<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LINQ与Lambda表达式]]></title>
    <url>%2F2019%2F02%2F28%2FLINQ%E4%B8%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[认识Lambda表达式、LINQ、学会使用 Lambda表达式基础从匿名方法 -&gt; Lambda表达式委托的典型用法 1234567891011121314151617181920212223242526272829303132namespace TypicalDelegateExample&#123; //1.定义一个委托 public delegate int AddDelegate(int i, int j);//2.定义一个MyClass类，放置一个满足AddDelegate委托要求的方法 class MyClass &#123; public int Add(int i,int j) &#123; return i + j; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; //3.定义一个委托变量 AddDelegate del = null; //4.实例化一个MyClass对象，并将其Add方法引用传给委托变量del MyClass obj = new MyClass(); del = obj.Add; //5.通过委托变量调用MyClass对象的Add()方法 int result=del(100, 200); Console.WriteLine("&#123;0&#125;+&#123;1&#125;=&#123;2&#125;",100,200,result); Console.ReadKey(true); &#125; &#125;&#125; 委托简化 -&gt;匿名方法-&gt;Lambda表达式 委托简化代码12345678910111213141516171819202122232425262728293031323334353637namespace UseAnonymousMethod&#123; //定义一个委托 public delegate int AddDelegate(int i, int j); class Program &#123; //使用委托类型参数的方法 public static void invokeDelegate(AddDelegate del, int i, int j) &#123; Console.WriteLine(del(i, j)); &#125; static void Main(string[] args) &#123; //利用C#匿名方法特性直接给委托变量赋值 AddDelegate del = delegate(int i, int j) &#123; return i + j; &#125;; //通过委托变量调用匿名方法 Console.WriteLine(del(100, 200)); //直接将匿名方法作为函数参数 invokeDelegate(delegate(int i, int j) &#123; return i + j; &#125;, 100, 200); //可以使用Lambda表达式进一步地简化 invokeDelegate((i, j) =&gt; i + j, 100, 200); Console.ReadKey(); &#125; &#125;&#125; 使用泛型委托示例123456789101112131415161718192021222324252627namespace UseGenericDelegate&#123; //定义泛型委托 public delegate T MyGenericDelegate&lt;T&gt;(T obj); class Program &#123; static void Main(string[] args) &#123; //使用匿名方法给泛型委托变量赋值 MyGenericDelegate&lt;int&gt; del = delegate(int vlaue) &#123; return vlaue * 2; &#125;; //调用泛型委托变量引用的匿名方法 Console.WriteLine(del(100)); //使用Lambda表达式给泛型委托变量赋值 MyGenericDelegate&lt;int&gt; del2 = (value) =&gt; value * 2; //调用泛型委托变量引用的Lambda表达式 Console.WriteLine(del2(100)); Console.ReadKey(); &#125; &#125;&#125; 系统预定义委托与Lambda表达式认识.NET基类库中几种预定义委托 Func&lt;&gt;委托 Action&lt;&gt; 委托 123456789101112131415161718192021222324252627282930313233343536namespace GenericDelegateInBaseClassLibrary&#123; class Program &#123; static void Main(string[] args) &#123; UseFuncDelegate(); UseActionDelegate(); Console.ReadKey(); &#125; private static void UseFuncDelegate() &#123; //使用匿名方法 Func&lt;int, int, long&gt; add = delegate(int a, int b) &#123; return a + b; &#125;; //使用Lambda表达式 Func&lt;int, int, int&gt; subtract = (a, b) =&gt; a - b; //调用示例 Console.WriteLine(add(5, 10)); Console.WriteLine(subtract(10, 5)); &#125; private static void UseActionDelegate() &#123; Action&lt;string&gt; show = (info) =&gt; &#123; Console.WriteLine(info); &#125;; show("Hello"); &#125; &#125;&#125; Comparison&lt;&gt;委托 Predicate&lt;&gt; 委托 Comparison&lt;&gt; Predicate&lt;&gt; 委托代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192namespace UseComparisonDelegate&#123; class MyClass &#123; public int Value; public string Information; &#125; class Program &#123; /// &lt;summary&gt; /// 创建一个MyClass类型的对象集合 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private static List&lt;MyClass&gt; GetMyClasList() &#123; List&lt;MyClass&gt; lst = new List&lt;MyClass&gt;(); Random ran = new Random(); MyClass obj = null; for (int i = 0; i &lt; 10; i++) &#123; obj = new MyClass &#123; Value = ran.Next(1, 100), Information = "object" + i.ToString() &#125;; lst.Add(obj); &#125; return lst; &#125; /// &lt;summary&gt; /// 打印一个MyClass对象集合的所有成员 /// &lt;/summary&gt; /// &lt;param name="lst"&gt;&lt;/param&gt; private static void PrintList(List&lt;MyClass&gt; lst) &#123; if (lst == null) return; foreach (MyClass obj in lst) Console.WriteLine("Infomation=&#123;0&#125;,Value=&#123;1&#125;", obj.Information, obj.Value); &#125; static void Main(string[] args) &#123; //使用Lambda表达式创建一个 Comparison&lt;MyClass&gt;委托对象 Comparison&lt;MyClass&gt; cmp = (obj1, obj2)=&gt; &#123; if (obj1.Value &gt; obj2.Value) return 1; else if (obj1.Value &lt; obj2.Value) return -1; else return 0; &#125;; List&lt;MyClass&gt; lst = GetMyClasList(); Console.WriteLine("生成的A对象集合为："); PrintList(lst); //调用泛型委托进行排序 lst.Sort(cmp); Console.WriteLine("排序后的结果为："); PrintList(lst); Console.ReadKey(); &#125; &#125;&#125;//替换上面的main static void Main(string[] args) &#123; //定义对象查询条件 Predicate&lt;MyClass&gt; pred = (elem)=&gt; &#123; if (elem.Value &gt; 50) return true; else return false; &#125;; List&lt;MyClass&gt; lst = GetAList(); Console.WriteLine("生成的A对象集合为："); PrintList(lst); //在集合中查询对象 MyClass foundElement= lst.Find(pred); if (foundElement != null) Console.WriteLine("找到了符合条件的对象。Infomation=&#123;0&#125;,Value=&#123;1&#125;", foundElement.Information, foundElement.Value); else Console.WriteLine("未找到符合条件的对象"); Console.ReadKey(); &#125; Lambda表达式基本语法 扩展方法 扩展方法是一种特殊的静态方法 扩展方法的特点（在静态类 指明适用类型） 扩展方法应用: .NET基类库提供的集合查询方法 扩展方法使用代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758namespace UseExtensionMethods&#123; /// &lt;summary&gt; /// 将被“动态”扩展的原始类型 /// &lt;/summary&gt; class Person &#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; &#125; /// &lt;summary&gt; /// 存放扩展方法的类 /// &lt;/summary&gt; static class PersonExtensions &#123; public static void SayHello(this Person person) &#123; Console.WriteLine("&#123;0&#125;说：“你好！”", person.Name); &#125; public static void SayHelloTo(this Person p1, Person p2) &#123; Console.WriteLine("&#123;0&#125;对&#123;1&#125;说：“您吃了吗？”",p1.Name,p2.Name); &#125; public static bool IsOlderThan(this Person p1, Person p2) &#123; return p1.Age &gt; p2.Age; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; var person = new Person() &#123; Name = "张三", Age = 30 &#125;; var person2 = new Person() &#123; Name = "李四", Age = 40 &#125;; person.SayHello(); person.SayHelloTo(person2); if (person.IsOlderThan(person2)) &#123; Console.WriteLine("&#123;0&#125;比&#123;1&#125;年纪大",person.Name,person2.Name); &#125; else &#123; Console.WriteLine("&#123;0&#125;并不比&#123;1&#125;年纪大", person.Name, person2.Name); &#125; Console.ReadKey(); &#125; &#125;&#125; 标准集合查询扩展方法查询扩展方法与LINQ的关系 常用集合查询扩展方法（筛选 数据投影、转换 集合代数运算） 各种查询代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166 //take扩展方法 从序列开头返回指定数量的连续元素//OfType&lt;int&gt;扩展方法 根据指定类型 筛选出集合元素//Concat 连接两个序列//union 并集//Except：差集。两个集合进行差集运算时，返回属于第一个集合 但不属于第二个集合的元素。//Intersect：交集。//Distinct ：从集合中移除重复值。namespace UseQueryMethods&#123; class Program &#123; static void Main(string[] args) &#123; //UseWhere(); //UseSelect(); // UseOrderBy(); UseSetAndAggregateMethods(); Console.ReadKey(); &#125; /// &lt;summary&gt; /// 使用Where扩展方法 /// &lt;/summary&gt; private static void UseWhere() &#123; //创建一个包容[1,100]内整数的数组 IEnumerable&lt;int&gt; nums = Enumerable.Range(1, 100); //使用Where扩展方法筛选出5的倍数，构成一个集合返回 var numList = nums.Where((num) =&gt; num % 5 == 0); Print("集合中5的倍数有：&#123;0&#125;", numList); &#125; /// &lt;summary&gt; /// Select方法示例 /// &lt;/summary&gt; private static void UseSelect() &#123; //fileList的类型为：string[] var fileList = Directory.GetFiles("c:\\", "*.*"); //files的类型为：IEnumerable&lt;FileInfo&gt; var files = fileList.Select( file =&gt; new FileInfo(file)); //infos是匿名对象的集合，此匿名对象包容两个属性：文件名和文件大小 var infos = files.Select(info =&gt; new &#123; FileName = info.Name, FileLength = info.Length &#125;); //输出结果 foreach (var info in infos) &#123; Console.WriteLine("&#123;0&#125;:&#123;1&#125;字节", info.FileName, info.FileLength); &#125; &#125; /// &lt;summary&gt; /// 数据排序示例 /// &lt;/summary&gt; private static void UseOrderBy() &#123; //先把String对象转换为FileInfo对象，之后再按文件大小降序排列 var fileInfos = Directory.GetFiles("C:\\") .Select(file =&gt; new FileInfo(file)) .OrderByDescending(fileInfo =&gt; fileInfo.Length); //输出结果 foreach (var info in fileInfos) &#123; Console.WriteLine("&#123;0&#125;:&#123;1&#125;字节", info.Name, info.Length); &#125; &#125; /// &lt;summary&gt; /// 集合与聚合操作 /// &lt;/summary&gt; private static void UseSetAndAggregateMethods() &#123; //创建一个多态对象集合 IEnumerable&lt;object&gt; stuff = new object[] &#123; new object(), 1, 3, 5, 7, 9, "\"thing\"", Guid.NewGuid() &#125;; //输出数组的内容 Print("Stuff集合的内容: &#123;0&#125;", stuff); //偶数集合 IEnumerable&lt;int&gt; even = new int[] &#123; 0, 2, 4, 6, 8 &#125;; Print("偶数集合的内容: &#123;0&#125;", even); //从多态集合stuff中筛选中整数元素（全部为奇数）组成一个新集合 IEnumerable&lt;int&gt; odd = stuff.OfType&lt;int&gt;(); Print("奇数集合的内容: &#123;0&#125;", odd); //求两个集合的并集 IEnumerable&lt;int&gt; numbers = even.Union(odd); Print("奇数与偶数集合的并集，成为一个整数集合: &#123;0&#125;", numbers); Print("整数集合与偶数集合的并集: &#123;0&#125;", numbers.Union(even)); Print("整数集合与偶数集合的差集：&#123;0&#125;", numbers.Except(even)); Print("整数集合与奇数集合相连接: &#123;0&#125;", numbers.Concat(odd)); Print("整数集合与偶数集合的交集: &#123;0&#125;", numbers.Intersect(even)); Print("整数集合与奇数集合连接，再删除重复值: &#123;0&#125;", numbers.Concat(odd).Distinct()); if (!numbers.SequenceEqual(numbers.Concat(odd).Distinct())) &#123; throw new Exception("Unexpectedly unequal"); &#125; else &#123; Print("反转整数集合: &#123;0&#125;", numbers.Reverse()); Print("求整数集合的平均值: &#123;0&#125;", numbers.Average()); Print("求整数集合的总和: &#123;0&#125;", numbers.Sum()); Print("求整数集合的最大值: &#123;0&#125;", numbers.Max()); Print("求整数集合的最小值: &#123;0&#125;", numbers.Min()); &#125; &#125; #region "辅助方法" /// &lt;summary&gt; /// 输出集合的内容 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; /// &lt;param name="format"&gt;&lt;/param&gt; /// &lt;param name="items"&gt;&lt;/param&gt; private static void Print&lt;T&gt;(string format, IEnumerable&lt;T&gt; items) &#123; StringBuilder text = new StringBuilder(); //take 从序列开头返回指定数量的连续元素 foreach (T item in items.Take(items.Count() - 1)) &#123; text.Append(item + ", "); &#125; text.Append(items.Last()); // 可更改为：string text=string.Join(",", items); Console.WriteLine(format, text); &#125; /// &lt;summary&gt; /// 按指定格式输出参数值 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; /// &lt;param name="format"&gt;&lt;/param&gt; /// &lt;param name="item"&gt;&lt;/param&gt; private static void Print&lt;T&gt;(string format, T item) &#123; Console.WriteLine(format, item); &#125; #endregion &#125;&#125; LINQ进化史独立数据处理功能 引入委托进行重构 引入泛型进行重构 引入扩展方法改造 使用yield属性优化性能 改写为LINQ查询语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352namespace EvolutionToLINQ&#123; class Program &#123; static void Main(string[] args) &#123; //FindOddNumbers(); //FindOddNumbers2(); //FindOddOrEvenNumbers(); //GenericFindOddOrEvenNumbers(); //GenericFindOddOrEvenNumbers2(); //FindOddOrEvenNumbersUseLambda(); //FindOddOrEvenNumbersUseExtensionMethod(); //FindOddOrEvenNumbersUseExtensionMethod2(); //FindOddNumbersUseWhere(); //FindOddNumbersUseLINQ(); Console.ReadKey(); &#125; #region "原始版本" /// &lt;summary&gt; /// 查找所有的奇数 /// &lt;/summary&gt; static void FindOddNumbers() &#123; //生成从1到10的整数集合 var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; //找出所有的奇数，放到List&lt;int&gt;集合中 var result = new List&lt;int&gt;(); foreach (var num in nums) &#123; if (IsOdd(num)) &#123; result.Add(num); &#125; &#125; //输出结果 foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; /// &lt;summary&gt; /// 判断某数是否为奇数 /// &lt;/summary&gt; /// &lt;param name="num"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; static bool IsOdd(int num) &#123; return num % 2 != 0; &#125; #endregion #region "数据处理功能独立" /// &lt;summary&gt; /// 将数据处理功能外置为独立的方法 /// &lt;/summary&gt; static void FindOddNumbers2() &#123; //生成从1到10的整数集合 var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; //找出所有满足条件的数，放到集合中 var result = FilterIntegers(nums); //输出结果 foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; static IEnumerable&lt;int&gt; FilterIntegers(IEnumerable&lt;int&gt; list) &#123; //找出所有的奇数，放到List&lt;int&gt;集合中 var result = new List&lt;int&gt;(); foreach (var num in list) &#123; if (IsOdd(num)) &#123; result.Add(num); &#125; &#125; return result; &#125; #endregion #region "引入委托" //定义一个新委托 public delegate bool PredicateDelegate(int value); /// &lt;summary&gt; /// 让外界指定数据筛选的方法 /// &lt;/summary&gt; /// &lt;param name="list"&gt;&lt;/param&gt; /// &lt;param name="predicate"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; static IEnumerable&lt;int&gt; FilterIntegers(IEnumerable&lt;int&gt; list, PredicateDelegate predicate) &#123; //找出所有的偶数，放到List&lt;int&gt;集合中 var result = new List&lt;int&gt;(); foreach (var num in list) &#123; if (predicate(num)) &#123; result.Add(num); &#125; &#125; return result; &#125; /// &lt;summary&gt; /// 新增一个“偶数”判断方法 /// &lt;/summary&gt; /// &lt;param name="num"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; static bool IsEven(int num) &#123; return num % 2 == 0; &#125; static void FindOddOrEvenNumbers() &#123; //生成从1到10的整数集合 var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; //现在在外部就可以“临时”指定到底是需要偶数还是奇数 var result = FilterIntegers(nums, IsEven); //result = FilterIntegers(nums, IsOdd); //输出结果 foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; #endregion #region "引入泛型" //定义一个新的泛型委托 public delegate bool PredicateGenericDelegate&lt;T&gt;(T value); //修改数据过滤方法 static IEnumerable&lt;T&gt; Filter&lt;T&gt;(IEnumerable&lt;T&gt; list, PredicateGenericDelegate&lt;T&gt; predicate) &#123; //找出所有的偶数，放到List&lt;int&gt;集合中 var result = new List&lt;T&gt;(); foreach (var num in list) &#123; if (predicate(num)) &#123; result.Add(num); &#125; &#125; return result; &#125; static void GenericFindOddOrEvenNumbers() &#123; //生成从1到10的整数集合 var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; //现在在外部就可以“临时”指定到底是需要偶数还是奇数 var result = Filter(nums, IsEven); //result = Filter(nums, IsOdd); //输出结果 foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; #endregion #region "使用.NET预定义委托" static IEnumerable&lt;T&gt; Filter2&lt;T&gt;(IEnumerable&lt;T&gt; list, Func&lt;T, bool&gt; predicate) &#123; //找出所有的偶数，放到List&lt;int&gt;集合中 var result = new List&lt;T&gt;(); foreach (var num in list) &#123; if (predicate(num)) &#123; result.Add(num); &#125; &#125; return result; &#125; static void GenericFindOddOrEvenNumbers2() &#123; //生成从1到10的整数集合 var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; //现在在外部就可以“临时”指定到底是需要偶数还是奇数 var result = Filter2(nums, IsEven); result = Filter2(nums, IsOdd); //输出结果 foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; #endregion #region "使用Lambda表达式" static void FindOddOrEvenNumbersUseLambda() &#123; //生成从1到10的整数集合 var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; //现在在外部就可以“临时”指定到底是需要偶数还是奇数 var result = Filter2(nums, num =&gt; num % 2 == 0); //result = Filter2(nums, num =&gt; num % 2 != 0); //输出结果 foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; #endregion #region "引入扩展方法特性" static void FindOddOrEvenNumbersUseExtensionMethod() &#123; //生成从1到10的整数集合 var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; var result = nums.Filter(num =&gt; num % 2 == 0); //result = nums.Filter(nums, num =&gt; num % 2 != 0); //输出结果 foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; #endregion #region "优化后的扩展方法" static void FindOddOrEvenNumbersUseExtensionMethod2() &#123; var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; var result = nums.AdvancedFilter(num =&gt; num % 2 != 0) .AdvancedFilter(num =&gt; num % 3 != 0); foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; #endregion #region ".NET基类库中的Where扩展方法" static void FindOddNumbersUseWhere() &#123; var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; //Where方法可以级联，完成筛选出所有不是3的倍数的奇数的功能 var result = nums.Where(num =&gt; num % 2 != 0) .Where(num =&gt; num % 3 != 0); foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; #endregion #region "使用LINQ让代码更易读" static void FindOddNumbersUseLINQ() &#123; var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; //LINQ查询就象数据库的SQL命令 var result = from num in nums where num % 2 != 0 &amp;&amp; num % 3 != 0 select num; foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; #endregion &#125; static class MyExtensions &#123; public static IEnumerable&lt;T&gt; Filter&lt;T&gt;(this IEnumerable&lt;T&gt; list, Func&lt;T, bool&gt; predicate) &#123; //找出所有的符合条件的数，放到List&lt;int&gt;集合中 var result = new List&lt;T&gt;(); foreach (var num in list) &#123; if (predicate(num)) &#123; result.Add(num); &#125; &#125; return result; &#125; public static IEnumerable&lt;T&gt; AdvancedFilter&lt;T&gt;(this IEnumerable&lt;T&gt; list, Func&lt;T, bool&gt; predicate) &#123; //找出所有的符合条件的数，返回给外界 foreach (var num in list) &#123; if (predicate(num)) &#123; yield return num; &#125; &#125; &#125; /// &lt;summary&gt; /// 自己实现的Where扩展方法，其功能与.NET基类库中所提供的类似 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; /// &lt;param name="list"&gt;&lt;/param&gt; /// &lt;param name="predicate"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static IEnumerable&lt;T&gt; Where&lt;T&gt;(this IEnumerable&lt;T&gt; list, Func&lt;T, bool&gt; predicate) &#123; //找出所有的符合条件的数，返回给外界 foreach (var num in list) &#123; if (predicate(num)) &#123; yield return num; &#125; &#125; &#125; &#125;&#125; LINQ基础LINQ是什么 LINQ技术框架 LINQ使用步骤 类型推断和延迟特性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950namespace IntroToLINQ&#123; class Program &#123; static void Main(string[] args) &#123; UseLinq(); //UseExtensionMethods(); Console.ReadKey(); &#125; private static void UseLinq() &#123; // 1. 指定数据源 var numbers = new int[] &#123; 0, 1, 2, 3, 4, 5, 6 &#125;; // 2. 创建查询表达式 var numQuery = from num in numbers where (num % 2) == 0 select num; // 3. 执行查询 foreach (int num in numQuery) &#123; Console.Write("&#123;0&#125; ", num); &#125; &#125; static void UseExtensionMethods() &#123; IEnumerable&lt;int&gt; numQuery = new int[] &#123; 0, 1, 2, 3, 4, 5, 6 &#125; .Where&lt;int&gt;( delegate(int num) &#123; return (num % 2) == 0; &#125; ); foreach (int num in numQuery) &#123; Console.Write("&#123;0&#125; ", num); &#125; &#125; &#125;&#125; LINQ编程技巧基本技巧使用逻辑运算符 混用LINQ查询和扩展方法 OrderBy字句使用多字段排序 使用匿名对象封装感兴趣的数据 引入新的变量暂存查询结果 LINQ中直接调用本地方法 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153namespace LINQExamples&#123; class Program &#123; static void Main(string[] args) &#123; //TestLogicalOperator(); //TestDistinct(); //TestOrderBy(); //TestAnonymousObject(); TestLetStatement(); // TestNativeMethod(); Console.ReadKey(); &#125; #region "使用C#的逻辑运算符" static void TestLogicalOperator() &#123; IEnumerable&lt;FileInfo&gt; files = from fileName in Directory.GetFiles("C:\\") where File.GetLastWriteTime(fileName) &lt; DateTime.Now.AddDays(-1) &amp;&amp; Path.GetExtension(fileName).ToUpper() == ".TXT" select new FileInfo(fileName); foreach (var file in files) &#123; Console.WriteLine(file); &#125; &#125; #endregion #region "Distinct示例：消除重复项" static void TestDistinct() &#123; Console.WriteLine("Enumerable类的所有公有成员："); ListMemberNamesOfEnumerable(); &#125; /// &lt;summary&gt; /// 列出Enumerable类的所有公有成员（除去重复的成员） /// &lt;/summary&gt; static void ListMemberNamesOfEnumerable() &#123; MemberInfo[] members = typeof(Enumerable).GetMembers( BindingFlags.Static | BindingFlags.Public); //var methods = (from method in members // select method.Name); var methods = (from method in members select method.Name).Distinct(); int count = 0; foreach (string method in methods) &#123; count++; Console.WriteLine(" &#123;0&#125;: &#123;1&#125;,", count, method); &#125; &#125; #endregion #region "排序" static void TestOrderBy() &#123; IEnumerable&lt;FileInfo&gt; files = from fileName in Directory.GetFiles("C:\\") orderby (new FileInfo(fileName)).Length, fileName ascending select new FileInfo(fileName); foreach (var file in files) &#123; Console.WriteLine("&#123;0&#125; &#123;1&#125;字节", file.Name, file.Length); &#125; &#125; #endregion #region"动态创建匿名对象的示例" static void TestAnonymousObject() &#123; var files = from fileName in Directory.GetFiles("C:\\") select new &#123; Name = fileName, Length = new FileInfo(fileName).Length &#125;; foreach (var file in files) &#123; Console.WriteLine("&#123;0&#125;:&#123;1&#125;字节", file.Name, file.Length); &#125; &#125; #endregion #region "引入新的范围变量暂存查询结果" static void TestLetStatement() &#123; IEnumerable&lt;FileInfo&gt; files = from fileName in Directory.GetFiles("C:\\") let file = new FileInfo(fileName) orderby file.Length, fileName select file; foreach (var file in files) &#123; Console.WriteLine("&#123;0&#125;:&#123;1&#125;字节", file.Name, file.Length); &#125; &#125; #endregion #region"使用本地方法" static void TestNativeMethod() &#123; // 数据源. int[] numbers = &#123; 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 &#125;; //查找所有偶数 var queryEvenNums = from num in numbers where IsEven(num) select num; // 执行查询 foreach (var s in queryEvenNums) &#123; Console.Write(s.ToString() + " "); &#125; &#125; /// &lt;summary&gt; /// 判断一个数是否为偶数 /// &lt;/summary&gt; /// &lt;param name="num"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static bool IsEven(int num) &#123; if (num % 2 == 0) return true; return false; &#125; #endregion &#125;&#125; 分组 分组的基本方式 分组数据的读取 使用into子句针对分组进行进一步处理 实现“非此即彼”的分组 多段分组 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210namespace LINQGroupExamples&#123; public class Student &#123; /// &lt;summary&gt; /// 姓名 /// &lt;/summary&gt; public string Name &#123; get; set; &#125; /// &lt;summary&gt; /// 籍贯 /// &lt;/summary&gt; public string City &#123; get; set; &#125; /// &lt;summary&gt; /// 考试成绩 /// &lt;/summary&gt; public List&lt;int&gt; Scores &#123; get; set; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; //IntroduceGroup(); //UseGroupInto(); //TestBooleanGroup(); TestMultiGroup(); Console.ReadKey(); &#125; #region "认识分组" static void IntroduceGroup() &#123; List&lt;Student&gt; students = new List&lt;Student&gt; &#123; new Student &#123;Name="张三", City="北京"&#125;, new Student &#123;Name="李四", City="上海"&#125;, new Student &#123;Name="王五", City="北京"&#125;, new Student &#123;Name="赵六", City="重庆"&#125;, new Student &#123;Name="马七", City="北京"&#125; , new Student &#123;Name="牛八", City="上海"&#125; &#125;; // studnetQuery类型为：IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt; var studnetQuery = from student in students group student by student.City; //studentGroup类型为：IGrouping&lt;string, Student&gt; foreach (var studentGroup in studnetQuery) &#123; Console.WriteLine("\n====================="); Console.WriteLine("在&#123;0&#125;的学生清单：", studentGroup.Key); Console.WriteLine("====================="); int count = 0; foreach (Student stu in studentGroup) &#123; count++; Console.WriteLine("&#123;0&#125;:&#123;1&#125;(&#123;2&#125;)", count, stu.Name, stu.City); &#125; &#125; &#125; #endregion #region "分组后进一步处理" static void UseGroupInto() &#123; //一个单词数组作为数据源 string[] words = &#123; "blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese", "elephant", "umbrella", "anteater" &#125;; // 按5个原音字母a、e、i、o、u将单词分组 var wordGroups = from w in words group w by w[0] into grps where (grps.Key == 'a' || grps.Key == 'e' || grps.Key == 'i' || grps.Key == 'o' || grps.Key == 'u') select grps; // 执行查询 foreach (var wordGroup in wordGroups) &#123; Console.WriteLine("以原音字母“&#123;0&#125;”开头的单词有：", wordGroup.Key); foreach (var word in wordGroup) &#123; Console.WriteLine(" &#123;0&#125;", word); &#125; &#125; &#125; #endregion #region "“非此即彼”的分组" static void TestBooleanGroup() &#123; List&lt;Student&gt; students = GetStudents(); // 按true或false分组 // 查询结果类型为：IEnumerable&lt;IGrouping&lt;bool, Student&gt;&gt; var booleanGroupQuery = from student in students group student by HasFailed(student.Scores); //输出查询结果 foreach (var studentGroup in booleanGroupQuery) &#123; Console.WriteLine(); Console.WriteLine(studentGroup.Key == true ? "有不及格课程的学生" : "成绩优秀的学生"); foreach (var student in studentGroup) &#123; Console.WriteLine(" &#123;0&#125;，平均分：&#123;1&#125;", student.Name, student.Scores.Average()); &#125; &#125; &#125; /// &lt;summary&gt; /// 创建示例数据 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; static List&lt;Student&gt; GetStudents() &#123; List&lt;Student&gt; students = new List&lt;Student&gt; &#123; new Student &#123;Name="张三", Scores= new List&lt;int&gt; &#123;97, 72, 81, 60&#125;&#125;, new Student &#123;Name="李四", Scores= new List&lt;int&gt; &#123;75, 84, 91, 39&#125;&#125;, new Student &#123;Name="王五", Scores= new List&lt;int&gt; &#123;99, 89, 91, 95&#125;&#125;, new Student &#123;Name="赵六", Scores= new List&lt;int&gt; &#123;72, 81, 65, 84&#125;&#125;, new Student &#123;Name="马七", Scores= new List&lt;int&gt; &#123;97, 89, 85, 82&#125;&#125; &#125;; return students; &#125; /// &lt;summary&gt; /// 判断成绩单中是否有“挂红灯”的课程 /// &lt;/summary&gt; /// &lt;param name="Scores"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; static bool HasFailed(List&lt;int&gt; Scores) &#123; foreach (int score in Scores) &#123; if (score &lt; 60) return true; &#125; return false; &#125; #endregion #region "多段分组" static void TestMultiGroup() &#123; List&lt;Student&gt; students = GetStudents(); // 查询结果类型为：IEnumerable&lt;IGrouping&lt;string, Student&gt; var booleanGroupQuery = from student in students group student by GroupKey(student.Scores); //输出查询结果 foreach (var studentGroup in booleanGroupQuery) &#123; Console.WriteLine(); Console.WriteLine(studentGroup.Key + "："); foreach (var student in studentGroup) &#123; Console.WriteLine(" &#123;0&#125;，平均分：&#123;1&#125;", student.Name, student.Scores.Average()); &#125; &#125; &#125; public static string GroupKey(List&lt;int&gt; Scores) &#123; //计算平均分，并取整 int avg = (int)Scores.Average(); string ret = ""; switch (avg / 10) //整除以10 &#123; case 10: case 9: ret = "优"; break; case 8: ret = "良"; break; case 7: ret = "中"; break; case 6: ret = "及格"; break; default: ret = "不及格"; break; &#125; return ret; &#125; #endregion &#125;&#125;]]></content>
      <categories>
        <category>C#-学习</category>
        <category>基础入门到进阶-金旭亮</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件化开发和单元测试]]></title>
    <url>%2F2019%2F02%2F27%2F%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%92%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[什么叫组件化开发？ 组件化开发概述软件系统开发面临的困境 用什么来描述组件实现的功能？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778namespace UseCOMServer&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; //Word对象 private Word.Application wordapp = null; //文件名 private string DocFileName &#123; get &#123; return txtFileName.Text; &#125; set &#123; txtFileName.Text = value; &#125; &#125; private void btnChooseFile_Click(object sender, EventArgs e) &#123; ChooseFile(); &#125; private void btnPrintPreview_Click(object sender, EventArgs e) &#123; PrintPreview(DocFileName); &#125; /// &lt;summary&gt; /// 选择要打开的Word文档 /// &lt;/summary&gt; private void ChooseFile() &#123; if (openFileDialog1.ShowDialog() == DialogResult.OK) &#123; //设定文件名 DocFileName = openFileDialog1.FileName; //激活打印预览按钮 btnPrintPreview.Enabled = true; &#125; &#125; /// &lt;summary&gt; /// 打印预览 /// &lt;/summary&gt; /// &lt;param name="wordFileName"&gt;&lt;/param&gt; private void PrintPreview(String wordFileName) &#123; if (String.IsNullOrEmpty(wordFileName)) &#123; return; &#125; //创建Word对象 if (wordapp == null) wordapp = new Microsoft.Office.Interop.Word.Application(); //使用命名参数和可选参数调用Word的功能 Word.Document doc = wordapp.Documents.Open(FileName: wordFileName); //打印预览 doc.PrintPreview(); //显示Word主窗体 wordapp.Visible = true; &#125; private void btnExit_Click(object sender, EventArgs e) &#123; Close(); &#125; &#125;&#125; 设计组件的基本原则 为复用而设计 考虑组建功能集合大小 组件化开发步骤 .NET组件化开始示例天下一统版 体制改革版 诸侯割据版 借鸡生蛋版 总结 .NET组件化开发技术基础什么叫程序集 程序集内部结构 “对外接口最小化”原则 组建依赖 组件版本 Nuget管理组件 单元测试软件测试概述 理解单元测试 单元测试编程技巧 1234567891011121314151617181920212223242526272829303132333435363738namespace ClassLib&#123; public class MyClass &#123; //求一个数的倍数 public int DoubleValue(int i) &#123; return i * 2; &#125; //计算从[from,to]中所有整数的和 public int Sum(int from, int to) &#123; if (from &gt; to) &#123; throw new ArgumentException("参数from必须小于to"); &#125; int sum = 0; for (int i = from; i &lt;= to; i++) &#123; sum += i; &#125; return sum; &#125; public const String AgeErrorString = "生日必须小于当前日期"; //给定一个人的生日，计算他的年纪 public int CaculateAge(DateTime Birthday) &#123; if (DateTime.Now &lt; Birthday) &#123; throw new ArgumentOutOfRangeException(AgeErrorString); &#125; return DateTime.Now.Year - Birthday.Year; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041namespace ClassLibTestProject&#123; [TestClass] public class InitializeAndCleanUpTest &#123; [TestInitialize] public void TestInitialize() &#123; Console.WriteLine("Begin Test"); &#125; [TestCleanup] public void TestCleanup() &#123; Console.WriteLine("Test finished"); &#125; [ClassInitialize] public static void MyClassInitialize(TestContext context) &#123; Console.WriteLine("Class is Initialized"); &#125; [ClassCleanup] public static void MyClassCleanup() &#123; Console.WriteLine("Class clean up"); &#125; [TestMethod] public void TestMethod1() &#123; Console.WriteLine("Running TestMethod1"); &#125; [TestMethod] public void TestMethod2() &#123; Console.WriteLine("Running TestMethod2"); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455namespace ClassLibTestProject&#123; [TestClass] public class MyClassTest &#123; public TestContext TestContext &#123; get; set; &#125; [TestMethod] public void DoubleValueTest() &#123; //Arrange:准备 MyClass target = new MyClass(); //设定测试用例 int value = 1; int expected = 2; //Act:执行 int actual = target.DoubleValue(value); //Assert:断言 Assert.AreEqual(expected, actual); &#125; [TestMethod] [ExpectedException(typeof(ArgumentException))] public void SumExceptionTest() &#123; MyClass target = new MyClass(); target.Sum(100, 50); &#125; [TestMethod] public void CalculateAgeOutOfRangeTest() &#123; try &#123; //Arrange:准备 MyClass target = new MyClass(); target.CaculateAge(DateTime.Now.AddDays(1)); &#125; catch (ArgumentOutOfRangeException e) &#123; StringAssert.Contains(e.Message, MyClass.AgeErrorString); return; &#125; Assert.Fail("No exception was thrown."); &#125; &#125;&#125; 123456789101112131415161718192021namespace ClassLibTestProject&#123; [TestClass] public class StringUtilsTest &#123; [TestMethod] public void ReverseWordTest() &#123; var OriginalString = "This is a string"; var ActualResult = StringUtils.Reverse(OriginalString); Assert.AreEqual("string a is This", ActualResult); &#125; [TestMethod] public void ReverseWordTest2() &#123; var OriginalString = "This is a string"; var ActualResult = StringUtils.Reverse(OriginalString); Assert.AreEqual("string a is This", ActualResult); &#125; &#125;&#125; 关于单元测试 编写单元测试原则 TDD]]></content>
      <categories>
        <category>C#-学习</category>
        <category>基础入门到进阶-金旭亮</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[委托-事件-对象协作详解]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%A7%94%E6%89%98-%E4%BA%8B%E4%BB%B6-%E5%AF%B9%E8%B1%A1%E5%8D%8F%E4%BD%9C%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[理解委托、事件、对象之间协作关系 委托委托引例 详解委托类型 委托组合与分解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273namespace MulticastDelegateInvocationList&#123; /// &lt;summary&gt; /// 定义一个委托变量 /// &lt;/summary&gt; /// &lt;param name="value"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public delegate int MyDelegate(int value); /// &lt;summary&gt; /// MyClass类中的两个方法Func1和Func2符合委托的要求 /// &lt;/summary&gt; public class MyClass &#123; public int Func1(int argument) &#123; Console.WriteLine("Func1: i=&#123;0&#125;", argument); return argument; &#125; public int Func2(int argument) &#123; argument *= 2; Console.WriteLine("Func2: i=&#123;0&#125;", argument); return argument; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; MyClass obj = new MyClass(); MyDelegate del1 = new MyDelegate(obj.Func1); del1 += new MyDelegate(obj.Func2); //上面两句可以简写为以下形式： //MyDelegate del1 = obj.Func1; //del1 += obj.Func2; //获取方法调用列表 Delegate[] ds = del1.GetInvocationList(); Console.WriteLine("del1的委托调用列表中包含&#123;0&#125;个方法", ds.GetLength(0)); del1(5); //先调用obj.Func1(),再调用obj.Func2() MyDelegate del2 = obj.Func1; del2 += obj.Func2; Console.WriteLine("del2的委托调用列表中包含&#123;0&#125;个方法", del2.GetInvocationList().GetLength(0)); del2(5); //先调用obj.Func1(),再调用obj.Func2() //组合两个委托变量 MyDelegate mul = del1 + del2; ds = mul.GetInvocationList(); Console.WriteLine("合并del1和del2之后，新的委托变量mul的委托调用列表中包含&#123;0&#125;个方法", ds.GetLength(0)); int ret = mul(10); //获取委托调用列表最后一个方法的返回值 Console.WriteLine("合并之后，新委托变量mul的返回值 = &#123;0&#125;", ret); mul -= obj.Func2; ////取消以下这句注释，观察程序运行结果你发现了什么特性？ mul -= obj.Func2; mul -= obj.Func2; Console.WriteLine("移除Func2之后，委托变量mul的委托调用列表中包含&#123;0&#125;个方法", mul.GetInvocationList().GetLength(0)); ret = mul(10); //获取委托调用列表最后一个方法的返回值 Console.WriteLine("移除Func2之后，返回值 = &#123;0&#125;", ret); Console.ReadKey(); &#125; &#125;&#125; 定时回调 1234567891011121314151617181920212223242526272829303132namespace UseTimerCallback&#123; //用于向回调函数提供参数信息 class TaskInfo &#123; public int count = 0; &#125; class Program &#123; static void Main(string[] args) &#123; System.Console.WriteLine("敲任意键结束……"); TaskInfo ti=new TaskInfo() ; //创建Timer对象，将一个回调函数传给它，每隔一秒调用一次 // callback: 将要执行的方法 // state :包含回调方法使用的信息的对象，或NULL // dueTime: 调用回调之前的延迟时间(以毫秒为单位)。 // period: Timer tm = new Timer(ShowTime, ti , 0, 1000); System.Console.ReadKey(); tm.Dispose(); &#125; //被回调的函数 static void ShowTime(Object ti) &#123; TaskInfo obj = ti as TaskInfo; obj.count++; System.Console.WriteLine("(&#123;0&#125;)&#123;1&#125;", obj.count, DateTime.Now); &#125; &#125;&#125; 事件 事件三要素 利用委托实现自定义事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657namespace UseMultiDelegateExample&#123; //定义事件委托 public delegate void MyEventDelegate(int value ); //事件发布者类 public class Publisher &#123; public Publisher() &#123; Console.WriteLine("Publisher对象&#123;0&#125;创建", this.GetHashCode()); &#125; //利用多路委托变量保存多个事件响应者方法引用 public MyEventDelegate MyEvent; &#125; //事件响应者类 public class Subscriber &#123; public Subscriber() &#123; Console.WriteLine("Subscriber对象&#123;0&#125;创建",this.GetHashCode()); &#125; //事件触发时的回调方法 public void MyMethod(int value ) &#123; Console.WriteLine("Subscriber对象&#123;0&#125;响应MyEvent事件：value=&#123;1&#125;", this.GetHashCode(), value); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; //一个事件源对象 Publisher p = new Publisher(); Console.WriteLine(); //两个事件响应者 Subscriber s1 = new Subscriber(); Subscriber s2 = new Subscriber(); //挂接事件响应方法 p.MyEvent += s1.MyMethod; p.MyEvent += s2.MyMethod; Console.WriteLine("\n直接调用委托变量触发事件MyEvent\n"); //直接调用委托变量，代表触发事件 p.MyEvent(new Random().Next(1,100)); Console.ReadKey(); &#125; &#125;&#125; 123456789Publisher对象46104728创建Subscriber对象12289376创建Subscriber对象43495525创建直接调用委托变量触发事件MyEventSubscriber对象12289376响应MyEvent事件：value=58Subscriber对象43495525响应MyEvent事件：value=58 C#引入关键字event用于自定义事件委托变量MyEvent前有一个event关键字,直接用委托的方式调用会编译错误！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667namespace UseEventExample&#123; //定义事件委托 public delegate void MyEventDelegate(int value); //事件发布者类 public class Publisher &#123; public Publisher() &#123; Console.WriteLine("Publisher对象&#123;0&#125;创建",this.GetHashCode()); &#125; //使用C#的event关键字定义一个事件 public event MyEventDelegate MyEvent; //激发事件 public void FireEvent(int EventArgu) &#123; if (MyEvent != null) &#123; Console.WriteLine("Publisher对象&#123;0&#125;触发事件，事件参数：&#123;1&#125;", this.GetHashCode(),EventArgu); MyEvent(EventArgu); &#125; &#125; &#125; //事件响应者类 public class Subscriber &#123; public Subscriber() &#123; Console.WriteLine("Subscriber对象&#123;0&#125;创建", this.GetHashCode()); &#125; //事件触发时的回调方法 public void MyMethod(int value) &#123; Console.WriteLine("MyEvent事件触发：value=&#123;0&#125;,响应者：&#123;1&#125;", value, this.GetHashCode()); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; Publisher p = new Publisher(); Console.WriteLine(); Subscriber s1 = new Subscriber(); Subscriber s2 = new Subscriber(); //挂接事件响应代码 p.MyEvent += s1.MyMethod; p.MyEvent += s2.MyMethod; //委托变量MyEvent前有一个event关键字， //所以无法直接调用Publisher类的MyEvent方法 //以下代码无法通过编译 //p.MyEvent(100); //只能通过Publisher类的公有方法间接地触发事件 Console.WriteLine("\n通过Publisher对象的公有方法触发事件\n"); p.FireEvent(new Random().Next(1, 100)); Console.ReadKey(); &#125; &#125;&#125; event关键字的功用 .NET事件揭秘 “Click”事件探秘 小结 运行时设定事件的响应函数 为事件重复追加响应方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051namespace UseEventHandler2&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; /// &lt;summary&gt; /// 借的钱 /// &lt;/summary&gt; private int LoanMoney = 0; /// &lt;summary&gt; /// 借钱的次数 /// &lt;/summary&gt; private int LoanCount = 0; /// &lt;summary&gt; /// 向黄世仁借钱 /// &lt;/summary&gt; private void LoanFromHuang() &#123; btnSum.Enabled = true; LoanMoney = 0; //追加事件响应函数 btnSum.Click += new EventHandler(btnSum_Click); lblLoanCount.Text = string.Format("&#123;0&#125; 次", ++LoanCount); &#125; /// &lt;summary&gt; /// 杨白劳看看欠了黄世仁多少钱 /// &lt;/summary&gt; private void ShowLoanState() &#123; LoanMoney += 100; lblLoanMoney.Text = string.Format("&#123;0&#125; 元", LoanMoney); lblLoanMoney.Refresh(); Thread.Sleep(300); btnSum.Enabled = false; &#125; private void btnLoanFromHuang_Click(object sender, EventArgs e) &#123; LoanFromHuang(); &#125; void btnSum_Click(object sender, EventArgs e) &#123; ShowLoanState(); &#125; &#125;&#125; 单个方法响应多个对象同样事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253namespace ResponseToEvents&#123; public partial class frmEnterToTab : Form &#123; public frmEnterToTab() &#123; InitializeComponent(); //挂接事件 foreach (Control ctl in groupBox1.Controls) &#123; if (ctl is TextBox) (ctl as TextBox).KeyDown += this.EnterToTab; &#125; &#125; //回车移动焦点 private void EnterToTab(object sender, KeyEventArgs e) &#123; TextBox txt=null; if (e.KeyCode == Keys.Enter) &#123; groupBox1.SelectNextControl(sender as Control , true, true, true, true); //拥有焦点的文本框自动全选 txt=(sender as TextBox); if(txt!=null) txt.SelectAll(); &#125; &#125; &#125;&#125; // 摘要: // Activates the next control. // // 参数: // ctl: // The System.Windows.Forms.Control at which to start the search. // // forward: // true to move forward in the tab order; false to move backward in the tab order. // // tabStopOnly: // true to ignore the controls with the System.Windows.Forms.Control.TabStop property // set to false; otherwise, false. // // nested: // true to include nested (children of child controls) child controls; otherwise, // false. // // wrap: // true to continue searching from the first control in the tab order after the // last control has been reached; otherwise, false. // // 返回结果: // true if a control was activated; otherwise, false. 动态设定事件响应方法 123456789101112131415161718192021222324252627282930313233343536373839404142namespace DynamicEventsInvoke&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; //定义两个事件响应函数 private void Event1(Object sender,EventArgs e) &#123; MessageBox.Show("事件处理程序一"); &#125; private void Event2(Object sender,EventArgs e) &#123; MessageBox.Show("事件处理程序二"); &#125; private void RadioButton1_CheckedChanged(object sender, EventArgs e) &#123; RemoveAllHandler(); Button1.Click += Event1; &#125; private void RemoveAllHandler() &#123; Button1.Click -= Event1; Button1.Click -= Event2; &#125; private void RadioButton2_CheckedChanged(object sender, EventArgs e) &#123; RemoveAllHandler(); Button1.Click += Event2; &#125; &#125;&#125; 对象间的协作与信息交换 同一对象内部的信息交换 12345678910111213141516171819202122232425namespace ButtonCounterInSingleForm&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; //被应用程序处理的信息 private int counter = 0; //当用户点击按钮时，此方法被调用，整个信息处理流程被启动 private void btnClickMe_Click(object sender, EventArgs e) &#123; //处理信息 counter++; //传输信息 ShowInfo(); &#125; private void ShowInfo() &#123; //标签对象通过其公有属性接收外界传入的信息 lblCount.Text = string.Format("你单击了&#123;0&#125;次按钮。", counter); &#125; &#125;&#125; “主-&gt;从”对象间信息的传送 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647namespace MultiFormProgram1&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); frm = new frmOther(); //创建从窗体对象 frm.Show();//显示从窗体 &#125; private frmOther frm = null; //用于引用从窗体对象 private void btnSend_Click(object sender, EventArgs e) &#123; //SendMessageViaPublicProperty(); SendMessageViaPublicMethod(); &#125; private void SendMessageViaPublicProperty() &#123; if (txtUserInput.Text == "") &#123; MessageBox.Show("请输入一条信息", "提示", MessageBoxButtons.OK, MessageBoxIcon.Asterisk); //焦点回到文本框 txtUserInput.Focus(); return; &#125; //通过向从窗体的自定义属性赋值传送信息 frm.Info = txtUserInput.Text; &#125; private void SendMessageViaPublicMethod() &#123; if (txtUserInput.Text == "") &#123; MessageBox.Show("请输入一条信息", "提示", MessageBoxButtons.OK, MessageBoxIcon.Asterisk); //焦点回到文本框 txtUserInput.Focus(); return; &#125; //直接调用从窗体对象公有方法传送信息 frm.Receive(txtUserInput.Text); &#125; &#125;&#125; 1234567891011121314151617181920212223242526namespace MultiFormProgram1&#123; public partial class frmOther : Form &#123; public frmOther() &#123; InitializeComponent(); &#125; /// &lt;summary&gt; /// 公有只写属性，用Label显示外界传入的信息 /// &lt;/summary&gt; public string Info &#123; set &#123; lblInfo.Text ="老大说："+ value; &#125; &#125; public void Receive(String Info) &#123; lblInfo.Text = Info; &#125; &#125;&#125; “从-&gt;主”对象间信息的传送主窗体“主动”查询信息 1234567891011121314151617181920namespace MultiFormProgram2&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private void btnShowDialog_Click(object sender, EventArgs e) &#123; frmOther frm = new frmOther(); //依据从窗体提供的状态信息，决定不同的处理方式 if (frm.ShowDialog() == DialogResult.OK) lblInfo.Text = frm.UserInput; else lblInfo.Text = "用户取消了输入。"; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132namespace MultiFormProgram2&#123; public partial class frmOther : Form &#123; public frmOther() &#123; InitializeComponent(); &#125; //供主窗体对象提取信息的公有属性 public string UserInput &#123; get &#123; return txtUserInput.Text; &#125; &#125; private void btnOK_Click(object sender, EventArgs e) &#123; //设置本窗体关闭的“原因”，以供主窗体进行查询 this.DialogResult = DialogResult.OK; this.Close(); &#125; private void btnCancel_Click(object sender, EventArgs e) &#123; //设置本窗体关闭的“原因”，以供主窗体进行查询 this.DialogResult = DialogResult.Cancel; this.Close(); &#125; &#125;&#125; 从窗体“主动”汇报(重点) 12345678910111213141516171819202122232425namespace OtherFormToMainForm2&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private void btnShowDialog_Click(object sender, EventArgs e) &#123; //主窗体把自己的引用传给从窗体对象 frmOther frm = new frmOther(this); frm.Show(); &#125; /// &lt;summary&gt; /// 供从窗体调用，向主窗体“汇报”工作完成情况 /// &lt;/summary&gt; /// &lt;param name="Info"&gt;&lt;/param&gt; public void Report(String Info) &#123; lblInfo.Text = Info; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334namespace OtherFormToMainForm2&#123; public partial class frmOther : Form &#123; //用于保存主窗体对象引用 private frmMain mainForm = null; //从外部将主窗体对象“注入”进来 public frmOther(frmMain main) &#123; InitializeComponent(); mainForm = main; &#125; //在事件响应方法中“回调”主窗体对象的Report()方法 private void btnOK_Click(object sender, EventArgs e) &#123; if (String.IsNullOrEmpty(txtUserInput.Text.Trim())) &#123; mainForm.Report("用户没有输入文本"); &#125; else &#123; mainForm.Report(txtUserInput.Text); &#125; Close(); &#125; private void btnCancel_Click(object sender, EventArgs e) &#123; mainForm.Report("用户取消了操作"); Close(); &#125; &#125;&#125; 理解回调概念 示例 12345678namespace CallBackExample&#123; //实现回调的类必须实现此接口 public interface ICallBack &#123; void run(); &#125;&#125; 1234567891011namespace CallBackExample&#123; class CallBackClass:ICallBack &#123; public void run() &#123; //输出当前时间 System.Console.WriteLine(DateTime.Now ); &#125; &#125;&#125; 12345678910111213141516namespace CallBackExample&#123; class CallBackClass2:ICallBack &#123; #region ICallBack 成员 private int counter = 0; public void run() &#123; counter++; System.Media.SystemSounds.Asterisk.Play(); Console.WriteLine("I'm invoked " + counter.ToString() + " times"); &#125; #endregion &#125;&#125; 123456789101112131415161718192021222324namespace CallBackExample&#123; class Controller &#123; private List&lt;ICallBack&gt; CallBackObjects = new List&lt;ICallBack&gt;();//回调对象 public void AddCallBack(ICallBack callback) &#123; CallBackObjects.Add(callback); &#125; public void Begin() &#123; Console.WriteLine("敲任意键回调方法 , ESC键退出..."); while (Console.ReadKey(true).Key != ConsoleKey.Escape) &#123; Console.WriteLine(); foreach (ICallBack obj in CallBackObjects) obj.run(); &#125; &#125; &#125;&#125; 123456789101112131415namespace CallBackExample&#123; class Program &#123; static void Main(string[] args) &#123; //创建控制器对象，将提供给它的回调对象传入 Controller controller = new Controller(); controller.AddCallBack(new CallBackClass()); controller.AddCallBack(new CallBackClass2()); //启动控制器对象运行 controller.Begin(); &#125; &#125;&#125; 为什么使用接口？ 对象间消息双向传送 12345678910111213141516171819202122232425262728namespace TwoWayCommunicationInForms&#123; public partial class frmMain : Form &#123; private frmOther frm = null; //引用从窗体 public frmMain() &#123; InitializeComponent(); frm = new frmOther(this); frm.Show(); &#125; /// &lt;summary&gt; /// 向外界公开的方法 /// &lt;/summary&gt; /// &lt;param name="value"&gt;&lt;/param&gt; public void SetValue(int value) &#123; NumericUpDown1.Value = value; &#125; private void NumericUpDown1_ValueChanged(object sender, EventArgs e) &#123; //通过从窗体的公有属性向其传送信息 frm.WorkDownPercent = (int)NumericUpDown1.Value; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869namespace TwoWayCommunicationInForms&#123; public partial class frmOther : Form &#123; public frmOther(frmMain frm) &#123; InitializeComponent(); frmMainForm = frm; &#125; //引用主窗体 private frmMain frmMainForm = null; /// &lt;summary&gt; /// 允许外界设置进度条的数值 /// &lt;/summary&gt; public int WorkDownPercent &#123; get &#123; return ProgressBar1.Value; &#125; set &#123; ProgressBar1.Value = value; //显示信息 lblInfo.Text = String.Format("&#123;0&#125;%", ProgressBar1.Value); &#125; &#125; /// &lt;summary&gt; /// 修改进度条控件的值，IsIncrease属性用于确定是增加还是减少 /// &lt;/summary&gt; /// &lt;param name="IsIncrease"&gt;&lt;/param&gt; private void ChangeProgressBarValue(bool IsIncrease) &#123; if (IsIncrease) //增值 &#123; if (ProgressBar1.Value == 100) ProgressBar1.Value = 0; //重新开始 else ProgressBar1.Value += 2; &#125; else //减值 &#123; if (ProgressBar1.Value == 0) ProgressBar1.Value = 0; //不允许再减少了 else ProgressBar1.Value -= 2; &#125; //显示信息 lblInfo.Text = String.Format("&#123;0&#125;%", ProgressBar1.Value); //向主窗体的公有方法向其传送信息 frmMainForm.SetValue(ProgressBar1.Value); &#125; private void btnIncrease_Click(object sender, EventArgs e) &#123; ChangeProgressBarValue(true); &#125; private void btnDecrease_Click(object sender, EventArgs e) &#123; ChangeProgressBarValue(false); &#125; &#125;&#125; 在对象间广播信息(一到多) 使用对象集合 123456789101112131415161718192021222324252627282930313233343536namespace UseObjectCollection&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private void btnNewForm_Click(object sender, EventArgs e) &#123; NewForm(); &#125; //窗体对象集合 private List&lt;frmOther&gt; OtherForms = new List&lt;frmOther&gt;(); private void NewForm() &#123; //每新建一个窗体，就将其加入到OtherForms对象集合中 frmOther frm = new frmOther(); OtherForms.Add(frm); frm.Show(); &#125; private int counter = 0;//计数器 private void btnClickMe_Click(object sender, EventArgs e) &#123; counter++; //遍历从窗体对象集合，逐个回调其ShowCounter方法，计数器新值成为其参数 foreach (frmOther frm in OtherForms) &#123; frm.ShowCounter(counter); &#125; &#125; &#125;&#125; 123456789101112131415namespace UseObjectCollection&#123; public partial class frmOther : Form &#123; public frmOther() &#123; InitializeComponent(); &#125; //供主窗体“回调”，显示主窗体传入的计数器值 public void ShowCounter(int counter) &#123; lblInfo.Text = counter.ToString(); &#125; &#125;&#125; 使用委托 12345678910111213141516171819202122232425262728293031323334353637namespace UseDelegate&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; //将用于引用多个从窗体对象所挂接的“回调”方法 private Action&lt;int&gt; ReceiverMethods; private void btnNewForm_Click(object sender, EventArgs e) &#123; NewForm(); &#125; private void NewForm() &#123; frmOther frm = new frmOther(); //从窗体将自己的ShowCounter方法挂接到主窗体的委托变量ReceiverMethods上 ReceiverMethods += frm.ShowCounter; frm.Show(); &#125; private int counter = 0;//计数器 private void btnClickMe_Click(object sender, EventArgs e) &#123; counter++; if (ReceiverMethods != null) &#123; //调用委托调用链中的所有方法，传入当前的计数器值 ReceiverMethods(counter); &#125; &#125; &#125;&#125; 12345678910111213141516namespace UseDelegate&#123; public partial class frmOther : Form &#123; public frmOther() &#123; InitializeComponent(); &#125; public void ShowCounter(int counter) &#123; lblInfo.Text = counter.ToString(); &#125; &#125;&#125; 使用事件 123456789101112131415161718192021222324252627282930313233343536373839namespace UseEvent&#123; public delegate void MyClickDelegate(int counter); public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; //主窗体定义一个MyClick事件 public event MyClickDelegate MyClick; private void btnNewForm_Click(object sender, EventArgs e) &#123; NewForm(); &#125; private void NewForm() &#123; frmOther frm = new frmOther(); //从窗体对象将ShowCounter方法挂接到MyClick事件上，响应这个事件 MyClick += frm.ShowCounter; frm.Show(); &#125; private int counter = 0;//计数器 private void btnClickMe_Click(object sender, EventArgs e) &#123; counter++; //触发事件 if (MyClick != null) &#123; MyClick(counter); &#125; &#125; &#125;&#125; 12345678910111213141516namespace UseEvent&#123; public partial class frmOther : Form &#123; public frmOther() &#123; InitializeComponent(); &#125; public void ShowCounter(int counter) &#123; lblInfo.Text = counter.ToString(); &#125; &#125;&#125; 对象监控(多到一) 利用对象引用回调 123456789101112131415161718192021222324252627namespace ButtonCounterForMultiFormUseReference&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; //从窗体点击计数器 private int counter = 0; /// &lt;summary&gt; /// 显示累计按钮单击次数的结果 /// &lt;/summary&gt; public void ShowCounter() &#123; counter++; lblInfo.Text = counter.ToString(); &#125; private void btnShowOtherForm_Click(object sender, EventArgs e) &#123; frmOther frm = new frmOther(this); //在屏幕上显示窗体 frm.Show(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526namespace ButtonCounterForMultiFormUseReference&#123; public partial class frmOther : Form &#123; //使用对象注入的方式，在主从对象之间建立关联 public frmOther(frmMain main) &#123; InitializeComponent(); MainForm = main; &#125; private frmMain MainForm = null; private void btnClickMe_Click(object sender, EventArgs e) &#123; //调用主窗体的公有方法，显示按钮计数 //此处无需向主窗体传送任何信息，因为我们只需要统计点击次数 //如果确实有信息想发给主窗体，可以让主窗体定义一个有参数的公有方法或属性 //在此处将信息以实参（或直接向主窗体公有属性赋值）的方式传送给主窗体 if (MainForm != null) &#123; MainForm.ShowCounter(); &#125; &#125; &#125;&#125; 利用委托回调 123456789101112131415161718192021222324252627282930namespace ButtonCounterForMultiFormUseDelegate&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private int counter = 0; /// &lt;summary&gt; /// 显示累计按钮单击次数的结果 /// &lt;/summary&gt; private void ShowCounter() &#123; counter++; lblInfo.Text = counter.ToString(); &#125; private void btnShowOtherForm_Click(object sender, EventArgs e) &#123; frmOther frm = new frmOther(); //将主窗体的方法“挂接”到从窗体对象上 frm.CallBackMethod = this.ShowCounter; //在屏幕上显示从窗体 frm.Show(); &#125; &#125;&#125; 123456789101112131415161718192021222324namespace ButtonCounterForMultiFormUseDelegate&#123; public partial class frmOther : Form &#123; public frmOther() &#123; InitializeComponent(); &#125; //用于“回调”主窗体挂接的方法 public Action CallBackMethod = null; private void btnClickMe_Click(object sender, EventArgs e) &#123; //回调主窗体的方法，显示按钮计数 if (CallBackMethod != null) &#123; CallBackMethod(); &#125; &#125; &#125;&#125; 自定义事件 12345678910111213141516171819202122232425262728293031namespace ButtonCounterForMultiFormUseEvent&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private int counter = 0; /// &lt;summary&gt; /// 主窗体响应从窗体的MyClick事件 /// &lt;/summary&gt; private void ResponseToOtherFormMyClickEvent() &#123; counter++; lblCount.Text = counter.ToString(); &#125; private void btnNewOtherForm_Click(object sender, EventArgs e) &#123; frmOther frm = new frmOther(); //挂接从窗体事件响应函数 frm.MyClick += this.ResponseToOtherFormMyClickEvent; frm.Show(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728namespace ButtonCounterForMultiFormUseEvent&#123; /// &lt;summary&gt; /// 定义事件委托 /// &lt;/summary&gt; /// &lt;param name="?"&gt;&lt;/param&gt; public delegate void MyClickDelegate(); public partial class frmOther : Form &#123; public frmOther() &#123; InitializeComponent(); &#125; //自定义一个事件 public event MyClickDelegate MyClick; //在按钮单击事件中激发MyClick事件 private void btnClickMe_Click(object sender, EventArgs e) &#123; if (MyClick != null) &#123; MyClick(); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122namespace ButtonCounterForMultiFormUseStaticMethod&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; public void ShowCounter(int counter) &#123; lblCount.Text = counter.ToString(); &#125; private void btnNewOtherForm_Click(object sender, EventArgs e) &#123; frmOther frm = new frmOther(); frm.Show(); &#125; &#125;&#125; 12345678910111213141516namespace ButtonCounterForMultiFormUseStaticMethod&#123; public partial class frmOther : Form &#123; public frmOther() &#123; InitializeComponent(); &#125; private void btnClickMe_Click(object sender, EventArgs e) &#123; Program.NotifyClicked(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>C#-学习</category>
        <category>基础入门到进阶-金旭亮</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象基础进阶]]></title>
    <url>%2F2019%2F02%2F24%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[理解对象组合、复制、序列化、比较 对象组合 一对一对象组合 一对一对象组合实现 对象间的”关联”理解 一对一对象组合应用实例 一对多对象组合 一对多编程实例 认识列表框控件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869namespace OneToManyWinForm&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private void btnAdd_Click(object sender, EventArgs e) &#123; AddItem(); &#125; private void btnClear_Click(object sender, EventArgs e) &#123; listBox1.Items.Clear(); &#125; private void btnDelete_Click(object sender, EventArgs e) &#123; DeleteItem(); &#125; /// &lt;summary&gt; /// 添加选项 /// &lt;/summary&gt; private void AddItem() &#123; //不允许加空项 if (txtUserInput.Text.Trim() != "") &#123; listBox1.Items.Add(txtUserInput.Text); txtUserInput.Text = ""; &#125; &#125; /// &lt;summary&gt; /// 删除选项 /// &lt;/summary&gt; private void DeleteItem() &#123; if (listBox1.SelectedIndex != -1) &#123; listBox1.Items.RemoveAt(listBox1.SelectedIndex); &#125; &#125; /// &lt;summary&gt; /// 显示列表框中的当前选中项 /// &lt;/summary&gt; private void ShowSelectedItem() &#123; String SelectedItem = listBox1.SelectedItem == null ? "无" : listBox1.SelectedItem.ToString(); lblInfo.Text = String.Format("当前选中项为：&#123;0&#125;", SelectedItem); &#125; private void listBox1_SelectedIndexChanged(object sender, EventArgs e) &#123; ShowSelectedItem(); &#125; private void txtUserInput_KeyDown(object sender, KeyEventArgs e) &#123; //回车时直接加入列表 if (e.KeyCode == Keys.Enter) &#123; AddItem(); &#125; &#125; &#125;&#125; 建模实例分析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061namespace CarFactory&#123; class Program &#123; static void Main(string[] args) &#123; Car car = new Car(); Console.WriteLine("\n敲任意键启动汽车……\n"); Console.ReadKey(true); car.Start(); Console.WriteLine("\n敲任意键刹车……\n"); Console.ReadKey(true); car.Brake(); Console.WriteLine("\n敲任意键退出程序……\n"); Console.ReadKey(true); &#125; &#125; //代表发动机 class Engine &#123; public void Start() &#123; Console.WriteLine("发动机启动"); &#125; public void Stop() &#123; Console.WriteLine("发动机停止"); &#125; &#125; //汽车轮 class Wheel &#123; &#125; class Car &#123; private Engine _engine = new Engine(); private Wheel[] wheels = new Wheel[4]; public void Start() &#123; Console.WriteLine("插入钥匙，打火，启动……"); _engine.Start(); Console.WriteLine("启动成功，开始行驶"); &#125; public void Brake() &#123; Console.WriteLine("刹车！"); Stop(); &#125; public void Stop() &#123; _engine.Stop(); Console.WriteLine("汽车停车"); &#125; &#125; &#125; 自引用类 1234567891011namespace LinkListExample&#123; //链表节点 class LinkNode &#123; //保存数据 public object Data; //引用下一个链接节点 public LinkNode Next = null; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334namespace LinkListExample&#123; class Program &#123; static void Main(string[] args) &#123; //生成链表节点 LinkNode Head = new LinkNode()&#123; Data="Head"&#125;; LinkNode First = new LinkNode() &#123; Data = "First" &#125;; LinkNode Second = new LinkNode() &#123; Data = "Second" &#125;; LinkNode Tail = new LinkNode() &#123; Data = "Tail" &#125;; //建立链表 Head.Next = First; First.Next = Second; Second.Next = Tail; Console.WriteLine("链表己创建，其内容为："); //访问链表的全部节点 LinkNode node; node = Head; while (node != null) &#123; //从node.Data中取出节点数据，干一些事 if(node.Next!=null) Console.Write("&#123;0&#125;--&gt;", node.Data); else Console.Write("&#123;0&#125;", node.Data); node = node.Next;//移往下一个节点 &#125; Console.ReadKey(); &#125; &#125;&#125; 对象复制 对象的“浅复制” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091namespace ObjectCloneDemo&#123; #region "支持内容比对的简单对象" class MyClass &#123; private int MyClassValue = 100; public override string ToString() &#123; return "MyClassValue:" + MyClassValue; &#125; public override bool Equals(object obj) &#123; if (obj == null || obj is MyClass == false) &#123; return false; &#125; return MyClassValue == (obj as MyClass).MyClassValue; &#125; public override int GetHashCode() &#123; return MyClassValue; &#125; public static MyClass CloneObject(MyClass obj) &#123; MyClass newObj = new MyClass(); newObj.MyClassValue = obj.MyClassValue; //字段复制 return newObj; &#125; &#125; #endregion #region "组合的对象" class ClassB &#123; public int BValue = 200; &#125; class ClassA &#123; public int AValue = 100; public ClassB EmbedObject; //ClassA包容一个ClassB的对象 public ClassA() &#123; EmbedObject = new ClassB(); //创建被包容对象 &#125; public static ClassA CloneObject(ClassA obj) &#123; ClassA newObj = new ClassA(); newObj.AValue = obj.AValue; //字段复制 newObj.EmbedObject = obj.EmbedObject; //引用复制 return newObj; &#125; &#125; #endregion class Program &#123; static void Main(string[] args) &#123; //ObjectCopyViaFieldCopy(); ObjectCopyViaFieldCopy2(); Console.ReadKey(); &#125; /// &lt;summary&gt; /// 基于字段值拷贝的简单对象复制 /// &lt;/summary&gt; static void ObjectCopyViaFieldCopy() &#123; MyClass obj = new MyClass(); MyClass other = MyClass.CloneObject(obj); Console.WriteLine("原对象：&#123;0&#125;,新对象：&#123;1&#125;", obj, other); Console.WriteLine(obj == other); //false Console.WriteLine(obj.Equals(other));// true &#125; /// &lt;summary&gt; /// 基于字段值拷贝的组合对象复制 /// &lt;/summary&gt; static void ObjectCopyViaFieldCopy2() &#123; ClassA obj = new ClassA(); ClassA other = ClassA.CloneObject(obj); Console.WriteLine(obj == other); //false Console.WriteLine(obj.AValue == other.AValue); // true Console.WriteLine(obj.EmbedObject == other.EmbedObject);// true Console.WriteLine(obj.EmbedObject.BValue == other.EmbedObject.BValue); //true &#125; &#125;&#125; 对象的深复制 ICloneable接口 1234567891011121314151617181920212223242526272829303132333435363738394041namespace DeepCopy&#123; class ClassA : ICloneable &#123; public int AValue = 100; public ClassB EmbedObject; //ClassA包容一个ClassB的对象 public Object Clone() &#123; ClassA ObjA = new ClassA(); ObjA.AValue = this.AValue; ObjA.EmbedObject = (this.EmbedObject as ICloneable).Clone() as ClassB; return ObjA; &#125; &#125; class ClassB : ICloneable &#123; public int BValue = 200; public Object Clone() &#123; ClassB ObjB = new ClassB(); ObjB.BValue = this.BValue; return ObjB; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; ClassA ObjA = new ClassA(); ObjA.EmbedObject = new ClassB(); //开始克隆 ClassA other = (ObjA as ICloneable).Clone() as ClassA; Console.WriteLine(other.EmbedObject == ObjA.EmbedObject); //false Console.ReadKey(); &#125; &#125;&#125; 对象序列化(保存对象状态) 什么是流？(一连串有顺序的二进制数据) 使用流实现序列化 .NET基类库中提供的几种流对象 两种对象序列化方式 XML格式序列化实例 123456789101112131415161718192021222324namespace UseXmlSerializer&#123; public class MyClass &#123; public int IntField ; public string StringField ; &#125; class Program &#123; static void Main(string[] args) &#123; var Serializer = new XmlSerializer(typeof(MyClass)); MyClass obj = new MyClass() &#123; IntField = 100, StringField = "Hello" &#125;; //输出流:控制台窗口 Serializer.Serialize(Console.Out, obj); Console.ReadKey(); &#125; &#125;&#125; 12345&lt;?xml version="1.0" encoding="gb2312"?&gt;&lt;MyClass xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt; &lt;IntField&gt;100&lt;/IntField&gt; &lt;StringField&gt;Hello&lt;/StringField&gt;&lt;/MyClass&gt; 二进制格式序列化实例 1234567891011121314namespace SingleObjectSerialization&#123; //学生信息 [Serializable] class CollegeStudent &#123; //姓名 public String Name = "空"; //性别 public bool IsMale = true; //入学考试成绩 public int ScoreForEntranceExamination = 0; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111namespace SingleObjectSerialization&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); stu = new CollegeStudent(); //将学生默认信息显示在窗体上 this.ClearInputControls(); &#125; //学生对象 private CollegeStudent stu ; //将学生信息显示在窗体上 private void ShowStudentInfo(CollegeStudent obj) &#123; if (obj == null) return; this.txtName.Text = obj.Name; this.txtScore.Text = Convert.ToString(obj.ScoreForEntranceExamination); this.rdoMale.Checked = obj.IsMale ; this.rdoFemale.Checked = !obj.IsMale; &#125; //清除所有的输入控件到初始状态 private void ClearInputControls() &#123; this.txtName.Text = "空"; this.txtScore.Text ="0"; this.rdoMale.Checked = true; &#125; //更新对象信息 private void UpdateStudentObj(CollegeStudent stu) &#123; if (stu == null) return; stu.IsMale = rdoMale.Checked; stu.Name = txtName.Text; stu.ScoreForEntranceExamination = Convert.ToInt32(txtScore.Text); &#125; //保存对象到文件中 private void SaveToFile() &#123; String FileName = ""; this.saveFileDialog1.FileName = "Student"; this.UpdateStudentObj(stu); if (this.saveFileDialog1.ShowDialog() == DialogResult.OK) &#123; FileName = saveFileDialog1.FileName; SerializeObj(FileName,stu); &#125; &#125; //将CollegeStudent对象序列化到文件中 private void SerializeObj(String FileName,CollegeStudent stu) &#123; //创建FileStream对象 using (FileStream writer = new FileStream(FileName, FileMode.Create)) &#123; //创建格式化器对象 using System.Runtime.Serialization; IFormatter formatter = new BinaryFormatter(); //格式化器对象使用FileStream对象序列化对象 formatter.Serialize(writer, stu); MessageBox.Show("对象成功保存到文件:" + FileName); &#125; &#125; //从文件中装入对象 private void LoadFromFile() &#123; String FileName = ""; if (this.openFileDialog1.ShowDialog() == DialogResult.OK) &#123; FileName = openFileDialog1.FileName; this.ShowStudentInfo(DeserializeObj(FileName)); &#125; &#125; //从文件中反序列化对象 private CollegeStudent DeserializeObj(String FileName) &#123; using (FileStream reader = new FileStream(FileName, FileMode.Open)) &#123; //using System.Runtime.Serialization.Formatters.Binary IFormatter formatter = new BinaryFormatter(); return (CollegeStudent)formatter.Deserialize(reader); &#125; &#125; private void btnClear_Click(object sender, EventArgs e) &#123; this.ClearInputControls(); &#125; private void btnSaveObject_Click(object sender, EventArgs e) &#123; this.SaveToFile(); &#125; private void btnLoadObject_Click(object sender, EventArgs e) &#123; this.LoadFromFile(); &#125; &#125;&#125; 反序列化 使用内存流快速大批的复制对象 12345678910111213141516171819202122232425262728293031323334namespace ObjectCloneViaSerialization&#123; [Serializable] class MyClass &#123; public int Index = 1; &#125; class Program &#123; static void Main(string[] args) &#123; MyClass obj = new MyClass(); //创建一个内存流对象 using (MemoryStream ms = new MemoryStream()) &#123; IFormatter formator = new BinaryFormatter(); //将对象序列化到内存流中 formator.Serialize(ms, obj); //克隆100个对象 for (int i = 0; i &lt; 100; i++) &#123; //回到流的开头 偏移是0 枚举 开始 当前 结束 ms.Seek(0, SeekOrigin.Begin); //反序列化对象 obj = (formator.Deserialize(ms) as MyClass); obj.Index += i; //设置对象字段 Console.WriteLine("对象&#123;0&#125;已创建。", obj.Index); &#125; &#125; Console.ReadKey(); &#125; &#125;&#125; 程序退出保存状态 123456789101112namespace SaveFormStatus&#123; [Serializable] public class FormStatus &#123; public Color BackgroundColor &#123; get; set; &#125; public int Left &#123; get; set; &#125; public int Top &#123; get; set; &#125; public int Width &#123; get; set; &#125; public int Height &#123; get; set; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980namespace SaveFormStatus&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); LoadStatus(); &#125; private void btnChooseColor_Click(object sender, EventArgs e) &#123; if (colorDialog1.ShowDialog() == DialogResult.OK) &#123; BackColor = colorDialog1.Color; &#125; &#125; private FormStatus status = null; private void SaveStatus() &#123; status=new FormStatus(); status.BackgroundColor=this.BackColor; status.Left=this.Left; status.Top=this.Top; status.Width=this.Width; status.Height = this.Height; using(FileStream fs=new FileStream("FormStatus.cfg",FileMode.Create)) &#123; IFormatter formatter = new BinaryFormatter(); formatter.Serialize(fs, status); &#125; &#125; private void LoadStatus() &#123; try &#123; if (File.Exists("FormStatus.cfg")) &#123; using (FileStream fs = new FileStream("FormStatus.cfg", FileMode.Open)) &#123; IFormatter formatter = new BinaryFormatter(); status = formatter.Deserialize(fs) as FormStatus; if (status != null) &#123; this.BackColor = status.BackgroundColor; this.Left = status.Left; this.Top = status.Top; this.Width = status.Width; this.Height = status.Height; &#125; &#125; &#125; &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); &#125; &#125; private void frmMain_FormClosing(object sender, FormClosingEventArgs e) &#123; SaveStatus(); &#125; private void frmMain_Load(object sender, EventArgs e) &#123; &#125; &#125;&#125; 对象比较 实现IComparable接口 仅判断是否相等(重写Equals方法) 重写GetHashCode方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899namespace ObjectCompare&#123; /// &lt;summary&gt; /// 圆心 /// &lt;/summary&gt; public struct CircleCenter &#123; public double x; public double y; &#125; class Circle : IComparable, IComparable&lt;Circle&gt;, IEquatable&lt;Circle&gt; &#123; public double Radius = 0; //半径 public CircleCenter Center &#123; get; set; &#125; //圆心 //实现IComparable接口定义的方法 public int CompareTo(object obj) &#123; if (!(obj is Circle)) throw new ArgumentException("只能比对Cirlce对象"); return CompareTo(obj as Circle); &#125; //实现IComparable&lt;T&gt;接口定义的方法 public int CompareTo(Circle other) &#123; double ret = Math.Abs(other.Radius - this.Radius); if (ret &lt; 1e-3) return 0; if (other.Radius &lt; this.Radius) return 1; return -1; &#125; //覆盖Object类的GetHashCode方法 public override int GetHashCode() &#123; //整数部分与小数点后3位相同的对象生成相同的哈希值 return (int)(Radius * 1000); &#125; //重写Object类的Equals方法 public override bool Equals(object obj) &#123; if (this.CompareTo(obj) == 0) return true; return false; &#125; //实现IEquatable&lt;Circle&gt;接口定义的方法 public bool Equals(Circle other) &#123; return this.CompareTo(other) == 0; &#125; //---------------------------------------- //重载相关的运算符 //---------------------------------------- public static bool operator ==(Circle obj1, Circle obj2) &#123; return obj1.Equals(obj2); &#125; public static bool operator !=(Circle obj1, Circle obj2) &#123; return !(obj1.Equals(obj2)); &#125; public static bool operator &gt;(Circle obj1, Circle obj2) &#123; if (obj1.CompareTo(obj2) &gt; 0) return true; return false; &#125; public static bool operator &lt;(Circle obj1, Circle obj2) &#123; if (obj1.CompareTo(obj2) &lt; 0) return true; return false; &#125; public static bool operator &lt;=(Circle obj1, Circle obj2) &#123; if ((obj1.CompareTo(obj2) &lt; 0) || (obj1.CompareTo(obj2) == 0)) return true; return false; &#125; public static bool operator &gt;=(Circle obj1, Circle obj2) &#123; if ((obj1.CompareTo(obj2) &gt; 0) || (obj1.CompareTo(obj2) == 0)) return true; return false; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435namespace ObjectCompare&#123; class Program &#123; static void Main(string[] args) &#123; Circle obj1 = new Circle &#123; Radius = 100.1 &#125;; Circle obj2 = new Circle &#123; Radius = 100.9 &#125;; //测试覆盖的方法 Console.WriteLine(obj1.GetHashCode());//100100 Console.WriteLine(obj2.GetHashCode());//100900 Console.WriteLine(obj1.CompareTo(obj2)); //-1 Console.WriteLine(obj1.Equals(obj2));//false //测试重载的运算符 Console.WriteLine(obj1 == obj2); //false Console.WriteLine(obj1 != obj2); //true Console.WriteLine(obj1 &gt;= obj2); //false //以下测试Circle对象数组的排序功能 Circle[] circles = new Circle[10]; //创建Circle对象数组 Random ran = new Random(); for (int i = 0; i &lt; 10; i++) &#123; circles[i] = new Circle &#123; Radius = ran.Next(1, 1000)/100.0 &#125;; &#125; Console.WriteLine("原始数组："); Array.ForEach&lt;Circle&gt;(circles, (circle) =&gt; &#123; Console.WriteLine("圆对象的哈希代码：&#123;0&#125;，半径：&#123;1&#125;", circle.GetHashCode(), circle.Radius); &#125;); Console.WriteLine("\n排序之后："); Array.Sort(circles); Array.ForEach&lt;Circle&gt;(circles, (circle) =&gt; &#123; Console.WriteLine("圆对象的哈希代码：&#123;0&#125;，半径：&#123;1&#125;", circle.GetHashCode(), circle.Radius); &#125;); Console.ReadKey(); &#125; &#125;&#125; 对象排序实例(实现接口，直接使用排序和查找)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091namespace ObjectSort&#123; class MyClass : IComparable&lt;MyClass&gt; &#123; public int Value &#123; get; set; &#125; public String Information &#123; get; set; &#125; /// &lt;summary&gt; /// 先按照Value字段值比较，如果Value值一样， /// 就按照Information字段值比较, /// 只有两个字段值都一样，才认为这两个对象相等 /// &lt;/summary&gt; /// &lt;param name="other"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public int CompareTo(MyClass other) &#123; if (other == null) &#123; return -1; &#125; int result=this.Value.CompareTo(other.Value); if (result == 0) &#123; return this.Information.CompareTo(other.Information); &#125; return result; &#125; public override bool Equals(object obj) &#123; if (obj == null || obj is MyClass == false) &#123; return false; &#125; return this.CompareTo(obj as MyClass)==0; &#125; public override int GetHashCode() &#123; return Value ; &#125; public override string ToString() &#123; return String.Format("Value:&#123;0&#125;\t Information:&#123;1&#125;\n", Value, Information) ; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; var MyClasses = GenerateExampleCollection(); Console.WriteLine("原始集合："); MyClasses.ForEach((obj) =&gt; &#123; Console.WriteLine(obj); &#125;); MyClasses.Sort(); Console.WriteLine("\n排序之后："); MyClasses.ForEach((obj) =&gt; &#123; Console.WriteLine(obj); &#125;); MyClass objToFind = new MyClass() &#123; Value = 2,Information = "ABC" &#125;; Console.WriteLine("\n查找对象：&#123;0&#125;", objToFind); int index = MyClasses.IndexOf(objToFind); Console.WriteLine("对象&#123;0&#125;在集合中的索引：&#123;1&#125;",objToFind,index); Console.ReadKey(); &#125; static List&lt;MyClass&gt; GenerateExampleCollection() &#123; var collection = new List&lt;MyClass&gt;(); collection.Add(new MyClass() &#123; Value=1, Information="Hello" &#125;); collection.Add(new MyClass() &#123; Value = 2, Information = "World" &#125;); collection.Add(new MyClass() &#123; Value = 2, Information = "ABC" &#125;); return collection; &#125; &#125;&#125; 对象比较器(类是别人写好的，不好修改实现IComparable接口) 1234567namespace ObjectComparer&#123; public class MyClass &#123; public int Value; &#125;&#125; 12345678910namespace ObjectComparer&#123; class MyClassComparer : IComparer&lt;MyClass&gt; &#123; public int Compare(MyClass x, MyClass y) &#123; return x.Value.CompareTo(y.Value); &#125; &#125;&#125; 12345678910111213141516171819202122232425namespace ObjectComparer&#123; class Program &#123; static void Main(string[] args) &#123; MyClass[] objs = new MyClass[] &#123; new MyClass&#123;Value=124&#125;, new MyClass&#123;Value=100&#125;, new MyClass&#123;Value=1&#125;, new MyClass&#123;Value=75&#125; &#125;; Console.WriteLine("原始数组："); Array.ForEach&lt;MyClass&gt;(objs, obj =&gt; &#123; Console.Write("Value=&#123;0&#125; ,", obj.Value); &#125;); //使用比较器对象 在sort集合中排序 Array.Sort&lt;MyClass&gt;(objs, new MyClassComparer()); Console.WriteLine("\n排序之后："); Array.ForEach&lt;MyClass&gt;(objs, obj =&gt; &#123; Console.Write("Value=&#123;0&#125; ,", obj.Value); &#125;); Console.ReadKey(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>C#-学习</category>
        <category>基础入门到进阶-金旭亮</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象基础入门]]></title>
    <url>%2F2019%2F02%2F22%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[熟悉C# 类、对象、数组、继承、多态、异常处理、泛型编程 认识类和对象面向对象的方式看世界 认识类 创建对象 类和对象的之间的关系 编写类 类的定义方法 小结 属性什么是属性 属性之经典实现方法 C#3.0改进-自动实现的属性 相比字段可以添加业务逻辑 属性的其他玩法 构造方法调用时机 形式（无返回值） 重载 存在意义 字段与属性的初始化问题点 使用构造函数 使用对象初始化器 初始化集合类型的对象 分部类与分部方法基本概念 具体使用场景 命名空间 管理类 创建和使用 程序集(组件化开发)什么是程序集 如何创建程序集 使用程序集 程序集和命名空间之间的关系 基于程序集开发程序 对象和对象变量对象变量与内存模型对象变量和对象之间的关系 线程堆栈VS托管堆 引用类型VS值类型 对象变量赋值的真实含义 对象判等 值类型都为true 引用类型都为false(都是比较对象变量的引用) 按照对象“内容”比较，需要重写基类equals方法 都为true 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465namespace EqualsDemo&#123; class Program &#123; static void Main(string[] args) &#123; //int i = 100; //int j = 100; //Console.WriteLine(i==j); ////int类型居然有equals方法？ //Console.WriteLine(i.Equals(j)); //Console.WriteLine(); //MyClass obj1 = new MyClass(); //MyClass obj2 = new MyClass(); //Console.WriteLine(obj1 == obj2); //Console.WriteLine(obj1.Equals(obj2)); Console.WriteLine(); //String类型是引用类型还是值类型？ String str1 = "Hello"; String str2 = "Hello"; Console.WriteLine(str1 == str2); Console.WriteLine(str1.Equals(str2)); Console.ReadKey(); &#125; &#125; class MyClass &#123; private int value = 100; #region "比较对象" /// &lt;summary&gt; /// 如何比较两个对象的“内容” /// &lt;/summary&gt; /// &lt;param name="obj"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public override bool Equals(object obj) &#123; if (obj == null) &#123; return false; &#125; else &#123; if (obj is MyClass) &#123; return this.value == (obj as MyClass).value; &#125; &#125; return false; &#125; public override int GetHashCode() &#123; return value; &#125; #endregion &#125;&#125; this引用是一个对象变量 访问字段隐藏了this this小结 装箱和拆箱 方法参数两种类型 不同作用 只读类 只读类实例 只读类存在意义 如何设计 类的静态成员 const和Static的应用 Static定义类的静态成员 两种类型的类成员 静态字段VS实例字段 类成员访问规则 多窗体编程初步添加新窗体 设定启动窗体 窗体的显示方式 数组数组基础 对象数组对象数组的定义 对象数组内存模型 作为方法参数 继承继承VS分类 C#中继承的实现方式 字段访问规则 方法的重载与覆盖 继承与代码重用 抽象类与接口抽象类与抽象方法 抽象类的定义 抽象类的使用 接口场景引出 解决方法 接口的特点 类与接口关系 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364namespace Duck&#123; class Program &#123; static void Main(string[] args) &#123; Duck d = new Duck(); //Duck对象d可以使用3种方法： //1.自身定义的； //2.父类定义的 //3.接口定义的 d.Fly(); d.Cook(); d.Swim(); //将子类（Duck）对象赋给基类变量 Bird b = d; //现在只能使用基类定义的Fly()方法 b.Fly(); //将Duck对象赋给ISwin接口变量 ISwim s = d; //现在只能使用接口定义的Swim()方法 s.Swim(); //将Duck对象赋给另一个实现的接口IFood接口变量 IFood f = d; //现在只能使用接口定义的Cook()方法 f.Cook(); Console.ReadKey(true); &#125; &#125; //定义两个接口 public interface ISwim &#123; void Swim(); &#125; public interface IFood &#123; void Cook(); &#125; //定义一个抽象类 public abstract class Bird &#123; public abstract void Fly(); &#125; //继承自一个抽象类，实现两个接口 public class Duck : Bird, IFood, ISwim &#123; //实现ISwim接口 public void Swim() &#123; Console.WriteLine("是鸭子就会游泳"); &#125; //实现IFood接口 public void Cook() &#123; Console.WriteLine("鸭子经常被烧烤，北京烤鸭就很有名"); &#125; //实现抽象类Bird中的抽象方法 public override void Fly() &#123; Console.WriteLine("只有野鸭才会飞"); &#125; &#125;&#125; 接口小结 多态继承多态现实世界中的多态 面向对象中的多态 真正的多态代码-针对基类编程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960namespace Fruit&#123; class Program &#123; static void Main(string[] args) &#123; //ShowPolymorphism(); CallPolymorphismMethod(); Console.ReadKey(); &#125; static void ShowPolymorphism() &#123; Fruit f; f = new Apple(); //这句输出什么？ f.GrowInArea(); f = new Pineapple(); //与前面相同的代码，输出什么？ f.GrowInArea(); &#125; /// &lt;summary&gt; /// 使用了“多态”特性的方法，其代码具有稳定性，与具体子类无关 /// 此方法用于显示特定水果的“适宜种植区域”信息 /// &lt;/summary&gt; /// &lt;param name="fruit"&gt;&lt;/param&gt; static void ShowFruitGrowInAreaInfo(Fruit fruit) &#123; fruit.GrowInArea(); &#125; /// &lt;summary&gt; /// 多态代码的典型用法： /// 在运行时动态地传递对象给它 /// &lt;/summary&gt; static void CallPolymorphismMethod() &#123; ShowFruitGrowInAreaInfo(new Apple()); ShowFruitGrowInAreaInfo(new Pineapple()); &#125; &#125; abstract class Fruit //抽象类 &#123; public abstract void GrowInArea(); //抽象方法 &#125; class Apple : Fruit //苹果 &#123; public override void GrowInArea() &#123; Console.WriteLine("我是苹果，南方北方都可以种植我。"); &#125; &#125; class Pineapple : Fruit //菠萝 &#123; public override void GrowInArea() &#123; Console.WriteLine("我是菠萝，喜欢温暖，只能在南方看到我。"); &#125; &#125;&#125; 多态示例-动物园 面向对象建模 引入继承重构 再次重构 1234567891011121314151617181920212223242526272829303132namespace Zoo3&#123; abstract class Animal &#123; public abstract void eat(); &#125; //狮子 class Lion : Animal &#123; public override void eat() &#123; Console.WriteLine("我是狮子，我不吃肉谁敢吃肉！"); &#125; &#125; //猴子 class Monkey : Animal &#123; public override void eat() &#123; Console.WriteLine("我是猴子，我喜欢偷吃香蕉！"); &#125; &#125; //鸽子 class Pigeon : Animal &#123; public override void eat() &#123; Console.WriteLine("我是一只漂亮的鸽子，为了维持优美的体形，我每餐只吃几粒大米！"); &#125; &#125;&#125; 12345678910111213141516namespace Zoo3&#123; //动物园饲养员 class Feeder &#123; public String Name; //喂养一群动物 public void FeedAnimals(IEnumerable&lt;Animal&gt; ans) &#123; foreach (Animal an in ans) &#123; an.eat(); &#125; &#125; &#125;&#125; 12345678910111213141516171819namespace Zoo3&#123; class Program &#123; static void Main(string[] args) &#123; //动物数组 var ans = new List&lt;Animal&gt; &#123; new Monkey(), new Pigeon(), new Lion() &#125;; Feeder f = new Feeder(); f.Name = "小李"; //喂养一群动物 f.FeedAnimals(ans); &#125; &#125;&#125; 多态的好处 多态的实现方式 异常处理机制什么是异常 异常基础 异常处理 Exception是最顶层的异常基类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051namespace ExceptionDemo&#123; class Program &#123; static void Main(string[] args) &#123; //WhatIsException(); InputNumber(); Console.ReadKey(); &#125; static void WhatIsException() &#123; int i = 100, j = 0; Console.WriteLine(i / j); &#125; private static void InputNumber() &#123; Console.Write("请输入一个正整数："); try &#123; //尝试着将用户输入的字符串转换为整数 int value = Convert.ToInt32(Console.ReadLine()); if (value &lt;= 0) &#123; //发现非法的数据，“主动”抛出一个异常 throw new InvalidOperationException("你输入的不是正整数！"); &#125; Console.WriteLine("您输入的数字是：&#123;0&#125;", value); &#125; catch (FormatException) &#123; Console.WriteLine("输入的字符串无法转换为数字"); &#125; catch (OverflowException) &#123; Console.WriteLine("你输入的数字太大了！"); &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); &#125; finally &#123; Console.WriteLine("敲任意键退出……"); &#125; &#125; &#125;&#125; 异常基类的重要属性和方法 123456789101112131415161718192021222324namespace ExceptionInfo&#123; class Program &#123; static void Main(string[] args) &#123; try &#123; int[] values = new int[10]; for (int i = 1; i &lt;= 10; i++) Console.WriteLine(values[i]); &#125; catch (Exception e) &#123; Console.WriteLine("在输出values数组值时发生数组越界错误"); Console.WriteLine("异常种类:" + e.GetType().Name); Console.WriteLine("系统给出的出错信息：" + e.Message); Console.WriteLine("系统调用堆栈信息:" + e.StackTrace); Console.WriteLine("引发此错误的方法：" + e.TargetSite); &#125; Console.ReadKey(); &#125; &#125;&#125; 基类库常用异常类型 创建自己的异常类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091namespace ExceptionLinkInRealWorld&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine("程序从Main()方法开始运行……\n"); try &#123; throwExceptionMethod(); //有可能抛出异常的方法调用 &#125; catch (MyException e) &#123; Console.WriteLine("在Main()方法中捕获到MyException异常，其Message属性值为：&#123;0&#125;",e.Message); &#125; catch (Exception e) &#123; Console.WriteLine("在Main()方法中捕获到Exception异常，其Message属性值为：&#123;0&#125;", e.Message); &#125; doesNotThrowException(); //不抛出异常的方法调用 Console.WriteLine("\nMain()方法运行结束，敲任意键退出……"); Console.ReadKey(); &#125; /// &lt;summary&gt; /// 自己虽然捕获了异常，但仍然希望外部进一步地处理，因此在简单地 /// 捕获并处理老异常之后，再抛出一个新的异常供本方法的调用者进行捕获。 /// &lt;/summary&gt; public static void throwExceptionMethod() &#123; try &#123; Console.WriteLine("throwExceptionMethod()方法开始执行"); Console.WriteLine("throwExceptionMethod()方法抛出了一个异常"); // 模拟产生一个异常 throw new Exception("系统运行时引发的Exception异常"); &#125; catch (Exception e) &#123; Console.WriteLine("throwExceptionMethod方法捕获并处理了抛出的Exception异常，并将其转换为一个自定义MyException异常再抛出", e); //转换为一个自定义异常，再抛出 throw new MyException("在throwExceptionMethod()方法执行时出现MyException异常",e); &#125; finally &#123; Console.WriteLine("throwExceptionMethod()方法中的finally语句块执行结束\n"); &#125; &#125; /// &lt;summary&gt; /// 自己能完全处理异常，不需要外界参与 /// &lt;/summary&gt; public static void doesNotThrowException() &#123; try &#123; Console.WriteLine("\ndoesNotThrowException()方法开始执行"); Console.WriteLine("doesNotThrowException()方法虽然包容try/catch/finally，但不会抛出任何异常"); &#125; catch (Exception e) &#123; Console.WriteLine(e.Message); &#125; finally &#123; Console.WriteLine("执行doesNotThrowException()方法中的finally语句块"); &#125; Console.WriteLine("doesNotThrowException()方法运行结束。\n"); &#125; &#125; class MyException : Exception &#123; //重载的构造函数--调用基类构造函数 public MyException(String Message) : base(Message) &#123; &#125; public MyException(string Message, Exception InnerException) : base(Message, InnerException) &#123; &#125; &#125;&#125; 异常处理链 嵌套的异常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192namespace EmbedException&#123; #region "自定义异常类型" class ExceptionA : Exception &#123; &#125; class ExceptionB : Exception &#123; &#125; class ExceptionC : Exception &#123; &#125; #endregion class Program &#123; static void Main(string[] args) &#123; try //Level1 &#123; Console.WriteLine("进入Level1的try语句块"); try //Level2 &#123; Console.WriteLine("进入Level2的try语句块"); //如果在Level3代码执行之前（和之后）出现异常，Level3的finally语句块还会执行吗？ //throw new ExceptionB(); try //Level3 &#123; Console.WriteLine("进入Level3的try语句块"); //to do:每次抛出一种异常，注释掉其余的语句，然后观察输出结果 //throw new ExceptionA(); //throw new ExceptionB(); //throw new ExceptionC(); //throw new InvalidOperationException(); Console.WriteLine("退出Level3的try语句块"); &#125; catch (ExceptionA) //Level3 &#123; Console.WriteLine("在Level3中处理ExceptionA。"); &#125; finally //Level3 &#123; Console.WriteLine("Level3中的finally语句块"); WriteMessageToFile("Level3.txt", "Level3中的finally语句块"); &#125; //throw new ExceptionB(); Console.WriteLine("退出Level2的try语句块"); &#125; catch (ExceptionB) &#123; Console.WriteLine("在Level2中处理ExceptionB"); &#125; finally &#123; Console.WriteLine("Level2中的finally语句块"); WriteMessageToFile("Level2.txt", "Level2中的finally语句块"); &#125; Console.WriteLine("退出Level1的try语句块"); &#125; catch (ExceptionC) &#123; Console.WriteLine("在Level1中处理ExceptionC "); &#125; //当示例抛出注释InvalidOperationException时，注释掉此块，查看CLR的异常处理策略 catch (Exception) &#123; Console.WriteLine("在Level1中处理Exception "); &#125; finally &#123; Console.WriteLine("Level1中的finally语句块"); WriteMessageToFile("Level1.txt", "Level1中的finally语句块"); &#125; Console.ReadKey();//程序暂停 &#125; /// &lt;summary&gt; /// 将异常信息写入到文件中，以备日后查询 /// &lt;/summary&gt; /// &lt;param name="FileName"&gt;&lt;/param&gt; /// &lt;param name="Message"&gt;&lt;/param&gt; private static void WriteMessageToFile(string FileName,string Message) &#123; FileStream fs = new FileStream(FileName, FileMode.Create); StreamWriter sw = new StreamWriter(fs); sw.Write(Message); sw.Close(); fs.Close(); &#125; &#125; &#125; 异常处理与捕获基本策略 异常处理的建议 泛型编程为什么使用泛型 泛型定义方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154namespace frmGPExample1&#123; public partial class frmGPExample1 : Form &#123; public frmGPExample1() &#123; InitializeComponent(); &#125;#region "变量区" //两个将要被排序的数组 char[] CharArray=new Char[10]; int[] IntArray=new int[10]; //整数数组元素中的最大最小值 private int MaxInt, MinInt; //字符数组元素中的最大最小值 private char MaxChar, MinChar;#endregion //用随机数据填充数组,并显示在列表框中 private void FillArray() &#123; int i = 0; Random ran = new Random(); lstData.Items.Clear(); if (rdoInteger.Checked) &#123; //获取指定维数最后一个元素的索引 for (i = 0; i &lt;= IntArray.GetUpperBound(0); i++) &#123; IntArray[i] = ran.Next(0, 100); lstData.Items.Add(IntArray[i]); &#125; &#125; if (rdoChar.Checked) &#123; for (i = 0; i &lt;= CharArray.GetUpperBound(0); i++) &#123; int charCode = ran.Next(0, 26); CharArray[i] = (char)(charCode + 'A'); lstData.Items.Add(CharArray[i] + " :ASC码值＝" + Convert.ToString((int)(CharArray[i]))); &#125; &#125; &#125; //显示结果： private void ShowResult() &#123; if (rdoInteger.Checked ) &#123; lblMax.Text = "最大值：" + MaxInt; lblMin.Text = "最小值：" + MinInt; &#125; if (rdoChar.Checked ) &#123; lblMax.Text = "最大值：" + MaxChar; lblMin.Text = "最小值：" + MinChar; &#125; &#125;#region "普通方法" //在整数数组中查找最大最小值 private void GetMaxMinValueFromIntArray(int[] datas) &#123; MaxInt = datas[0]; MinInt = datas[0]; for (int i= 1 ;i&lt;= IntArray.GetUpperBound(0);i++) &#123; if (MaxInt &lt; datas[i]) MaxInt = datas[i]; if( MinInt &gt; datas[i]) MinInt = datas[i]; &#125; &#125; //在字符数组中查找最大最小值 private void GetMaxMinValueFromCharArray(char [] datas ) &#123; MaxChar = datas[0]; MinChar = datas[0]; for (int i = 1;i&lt;= IntArray.GetUpperBound(0);i++) &#123; if (MaxChar &lt; datas[i] ) MaxChar = datas[i]; if (MinChar &gt; datas[i] ) MinChar = datas[i]; &#125; &#125; private void OnButtonClick1()&#123; //填充数组 FillArray(); if (rdoInteger.Checked ) GetMaxMinValueFromIntArray(IntArray); if (rdoChar.Checked ) GetMaxMinValueFromCharArray(CharArray); //显示数据处理结果 ShowResult(); &#125;#endregion#region "泛型方法版本" private void GetMaxMinVauleFromArray&lt;T&gt;(T[] datas , ref T Max ,ref T Min) where T:IComparable &#123; Max = datas[0]; Min = datas[0]; for(int i = 1 ;i&lt;=IntArray.GetUpperBound(0);i++) &#123; if( Max.CompareTo(datas[i])&lt;0) Max = datas[i]; if (Min.CompareTo(datas[i])&gt;0) Min = datas[i]; &#125; &#125; private void OnButtonClick2() &#123; //填充数组 FillArray(); //根据用户选项填充对应的数组 if( rdoInteger.Checked ) GetMaxMinVauleFromArray&lt;int&gt;(IntArray, ref MaxInt,ref MinInt); if (rdoChar.Checked ) GetMaxMinVauleFromArray&lt;char&gt;(CharArray,ref MaxChar, ref MinChar); //显示数据处理结果 ShowResult(); &#125;#endregion private void btnExit_Click(object sender, EventArgs e) &#123; Application.Exit(); &#125; private void btnFillArray_Click(object sender, EventArgs e) &#123; OnButtonClick1();//普通版本 //OnButtonClick2();//泛型方法版本 &#125; &#125;&#125; 泛型编程基础泛型类编写方法 设定参数约束 常用参数约束 编写泛型方法 泛型类和方法实例 12345678910111213141516171819202122232425262728293031323334namespace MaxMinValueForGP2&#123; class ComplexNum:IComparable&lt;ComplexNum&gt; &#123; public double a;//实部 public double b ;//虚部 public ComplexNum(double aValue , double bValue ) &#123; a = aValue; b = bValue; &#125; //按复数标准形式返回a+bi形式的字串 public override String ToString() &#123; return (a.ToString() + "+" + b.ToString() + "i"); &#125; //求复数的模 public double GetMod() &#123; return Math.Sqrt(a * a + b * b); &#125; //按模比较两个复数的大小 int IComparable&lt;ComplexNum&gt;.CompareTo(ComplexNum other ) &#123; if (Math.Abs(GetMod() - other.GetMod()) &lt; 0.000001 ) return 0; if( GetMod() &gt; other.GetMod() ) return 1; else return -1; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738namespace MaxMinValueForGP2&#123; /// &lt;summary&gt; /// 使用泛型类封装算法 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; public class MaxMin&lt;T&gt; where T : IComparable&lt;T&gt; &#123; //处理数据，获取最大值最小值 public static Pair&lt;T&gt; GetMaxMinVauleFromArray(T[] arr) &#123; Pair&lt;T&gt; ret; ret.Max = arr[0]; ret.Min = arr[0]; for (int i = 1; i &lt;= arr.GetUpperBound(0); i++) &#123; if (ret.Max.CompareTo(arr[i]) &lt; 0) ret.Max = arr[i]; if (ret.Min.CompareTo(arr[i]) &gt; 0) ret.Min = arr[i]; &#125; return ret; &#125; &#125; /// &lt;summary&gt; /// 使用泛型struct封装数据处理结果 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; public struct Pair&lt;T&gt; &#123; public T Max; public T Min; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788namespace MaxMinValueForGP2&#123; public partial class frmGPExample2 : Form &#123; public frmGPExample2() &#123; InitializeComponent(); &#125; /// &lt;summary&gt; /// 三个字段，引用被处理的三种类型的数组 /// &lt;/summary&gt; private char[] CharArray = new char[10]; private int[] IntArray = new int[10]; private ComplexNum[] ComplexArray = new ComplexNum[10]; private void OnButtonClick() &#123; //填充数组 FillArray(); if (rdoInteger.Checked) ShowResult&lt;int&gt;(MaxMin&lt;int&gt;.GetMaxMinVauleFromArray(IntArray)); if (rdoChar.Checked) ShowResult&lt;char&gt;(MaxMin&lt;char&gt;.GetMaxMinVauleFromArray(CharArray)); if (rdoComplex.Checked) ShowResult&lt;ComplexNum&gt;(MaxMin&lt;ComplexNum&gt;.GetMaxMinVauleFromArray(ComplexArray)); &#125; /// &lt;summary&gt; /// 使用泛型方法显示数据处理结果 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; /// &lt;param name="ret"&gt;&lt;/param&gt; private void ShowResult&lt;T&gt;(Pair&lt;T&gt; ret) &#123; lblMax.Text = "最大值：" + ret.Max.ToString(); lblMin.Text = "最小值：" + ret.Min.ToString(); &#125; //用随机数据填充数组,并显示在列表框中 private void FillArray() &#123; int i; Random ran = new Random(); lstData.Items.Clear(); if (rdoInteger.Checked) for (i = 0; i &lt;= IntArray.GetUpperBound(0); i++) &#123; IntArray[i] = ran.Next(0, 100); lstData.Items.Add(IntArray[i]); &#125; if (rdoChar.Checked) for (i = 0; i &lt;= CharArray.GetUpperBound(0); i++) &#123; int charCode; charCode = ran.Next(0, 26); CharArray[i] = (char)('A' + charCode); lstData.Items.Add(CharArray[i].ToString() + " :ASC码值＝" + ((int)CharArray[i]).ToString()); &#125; int a, b; if (rdoComplex.Checked) for (i = 0; i &lt;= ComplexArray.GetUpperBound(0); i++) &#123; a = ran.Next(0, 10); b = ran.Next(0, 10); ComplexArray[i] = new ComplexNum(a, b); lstData.Items.Add(ComplexArray[i].ToString() + " 模＝" + ComplexArray[i].GetMod().ToString()); &#125; &#125; private void btnFillArray_Click(object sender, EventArgs e) &#123; OnButtonClick();//泛型类版本 &#125; private void btnExit_Click(object sender, EventArgs e) &#123; Application.Exit(); &#125; &#125;&#125; 泛型接口 泛型接口的使用 使用泛型的好处 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394namespace UseGenericExampleForCS&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; long beginTime, endTime, usedTime;//代码运行时间 //用于测试的集合 ArrayList arr1 = new ArrayList(); List&lt;long&gt; arr2 = new List&lt;long&gt;(); //加入集合的元素个数 private const int ElementCounters = 5000000; //提示信息 String strInfo = "&#123;0&#125;,运行时间：&#123;1&#125; ticks" + Environment.NewLine; private void AddElement() &#123; //起始时间 beginTime = Environment.TickCount; //清除原有数据 arr1.Clear(); arr2.Clear(); //向集合中加入元素 for (int i = 0; i &lt; ElementCounters; i++) if (rdoArrayList.Checked) arr1.Add(i); //非泛型版本 else arr2.Add(i); endTime = Environment.TickCount; usedTime = endTime - beginTime; if (rdoArrayList.Checked) txtInfo.Text += String.Format(strInfo, "向集合中加入元素：" + ElementCounters + "个" , usedTime); else txtInfo.Text += String.Format(strInfo, "向泛型集合中加入元素：" + ElementCounters + "个", usedTime); &#125; private void SumElement() &#123; //起始时间 beginTime = Environment.TickCount; //清除原有数据 arr1.Clear(); arr2.Clear(); //向集合中加入元素 int i ; for (i = 0 ;i&lt; ElementCounters;i++) if (rdoArrayList.Checked ) arr1.Add(i); //非泛型版本 else arr2.Add(i); //求和 long ret=0; for (i = 0;i&lt; ElementCounters;i++) if (rdoArrayList.Checked ) ret += Convert.ToInt64( arr1[i]); //非泛型版本 else ret += arr2[i]; endTime =Environment.TickCount; usedTime = endTime - beginTime; if (rdoArrayList.Checked) txtInfo.Text += String.Format(strInfo, "对集合" + ElementCounters.ToString() + "个元素求和：" + ret , usedTime); else txtInfo.Text += String.Format(strInfo, "对泛型集合" + ElementCounters.ToString() + "个元素求和：" + ret , usedTime); &#125; private void btnAddElement_Click(object sender, EventArgs e) &#123; AddElement(); &#125; private void btnSumElement_Click(object sender, EventArgs e) &#123; SumElement(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>C#-学习</category>
        <category>基础入门到进阶-金旭亮</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Winform软件开发技术基础]]></title>
    <url>%2F2019%2F02%2F21%2FWinform%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[掌握桌面程序开发、熟悉常用的控件 使用VisualStudio 编写GUI程序本博客内容由金旭亮老师网上上传的文档制作，在此特地感谢！ GUI应用程序简介 使用VisualStudio设计可视化桌面应用 快速应用开发模式 常用Winform控件使用 按钮控件 设计带图标的按钮 资源的使用 使用资源后需要注意的属性 标签控件 文本控件 进度条和小闹钟控件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071namespace ProgressBarAndTimer&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); ShowProgressBarValue(AutoProgressBar.Value); &#125; private void ShowProgressBarValue(int value) &#123; lblInfo.Text = string.Format("&#123;0&#125;%", value); &#125; #region "事件响应" private void btnIncrease_Click(object sender, EventArgs e) &#123; if (ManualProgressBar.Value + 2 &gt; ManualProgressBar.Maximum) &#123; ManualProgressBar.Value = ManualProgressBar.Maximum; &#125; else &#123; ManualProgressBar.Value += 2; &#125; &#125; private void btnDecrease_Click(object sender, EventArgs e) &#123; if (ManualProgressBar.Value - 2 &lt; ManualProgressBar.Minimum) &#123; ManualProgressBar.Value = ManualProgressBar.Minimum; &#125; else &#123; ManualProgressBar.Value -= 2; &#125; &#125; private void timer1_Tick(object sender, EventArgs e) &#123; if (AutoProgressBar.Value + 2 &gt; AutoProgressBar.Maximum) &#123; //自动回头 AutoProgressBar.Value = 0; &#125; else &#123; AutoProgressBar.Value += 2; &#125; ShowProgressBarValue(AutoProgressBar.Value); &#125; private void btnTimer_Click(object sender, EventArgs e) &#123; timer1.Enabled = !timer1.Enabled; if (timer1.Enabled == true) &#123; btnTimer.Image = Resources.DisableClock; &#125; else &#123; btnTimer.Image = Resources.EnableClock; &#125; &#125; #endregion &#125;&#125; 控件学习指导 通用属性学会学习 控件Anchor属性 控件Dock属性 12345678910111213141516171819202122232425262728293031323334353637383940namespace FormCtrlProperty&#123; public partial class frmDock : Form &#123; public frmDock() &#123; InitializeComponent(); &#125; private void rdoNone_CheckedChanged(object sender, EventArgs e) &#123; button1.Dock = DockStyle.None; &#125; private void rdoLeft_CheckedChanged(object sender, EventArgs e) &#123; button1.Dock = DockStyle.Left; &#125; private void rdoRight_CheckedChanged(object sender, EventArgs e) &#123; button1.Dock = DockStyle.Right; &#125; private void rdoTop_CheckedChanged(object sender, EventArgs e) &#123; button1.Dock = DockStyle.Top; &#125; private void rdoBottom_CheckedChanged(object sender, EventArgs e) &#123; button1.Dock = DockStyle.Bottom; &#125; private void rdoFill_CheckedChanged(object sender, EventArgs e) &#123; button1.Dock = DockStyle.Fill; &#125; &#125;&#125; 控件容器 面板Panel 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374namespace ContainerDemo&#123; public partial class frmPanel : Form &#123; public frmPanel() &#123; InitializeComponent(); &#125; private void btnShowOrHide_Click(object sender, EventArgs e) &#123; if (rdoOuter.Checked) &#123; pnlOuter.Visible = !pnlOuter.Visible; &#125; else &#123; pnlInner.Visible = !pnlInner.Visible; &#125; ChangebtnShowOrHideText(); &#125; private void btnEnableOrDisable_Click(object sender, EventArgs e) &#123; if (rdoOuter.Checked) &#123; pnlOuter.Enabled = !pnlOuter.Enabled; &#125; else &#123; pnlInner.Enabled = !pnlInner.Enabled; &#125; ChangebtnEnableOrDisableText(); &#125; private void ChangebtnShowOrHideText() &#123; if (rdoOuter.Checked) &#123; btnShowOrHide.Text = pnlOuter.Visible ? "隐藏" : "显示"; &#125; else &#123; btnShowOrHide.Text = pnlInner.Visible ? "隐藏" : "显示"; &#125; &#125; private void ChangebtnEnableOrDisableText() &#123; if (rdoOuter.Checked) &#123; btnEnableOrDisable.Text = pnlOuter.Enabled ? "禁用" : "激活"; &#125; else &#123; btnEnableOrDisable.Text = pnlInner.Enabled ? "禁用" : "激活"; &#125; &#125; private void rdoOuter_CheckedChanged(object sender, EventArgs e) &#123; ChangebtnEnableOrDisableText(); ChangebtnShowOrHideText(); &#125; private void rdoInner_CheckedChanged(object sender, EventArgs e) &#123; ChangebtnEnableOrDisableText(); ChangebtnShowOrHideText(); &#125; &#125;&#125; 组合框GropBox 选项卡TabControl 1234567891011121314151617181920212223242526272829303132333435363738394041namespace ContainerDemo&#123; public partial class frmTabControl : Form &#123; public frmTabControl() &#123; InitializeComponent(); tabCount = tabControl1.TabPages.Count; &#125; private int tabCount = 0; private Random ran = new Random(); private void btnAddTab_Click(object sender, EventArgs e) &#123; tabCount++; TabPage newPage = new TabPage("tabPage" + tabCount); newPage.BackColor = Color.FromArgb( ran.Next(0,255), ran.Next(0,255), ran.Next(0,255)); tabControl1.TabPages.Add(newPage); &#125; private void btnActiveLeft_Click(object sender, EventArgs e) &#123; if (tabControl1.SelectedIndex != 0) &#123; tabControl1.SelectTab(tabControl1.SelectedIndex - 1); &#125; &#125; private void btnActiveRight_Click(object sender, EventArgs e) &#123; if (tabControl1.SelectedIndex != tabControl1.TabPages.Count - 1) &#123; tabControl1.SelectTab(tabControl1.SelectedIndex + 1); &#125; &#125; &#125;&#125; 容器控件布局窗体分割条面板SplitContainer FlowLayout控件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253namespace LayoutDemos&#123; public partial class frmFlowLayout : Form &#123; public frmFlowLayout() &#123; InitializeComponent(); &#125; private int counter = 0; private void btnAddButton_Click(object sender, EventArgs e) &#123; counter++; Button btn = new Button(); btn.Text = "按钮" + counter; flowLayoutPanel1.Controls.Add(btn); &#125; private void chkWrapContents_CheckedChanged(object sender, EventArgs e) &#123; flowLayoutPanel1.WrapContents = chkWrapContents.Checked; &#125; private void chkAutoScroll_CheckedChanged(object sender, EventArgs e) &#123; flowLayoutPanel1.AutoScroll = chkAutoScroll.Checked; &#125; private void cboFlowDirection_SelectedIndexChanged(object sender, EventArgs e) &#123; switch (cboFlowDirection.Text) &#123; case "BottomUp": flowLayoutPanel1.FlowDirection = FlowDirection.BottomUp; break; case "LeftToRight": flowLayoutPanel1.FlowDirection = FlowDirection.LeftToRight; break; case "RightToLeft": flowLayoutPanel1.FlowDirection = FlowDirection.RightToLeft; break; case "TopDown": flowLayoutPanel1.FlowDirection = FlowDirection.TopDown; break; default: break; &#125; &#125; &#125;&#125; TabelLayoutPanel 复杂一些的控件对话框 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071namespace DialogDemo&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private void btnOpenFile_Click(object sender, EventArgs e) &#123; openFileDialog1.Title = "选择一张图片"; openFileDialog1.Filter = "所有支持的图片文件|*.jpg;*.gif;*.png;*.bmp|任意文件（*.*）|*.*"; openFileDialog1.FileName = ""; openFileDialog1.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures); openFileDialog1.CheckFileExists = true; openFileDialog1.CheckPathExists = true; //是否允许选择多个文件 //openFileDialog1.Multiselect = false; openFileDialog1.Multiselect = true; if (openFileDialog1.ShowDialog() == DialogResult.OK) &#123; if (openFileDialog1.Multiselect == false) &#123; lblInfo.Text = openFileDialog1.FileName; &#125; else &#123; StringBuilder sb = new StringBuilder(); foreach (var file in openFileDialog1.FileNames) &#123; sb.Append(file); sb.Append("\n"); &#125; lblInfo.Text = sb.ToString(); &#125; &#125; &#125; private void btnSaveFile_Click(object sender, EventArgs e) &#123; //设置默认文件扩展名 saveFileDialog1.DefaultExt = ".txt"; //指定文件名存在，是否提示警告 saveFileDialog1.OverwritePrompt = true; saveFileDialog1.Title = "保存文件"; if (saveFileDialog1.ShowDialog() == DialogResult.OK) &#123; lblInfo.Text = "文件己保存到：" + saveFileDialog1.FileName; &#125; &#125; private void btnFontDialog_Click(object sender, EventArgs e) &#123; if (fontDialog1.ShowDialog() == DialogResult.OK) &#123; lblInfo.Font = fontDialog1.Font; &#125; &#125; private void btnColor_Click(object sender, EventArgs e) &#123; if (colorDialog1.ShowDialog() == DialogResult.OK) &#123; lblInfo.ForeColor = colorDialog1.Color; &#125; &#125; &#125;&#125; 下拉菜单 弹出式菜单：例如鼠标点右键 弹出式菜单 1234567891011121314151617181920212223242526272829303132333435363738394041424344namespace MenuDemo&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private void mnuExit_Click(object sender, EventArgs e) &#123; Close(); &#125; private void menuOpen_Click(object sender, EventArgs e) &#123; openFileDialog1.ShowDialog(); &#125; private void btnEnable_Click(object sender, EventArgs e) &#123; FileMenuItem.Enabled = !FileMenuItem.Enabled; &#125; private int SaveCount = 0; private void mnuSave_Click(object sender, EventArgs e) &#123; SaveCount++; mnuSave.Text = string.Format("保存(&#123;0&#125;)", SaveCount); &#125; private void btnExchange_Click(object sender, EventArgs e) &#123; menuStripEdit.Visible = !menuStripEdit.Visible; menuStripFile.Visible = !menuStripFile.Visible; &#125; private void buttonShowContextMenu_Click(object sender, EventArgs e) &#123; //相对于指定控件定位 contextMenuStripExample.Show(sender as Control,20,25); &#125; &#125;&#125; 状态条 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556namespace StatusStripDemo&#123; public partial class frmStatusStrip : Form &#123; public frmStatusStrip() &#123; InitializeComponent(); &#125; private void btnShowTime_Click(object sender, EventArgs e) &#123; timerForCurrentTime.Enabled = !timerForCurrentTime.Enabled; &#125; private void timer1_Tick(object sender, EventArgs e) &#123; toolStripStatusLabel1.Text = DateTime.Now.ToLongTimeString(); &#125; private void ToolStripMenuItem1_Click(object sender, EventArgs e) &#123; MessageBox.Show("菜单项一"); &#125; private void ToolStripMenuItem2_Click(object sender, EventArgs e) &#123; MessageBox.Show("菜单项二"); &#125; private void ToolStripMenuItem3_Click(object sender, EventArgs e) &#123; MessageBox.Show("菜单项三"); &#125; private void btnShowProgress_Click(object sender, EventArgs e) &#123; toolStripProgressBar1.Visible = true; toolStripProgressBar1.Value = 0; timerForProgress.Enabled = true; btnShowProgressBar.Enabled = false; &#125; private void timerForProgress_Tick(object sender, EventArgs e) &#123; if (toolStripProgressBar1.Value &lt; 100) toolStripProgressBar1.Value += 5; else &#123; toolStripProgressBar1.Visible = false; timerForProgress.Enabled = false; btnShowProgressBar.Enabled = true; &#125; &#125; &#125;&#125; 树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109namespace TreeDemo&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private void btnNewTopNode_Click(object sender, EventArgs e) &#123; string NodeText = ""; if (!string.IsNullOrEmpty(txtNewNodeText.Text.Trim())) &#123; NodeText = txtNewNodeText.Text; &#125; else &#123; NodeText = "新根节点" + (treeView1.GetNodeCount(true) + 1); &#125; treeView1.Nodes.Add(NodeText); &#125; private void btnAddBrotherNode_Click(object sender, EventArgs e) &#123; string NodeText = ""; if (treeView1.SelectedNode != null &amp;&amp; treeView1.SelectedNode.Parent!=null) &#123; if (!string.IsNullOrEmpty(txtNewNodeText.Text.Trim())) &#123; NodeText = txtNewNodeText.Text; &#125; else &#123; NodeText = "新兄弟节点" + (treeView1.GetNodeCount(true) + 1); &#125; treeView1.SelectedNode.Parent.Nodes.Add(NodeText); &#125; &#125; private void btnAddChildNode_Click(object sender, EventArgs e) &#123; string NodeText = ""; if (treeView1.SelectedNode != null) &#123; if (!string.IsNullOrEmpty(txtNewNodeText.Text.Trim())) &#123; NodeText = txtNewNodeText.Text; &#125; else &#123; NodeText = "新子节点" + (treeView1.GetNodeCount(true) + 1); &#125; treeView1.SelectedNode.Nodes.Add(NodeText); treeView1.SelectedNode.Expand(); &#125; &#125; private void btnDeleteNode_Click(object sender, EventArgs e) &#123; if (treeView1.SelectedNode != null) &#123; if (treeView1.SelectedNode.Parent != null) &#123; treeView1.SelectedNode.Parent.Nodes.Remove(treeView1.SelectedNode); &#125; else &#123; treeView1.Nodes.Remove(treeView1.SelectedNode); &#125; &#125; &#125; private void btnClearTreeNodes_Click(object sender, EventArgs e) &#123; treeView1.Nodes.Clear(); &#125; private void btnExpandCollapseNode_Click(object sender, EventArgs e) &#123; if (treeView1.SelectedNode != null) &#123; if (treeView1.SelectedNode.IsExpanded) &#123; treeView1.SelectedNode.Collapse(true); &#125; else &#123; treeView1.SelectedNode.Expand(); &#125; &#125; &#125; private void treeView1_AfterSelect(object sender, TreeViewEventArgs e) &#123; txtNodeText.Text = e.Node.Text; &#125; private void btnNodeRename_Click(object sender, EventArgs e) &#123; if (txtNodeText.Text.Trim().Length &gt; 0) &#123; treeView1.SelectedNode.Text = txtNodeText.Text.Trim(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>C#-学习</category>
        <category>基础入门到进阶-金旭亮</category>
      </categories>
      <tags>
        <tag>Winform编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#面向对象程序设计概述和基础知识]]></title>
    <url>%2F2019%2F02%2F20%2FCSharp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0%E5%92%8C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[了解C#语言历史、编程工具、运行原理、基础语法…… 本节细节点概述本博客内容由金旭亮老师网上上传的文档制作，在此特地感谢！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//了解变量的特定类型变量名.GetType()int intvalue=100;Console.Writeline(intvalue.GetType()==typeof(int))//C#语言内置类型和CLR支持的基础类型的对应关系int---System.Int32......var 关键字根据右边的具体值推断类型//数据类型占用大小"占用字节少"的可以直接赋值给"占用字节多的""占用字节多的"赋值给"占用字节少" 必须要强制转换占用相同大小内存，因为解析方式不一样，也要进行"类型转换"//表达式的概念表达式会有一个结果 没有分号 语句才有分号表达式使用场景：如 条件选择和循环语句//构建逻辑表达式的运算符&lt; &gt; == &gt;= &lt;= !=//逻辑表达式的组合&amp;&amp; || ！//多值选择结构switch (intvalue)&#123; case 0: CaseZero(); break; case 1: CaseOne(); break; default : CaseOther(); break;&#125;//break Continuebreak ：直接跳出循环continue ：跳过本次循环//foreach 循环 遍历数据集合时，不能向里面增删数据项//Console.ReadKey()方法 返回一个ConsoleKeyInfo结构可用于 检测用户输入的按键 详细下面代码//静态方法 --方法前面加 static关键字可以通过类名直接调用 而实例方法依附于具体的对象//方法的重载返回值类型不作为重载的依据//.net类库中的类生成随机数Random ran = new Random (System.Environment.TickCount);Console.Write(ran.Next(1,100));//1-100之间的随机整数 不能取到上界值//递归"自己调用自己" 开头一定时判断递归结束的条件是否满足有一个控制递归可以终结的变量(递归函数中变化)特点： 先从大到小 再从小到大//浮点数的判等问题//处理大的整数 .NET 4.0 提供了BigInteger 类 需要引用 System.Numerics C#与.NET来世今生C#语言编程史 Windows与.NET技术发展的历程及趋势 什么是.NET 使用VisualStudio编程工具认识Visual Studio Console的重要属性 控制台窗口的输入与输出 ReadKey和Beep 程序调试基本技巧 C#与Visual Studio编程须知基本编程规则 文件组织方式 行号、颜色、字体大小 面向对象概述与.NET运行原理面向对象编程概述 程序是如何被计算机执行的？ 如何编写计算机可以执行的程序？ 怎样构造求解问题的算法？ 日期计算结构化编程的实现 日期计算面向对象编程的实现 变量、数据类型与表达式理解变量 数据类型 String和Var 变量与内存 数据类型转换 运算符与表达式 选择结构与逻辑表达式 if/else 选择结构 选择结构的嵌套 逻辑表达式的组合 多分支结构 循环结构 while/do 循环 12345678910111213141516static void InputQuitToStop() &#123; string userInput = ""; while (userInput.ToLower() != "quit") &#123; Console.WriteLine("\n不断输入字符串，回车结束一次输入。不想再运行程序时，输入quit。"); userInput = Console.ReadLine(); if (string.IsNullOrEmpty(userInput) == false) &#123; Console.WriteLine("您输入了：&#123;0&#125;", userInput); &#125; &#125; Console.WriteLine("\n---------------------------------------------"); Console.WriteLine("\n检测到quit命令，循环中止，敲任意键退出……"); &#125; for循环 Break和Continue 1234567891011121314151617/// &lt;summary&gt;/// 理解Break和Continue的不同作用/// &lt;/summary&gt;static void BreakAndContinue()&#123; for (int i = 1; i &lt;= 10; i++) &#123; if (i == 5) &#123; //切换以下两句的注释，体会它们的不同作用 //continue; break; &#125; Console.WriteLine("第&#123;0&#125;轮循环", i); &#125;&#125; foreach循环 控制台程序编程小技巧 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//测试如何检测按键 static void testKey() &#123; Console.WriteLine("随意敲任意键查看其键值，压ESC退出"); ConsoleKeyInfo key; do &#123; //用户敲了按键了吗？ while (!Console.KeyAvailable) &#123; //啥也不干，等待…… &#125; //等待用户击键 key = Console.ReadKey(true); Console.WriteLine();//输出一个空行 Console.WriteLine("Modifiers值=&#123;0&#125;", key.Modifiers); Console.WriteLine("KeyChar值=&#123;0&#125;", (int)(key.KeyChar)); Console.WriteLine("Key值=&#123;0&#125;", key.Key); //CapsLock这个键是不能被捕获的，但我们可以检测出键盘的状态 if (Console.CapsLock) &#123; Console.WriteLine("处于大写状态"); &#125; //NumberLock这个键是不能被捕获的，但我们可以检测出键盘的状态 if (Console.NumberLock) &#123; Console.WriteLine("小键盘上的Num Lock键被按下"); &#125; //检测控制键 if (key.Modifiers != 0) &#123; if ((key.Modifiers &amp; ConsoleModifiers.Alt) != 0) &#123; Console.WriteLine("Alt键被按下"); &#125; if ((key.Modifiers &amp; ConsoleModifiers.Control) != 0) &#123; Console.WriteLine("Ctrl键被按下"); &#125; if ((key.Modifiers &amp; ConsoleModifiers.Shift) != 0) &#123; Console.WriteLine("Shift键被按下"); &#125; &#125; &#125; while (key.Key != ConsoleKey.Escape); Console.WriteLine("\n检测到ESC键，敲任意键退出……\n"); &#125; 123456789101112131415161718192021222324252627282930313233/// &lt;summary&gt;/// 展示系统内置的强制中止控制台程序的功能/// &lt;/summary&gt;static void QuitConsoleApp()&#123; Console.WriteLine("死循环：请使用Ctrl+C或Ctrl+Break强制中止本程序"); while (true) &#123; Console.WriteLine("当前时间：" + DateTime.Now.ToLocalTime()); Thread.Sleep(2000); &#125;&#125;/// &lt;summary&gt;/// 禁用Ctrl+C/// &lt;/summary&gt;static void DisableControlC()&#123; Console.WriteLine("本程序只能通过ESC键结束，无法通过Ctrl+C而中止"); Console.TreatControlCAsInput = true; do &#123; var key = Console.ReadKey(true); if (key.Key == ConsoleKey.Escape) &#123; Console.WriteLine("检测到ESC键，敲任意键退出……"); break; &#125; &#125; while (true);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445/// &lt;summary&gt; /// 响应UseCancelKeyPress事件，屏蔽掉Ctrl+C和Ctrl+Break /// &lt;/summary&gt; static void UseCancelKeyPress() &#123; Console.WriteLine("本程序只能通过ESC键结束"); //响应CancelKeyPress事件（即Ctrl+C和Ctrl+Break被按下） Console.CancelKeyPress += Console_CancelKeyPress; do &#123; var key = Console.ReadKey(true); if (key.Key == ConsoleKey.Escape) &#123; Console.WriteLine("\n检测到ESC键，敲任意键退出……"); break; &#125; if (key.KeyChar != '\0') &#123; if (key.Key == ConsoleKey.Enter) &#123; Console.WriteLine(); &#125; else &#123; Console.Write(key.KeyChar); &#125; &#125; &#125; while (true); &#125; private static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e) &#123; var isCtrlC = e.SpecialKey == ConsoleSpecialKey.ControlC; var isCtrlBreak = e.SpecialKey == ConsoleSpecialKey.ControlBreak; //如果是Ctrl+C和Ctrl+Break if (isCtrlC || isCtrlBreak) &#123; //屏蔽掉它们，让它们不起作用 e.Cancel = true; //通知用户，Ctrl+C和Ctrl+Break已经不起作用了…… Console.WriteLine(isCtrlC ? "Ctrl+C已被屏蔽" : "Ctrl+Break已被屏蔽"); &#125; &#125; 方法 方法定义与调用 方法重载 方法应用实例 123456789101112131415161718192021222324namespace ShowPicInForm&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private void LoadPicture() &#123; if (openFileDialog1.ShowDialog() == DialogResult.OK) &#123; string FileName = openFileDialog1.FileName; picImage.ImageLocation = FileName; &#125; &#125; private void btnLoadPic_Click(object sender, EventArgs e) &#123; LoadPicture(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344namespace Pseudorandom&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private float a = 3; //乘数,注意，a&gt;=2 and a&lt;m private int m = 100; //模 private float c = 4; //增量，注意，c&gt;=0 and c&lt;m //依据公式计算出下一个随机数 private float GetNextRanNumber(int m, float a, float c, float prevNum) &#123; return (a * prevNum + c) % m; &#125; //按指定的种子Seed生成nums个随机数 private void GenerateRandomSequence(int nums, float seed) &#123; float lastNum, nextNum; lastNum = seed; //清空富文本框 RichTextBox1.Clear(); //追加字符串到富文本框中 RichTextBox1.AppendText(seed.ToString()); for (int i = 0; i &lt; nums; i++) &#123; nextNum = GetNextRanNumber(m, a, c, lastNum); RichTextBox1.AppendText(" ," + nextNum); lastNum = nextNum; &#125; &#125; private void btnGenerate_Click(object sender, EventArgs e) &#123; int nums = Convert.ToInt32(txtNumbers.Text); float seed = Convert.ToSingle(txtSeed.Text); GenerateRandomSequence(nums, seed); &#125; &#125;&#125; 递归递归概述 递归编程技巧 1234567891011121314151617181920212223242526272829303132333435363738namespace CalculateN&#123; public partial class frmCalculate : Form &#123; public frmCalculate() &#123; InitializeComponent(); &#125; private void btnCalculate_Click(object sender, EventArgs e) &#123; int n = Convert.ToInt32(txtN.Text); lblResult.Text = n.ToString()+"!="+Factorial(n).ToString(); //lblResult.Text = n.ToString() + "!=" + Factorial2(n).ToString(); &#125; //计算n!，用递归实现 private long Factorial(int n) &#123; if (n == 1) return 1; long ret; ret = Factorial(n - 1) * n; return ret; &#125; //计算n!，用递推实现 private long Factorial2(int n) &#123; long result = 1; for(int i = 1; i &lt;= n; i++) &#123; result *= i; &#125; return result; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253namespace Recursion&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private string Story = ""; //故事主体： private void WriteStory() &#123; Story = "从前有座山，山里有座庙。\n"; Story += "庙里有两个和尚，在讲故事。\n"; Story += "讲什么故事呢？……\n"; &#125; private void btnExecute_Click(object sender, EventArgs e) &#123; //清空文本 RichTextBox1.Text = ""; //老和尚开始没完没了地讲故事 DoRecursion((int)updnTimes.Value); &#125; //用于实现递归调用 private void DoRecursion(int times) &#123; //结束条件 if (times == 0) return; //每次递归调用时要完成的工作 //to do: 如果将以下这两句移到DoRecursion()一句之后， // 会发生什么？ //RichTextBox1.AppendText("第 " + times + " 次\n"); //RichTextBox1.AppendText(Story); //递归调用，参数减一 DoRecursion(times - 1); //////每次递归调用时要完成的工作 RichTextBox1.AppendText("第 " + times + " 次\n"); RichTextBox1.AppendText(Story); &#125; private void Form1_Load(object sender, EventArgs e) &#123; //把故事主体写好 WriteStory(); &#125; &#125;&#125; 处理大整数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475namespace GetFibonacciNumber&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); ShowCalculateResult(); &#125; private long FibonacciUseLong(int NumberIndex) &#123; long previousValue = -1; long currentResult = 1; for (var i = 0; i &lt;= NumberIndex; ++i) &#123; if (long.MaxValue - currentResult &lt; previousValue) &#123; throw new OverflowException("超过了本计算机能计算的最大整数！"); &#125; long sum = currentResult + previousValue; previousValue = currentResult; currentResult = sum; &#125; return currentResult; &#125; private BigInteger FibonacciUseBigInteger(int NumberIndex) &#123; BigInteger previousValue = -1; BigInteger currentResult = 1; for (var i = 0; i &lt;= NumberIndex; ++i) &#123; BigInteger sum = currentResult + previousValue; previousValue = currentResult; currentResult = sum; &#125; return currentResult; &#125; /// &lt;summary&gt; /// 显示计算结果 /// &lt;/summary&gt; private void ShowCalculateResult() &#123; try &#123; if (rdoLong.Checked) lblResult.Text = FibonacciUseLong((int)numericUpDown1.Value).ToString(); else lblResult.Text = FibonacciUseBigInteger((int)numericUpDown1.Value).ToString(); &#125; catch (Exception ex) &#123; lblResult.Text = ex.Message; &#125; &#125; private void numericUpDown1_ValueChanged(object sender, EventArgs e) &#123; ShowCalculateResult(); &#125; private void radioButton1_CheckedChanged(object sender, EventArgs e) &#123; ShowCalculateResult(); &#125; private void rdoLong_CheckedChanged(object sender, EventArgs e) &#123; ShowCalculateResult(); &#125; &#125;&#125; 浮点数的处理技巧]]></content>
      <categories>
        <category>C#-学习</category>
        <category>基础入门到进阶-金旭亮</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascrpit-正则表达式]]></title>
    <url>%2F2019%2F02%2F18%2Fjavascrpit-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[学会创建javascrip正则表达式对象，然后用于匹配、提取、替换 创建正则对象方式1： 12var reg = new RegExp('\d', 'i');var reg = new RegExp('\d', 'gi'); 方式2： 12var reg = /\d/i;var reg = /\d/gi; 参数 标志 说明 i 忽略大小写 g 全局匹配 gi 全局匹配+忽略大小写 正则匹配1234// 匹配日期var dateStr = '2015-10-10';var reg = /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/console.log(reg.test(dateStr)); 正则提取1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 &lt;script&gt; // 跟正则表达式相关的方法 // 1 RegExp对象 // test() 匹配 // exec() 提取 提取一个内容 // 2 String对象 // match() 提取 可以提取多个内容 // replace() 替换 // split() 切割 // search() var str = '张三：2500，李四：3000，王五：50000'; // var reg = /\d+/gi; // gi 全局匹配并且忽略大小写 var reg = /\d+/g; // exec() 只返回一个匹配到的结果 如果没有匹配的内容返回null--返回一个结果数组或 null。 // var content = reg.exec(str); // console.log(content); //2500 匹配完后正则表达对象会记录下一次匹配开始位置 //参考链接：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec // content = reg.exec(str); // console.log(content); //3000 // content = reg.exec(str); // console.log(content); //50000 // content = reg.exec(str); // console.log(content); //null do &#123; var content = reg.exec(str); if (content) &#123; console.log(content[0]); &#125; &#125; while(content); &lt;/script&gt;// 1. 提取工资var str = "张三：1000，李四：5000，王五：8000。";var array = str.match(/\d+/g);console.log(array);// 2. 提取email地址- . 是匹配除换行符以外的任意单个字符，所以需要加转义var str = "123123@xx.com,fangfang@valuedopinions.cn 286669312@qq.com 2、emailenglish@emailenglish.englishtown.com 286669312@qq.com...";var array = str.match(/\w+@\w+\.\w+(\.\w+)?/g);console.log(array);// 3. 分组提取 // 3. 提取日期中的年部分 2015-5-10var dateStr = '2016-1-5';// 正则表达式中的()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取var reg = /(\d&#123;4&#125;)-\d&#123;1,2&#125;-\d&#123;1,2&#125;/;if (reg.test(dateStr)) &#123; console.log(RegExp.$1);&#125;// 4. 提取邮件中的每一部分var reg = /(\w+)@(\w+)\.(\w+)(\.\w+)?/;var str = "123123@xx.com";if (reg.test(str)) &#123; console.log(RegExp.$1); console.log(RegExp.$2); console.log(RegExp.$3);&#125;// 1. 提取日期中的年部分 2015-5-10// var dateStr = '2015-1-5';// console.log(dateStr.split('-'));// var dateStr = '2015/1-5';// console.log(dateStr.split(/[/-]/));// 2. 提取邮件中的每一部分var str = 'xxxx@itcast.com';console.log(str.split(/[@\.]/)); 正则替换12345678910111213141516171819202122232425262728293031// 1. 替换所有空白var str = " 123AD asadf asadfasf adf ";str = str.replace(/\s/g,"xx");console.log(str); //xxxxxx123ADxxxxasadfxxxxxxasadfasfxxxxadfxx// 2. 替换所有,|，var str = "abc,efg,123，abc,123，a";str = str.replace(/,|，/g, ".");console.log(str); // 1. 替换所有空白// var str = " 123AD asadf asadfasf adf ";// trim() 去除前后的空格// console.log( str.trim());// replace() 只能替换掉第一个查找到的内容// console.log(str.replace(' ', 'x'));// console.log(str.replace(/\s/g, ''));//console.log(str.split(' '));//["", "", "", "123AD", "", "asadf", "", "", "", "", "asadfasf", "", "adf", ""]// console.log(str.split(' ').join(''));// 2. 把所有,和，替换为.var str = "abc,efg,123，abc,123，a";console.log(str.replace(/,|，/g, '.')); 案例：表单验证12345QQ号：&lt;input type="text" id="txtQQ"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;邮箱：&lt;input type="text" id="txtEMail"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;手机：&lt;input type="text" id="txtPhone"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;生日：&lt;input type="text" id="txtBirthday"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;姓名：&lt;input type="text" id="txtName"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 12345678910111213141516171819202122232425262728293031323334353637383940//获取文本框var txtQQ = document.getElementById("txtQQ");var txtEMail = document.getElementById("txtEMail");var txtPhone = document.getElementById("txtPhone");var txtBirthday = document.getElementById("txtBirthday");var txtName = document.getElementById("txtName");//txtQQ.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; var reg = /^\d&#123;5,12&#125;$/; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = "请输入正确的QQ号"; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125;&#125;;//txtEMailtxtEMail.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; var reg = /^\w+@\w+\.\w+(\.\w+)?$/; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = "请输入正确的EMail地址"; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125;&#125;; 表单验证部分，封装成函数： 12345678910111213141516171819var regBirthday = /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/;addCheck(txtBirthday, regBirthday, "请输入正确的出生日期");//给文本框添加验证function addCheck(element, reg, tip) &#123; element.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = tip; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125; &#125;;&#125; 通过给元素增加自定义验证属性对表单进行验证： 1234567&lt;form id="frm"&gt; QQ号：&lt;input type="text" name="txtQQ" data-rule="qq"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 邮箱：&lt;input type="text" name="txtEMail" data-rule="email"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 手机：&lt;input type="text" name="txtPhone" data-rule="phone"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 生日：&lt;input type="text" name="txtBirthday" data-rule="date"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 姓名：&lt;input type="text" name="txtName" data-rule="cn"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;&lt;/form&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 所有的验证规则var rules = [ &#123; name: 'qq', reg: /^\d&#123;5,12&#125;$/, tip: "请输入正确的QQ" &#125;, &#123; name: 'email', reg: /^\w+@\w+\.\w+(\.\w+)?$/, tip: "请输入正确的邮箱地址" &#125;, &#123; name: 'phone', reg: /^\d&#123;11&#125;$/, tip: "请输入正确的手机号码" &#125;, &#123; name: 'date', reg: /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/, tip: "请输入正确的出生日期" &#125;, &#123; name: 'cn', reg: /^[\u4e00-\u9fa5]&#123;2,4&#125;$/, tip: "请输入正确的姓名" &#125;];addCheck('frm');//给文本框添加验证function addCheck(formId) &#123; var i = 0, len = 0, frm =document.getElementById(formId); len = frm.children.length; for (; i &lt; len; i++) &#123; var element = frm.children[i]; // 表单元素中有name属性的元素添加验证 if (element.name) &#123; element.onblur = function () &#123; // 使用dataset获取data-自定义属性的值 var ruleName = this.dataset.rule; var rule =getRuleByRuleName(rules, ruleName); var span = this.nextElementSibling; //判断验证是否成功 if(!rule.reg.test(this.value) )&#123; //验证不成功 span.innerText = rule.tip; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125; &#125; &#125; &#125;&#125;// 根据规则的名称获取规则对象function getRuleByRuleName(rules, ruleName) &#123; var i = 0, len = rules.length; var rule = null; for (; i &lt; len; i++) &#123; if (rules[i].name == ruleName) &#123; rule = rules[i]; break; &#125; &#125; return rule;&#125;]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式初识及简单使用]]></title>
    <url>%2F2019%2F02%2F17%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9D%E8%AF%86%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[学会用正则表达式做字符串提取和简单的匹配，如手机号、邮箱、日期…… 了解正则表达式基本语法 什么是正则表达式正则表达式：用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 正则表达式的作用 给定的字符串是否符合正则表达式的过滤逻辑(匹配) 可以通过正则表达式，从字符串中获取我们想要的特定部分(提取) 强大的字符串替换能力(替换) 正则表达式的特点 灵活性、逻辑性和功能性非常的强 可以迅速地用极简单的方式达到字符串的复杂控制 对于刚接触的人来说，比较晦涩难懂 正则表达式的测试 在线测试正则 工具中使用正则表达式 sublime/vscode/word 演示替换所有的数字 正则表达式的组成 普通字符abc 123 特殊字符(元字符)：正则表达式中有特殊意义的字符\d \w 示例演示： \d 匹配数字 ab\d 匹配 ab1、ab2 元字符通过测试工具演示下面元字符的使用 常用元字符串 元字符 说明 \d 匹配数字 \D 匹配任意非数字的字符 \w 匹配字母或数字或下划线 \W 匹配任意不是字母，数字，下划线 \s 匹配任意的空白符 \S 匹配任意不是空白符的字符 . 匹配除换行符以外的任意单个字符 ^ 表示匹配行首的文本(以谁开始) $ 表示匹配行尾的文本(以谁结束) 限定符 限定符 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 其它1234567[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思[^] 匹配除中括号以内的内容\ 转义符| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱() 从两个直接量中选择一个，分组 eg：gr(a|e)y匹配gray和grey[\u4e00-\u9fa5] 匹配汉字 案例验证手机号： 1^\d&#123;11&#125;$ ^[1-9]\d&#123;10&#125;$ 验证邮编： 1^\d&#123;6&#125;$ ^[1-9]\d&#123;5&#125;$ 验证日期 2012-5-01 1^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$ 验证邮箱 xxx@itcast.cn：sina.com.cn 1^\w+@\w+(\.\w+)+$ 验证IP地址 192.168.1.10 1^\d&#123;1,3&#125;(.\d&#123;1,3&#125;)&#123;3&#125;$]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VsCode 快捷键]]></title>
    <url>%2F2019%2F02%2F16%2Fvscode-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[提高自己的效率，基本快捷键的必须得了解一下啊 注释快捷键 注释： 先CTRL+K，然后CTRL+C 取消注释： 先CTRL+K，然后CTRL+U 代码块整体移动 右移： Tab 左移： Shift+tab 格式化代码 格式化选定内容： Ctrl +K Ctrl+F]]></content>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产线员工离岗管理小软件]]></title>
    <url>%2F2019%2F02%2F15%2F%E4%BA%A7%E7%BA%BF%E5%91%98%E5%B7%A5%E7%A6%BB%E5%B2%97%E7%AE%A1%E7%90%86%E5%B0%8F%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[生产线员工离岗记录小软件 需求 记录于2019.2.15上午生产线 为了便于管理公司生产线员工在生产时间是否外出超时和旷工，产线老大今天叫我写一个简单的小软件，丢弃以前手动填写excel的方式并且对表格加密（记录的时间不准确，手工可以改）另外软件展示离岗超时名单，可以给其他离岗员工提醒，便于约束产线员工行为。 分析一、 数据准备： 需要一个简单工号和姓名数据对应表，因为产线员工也有流动性，也得时常增加员工和编号—–在此，我选择用一个文本保存，一条信息一行 如：张三*1001 软件初始化时，读取，封装成对象集合，用于判断员工工号的正确性. 对象的查找，使用Linq查询实现 二、类的分析： 操作写Excel类、员工实体类(记录基本信息，封装对象)、窗体界面类里实现基本简单业务逻辑 Excel操作类，做一个写操作接口（传入要写的对象） 员工实体类-记录姓名，ID，日期、离开时间，回来时间、离岗次数、是否超时 涉及到的基本知识点 LINQ查询 对象的封装 微软官方的Microsoft.Office.Interop.Excel基础操作 文件IO读操作 函数的命名参数的使用(Excel操作类，保存，打开用到密码) 集合的深拷贝(因为对集合遍历操作时不能改变集合元素个数的，一旦操作涉及到，需要深拷贝一份) 控件的绑定技术 winform消息框实现定时自动关闭–不会阻塞线程执行（非要人点一下子） 具体实现软件界面设计 软件初始化操作建立软件文件夹、员工信息txt、员工信息的基本excel的创建 12345678910111213141516171819202122//软件启动初始化工作---建立文件夹和员工信息文本private void initConfig()&#123; if (!Directory.Exists(@"D:\离岗记录软件配置文件夹")) &#123; Directory.CreateDirectory(@"D:\离岗记录软件配置文件夹"); &#125; if (!File.Exists(@"D:\离岗记录软件配置文件夹\员工信息.txt")) &#123; using (FileStream fs = new FileStream(@"D:\离岗记录软件配置文件夹\员工信 息.txt", FileMode.Create)) &#123; StreamWriter sw = new StreamWriter(fs, Encoding.Default); sw.WriteLine("请从下一行开始按照示例规范填写员工信息,如：张三*120"); sw.WriteLine("张三*100"); sw.WriteLine("李四*110"); sw.WriteLine("王五*120"); sw.Flush(); sw.Close(); &#125; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435//软件启动初始化工作---读取员工姓名和编号 封装到集合中private void ReadEmployeeInfo()&#123; using (FileStream fs = new FileStream(@"D:\离岗记录软件配置文件夹\员工信息.txt", FileMode.Open)) &#123; //Encoding.Default 防止中文乱码 StreamReader sr = new StreamReader(fs, Encoding.Default); //第一行是提示信息，读取作废 string employee = sr.ReadLine(); while (true) &#123; employee = sr.ReadLine(); if (employee != "" &amp;&amp; employee != null) &#123; //切割成数组 string[] employeeArray = employee.Split('*'); //封装对象，添加到集合中---该集合是窗体对象属性 employeeInfos.Add(new EmployeeInfo() &#123; Name = employeeArray[0], ID = employeeArray[1] &#125;); &#125; else &#123; break; &#125; &#125; sr.Close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344//创建Excel文件，初始化表头private void initExcel()&#123; if (!File.Exists(@"D:\离岗记录软件配置文件夹\员工离岗信息记录.xlsx")) &#123; //创建Excel Excel.Application excelApp= new Excel.Application(); excelApp.Visible = false; //将此属性设置为False ，如果您不想被打扰提示和通知消息 excelApp.DisplayAlerts = false; //创建一个新的工作簿。 新工作簿成为活动工作簿。 返回Workbook对象。 Excel.Workbook workBook = excelApp.Workbooks.Add(true); //在活动工作簿或工作簿的指定的窗口中，则返回一个对象，表示活动工作表 Excel.Worksheet workSheet = excelApp.ActiveSheet as Excel.Worksheet; workSheet.Cells[1, "A"] = "姓名"; workSheet.Cells[1, "B"] = "ID"; workSheet.Cells[1, "C"] = "日期"; workSheet.Cells[1, "D"] = "离开时间"; workSheet.Cells[1, "E"] = "回来时间"; workSheet.Cells[1, "F"] = "离岗次数"; workSheet.Cells[1, "G"] = "是否超时"; workSheet.Cells[1, "H"] = "是否超次数"; workSheet.Cells[1, "I"] = "是否旷工"; workSheet.Cells[1, "J"] = "是否漏打卡"; workBook.SaveAs(Filename:@"D:\离岗记录软件配置文件夹\员工离岗信息记录.xlsx", Password:"654321"); workBook.Close(); excelApp.Quit(); //设置为null 方便垃圾回收机制回收资源 workSheet = null; workBook = null; excelApp = null; GC.Collect(); &#125;// excel文件存在了，可以创建操作excel对象了 excelOperationObj = new ExcelOperation(@"D:\离岗记录软件配置文件夹\员工离岗信息记录.xlsx");&#125; 实体类设计12345678910111213141516171819202122232425262728293031323334353637[Serializable]public class EmployeeInfo&#123; public string Name &#123; get; set; &#125; public string ID &#123; get; set; &#125; //离开时间 public List&lt;DateTime&gt; DepatureTime &#123; get; set; &#125; = new List&lt;DateTime&gt;(); //回来时间 public List&lt;DateTime&gt; ComeBackTime &#123; get; set; &#125; = new List&lt;DateTime&gt;(); //用于判定是否是重复错误输入或者是漏打卡判定 public DateTime Nowtime &#123; get; set; &#125; //员工离岗次数 public int LeaveCount &#123; get; set; &#125; = 0; //离岗信息 姓名+超出的规定次数 一条信息展示 public string Leaveinfo1 &#123; get; set; &#125; //离岗超时信息 姓名+超时时间--- 多条信息展示 public List&lt;string&gt; Leaveinfo2 &#123; get; set; &#125; = new List&lt;string&gt;(); //是否超时 便于excel查看 public string IsOverTime &#123; get; set; &#125; //是否超次数 便于excel查看 public string IsOverOut &#123; get; set; &#125; //是否离岗 便于Excel查看 public string ISAbsent &#123; get; set; &#125; //是否忘打开 便于Excel查看 public string Isforget &#123; get; set; &#125;&#125; LINQ查询判断123456789101112131415//通过员工编号，找到员工对象private EmployeeInfo FindEmployeeById(string id)&#123; IEnumerable&lt;EmployeeInfo&gt; employeeList = from mployeeInfo in employeeInfos where mployeeInfo.ID == id select mployeeInfo; if (employeeList.Count() != 0) &#123; return employeeList.First(); &#125; else &#123; return null; &#125;&#125; 员工离开打卡实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private void txtDepatureNumber_KeyDown(object sender, KeyEventArgs e)&#123; if (e.KeyCode == Keys.Enter) &#123; string id = this.txtDepatureNumber.Text.Trim(); //判断输入的是否是存档的员工编号 EmployeeInfo employeeInfo = FindEmployeeById(id); if (employeeInfo!=null) &#123; // 人员离岗---确定离岗集合中无此人 if (!depatureList.Contains(employeeInfo)) &#123; //记录此离岗人员 depatureList.Add(employeeInfo); //记录离岗时间 employeeInfo.DepatureTime.Add(System.DateTime.Now); &#125; else //人员离岗返回 包含重复输入和漏打卡两种情况 &#123; employeeInfo.Nowtime = DateTime.Now; TimeSpan interval = employeeInfo.Nowtime - employeeInfo.DepatureTime.Last(); if (interval.Seconds &lt;5) //判断是重复输入--5s &#123; this.txtDepatureNumber.Text = ""; return; &#125; else if(interval.Minutes&gt; 30)//大于30分钟判定是漏打卡 &#123; employeeInfo.Isforget = "是"; //此时写一条忘打卡记录 EmployeeDealLogic(employeeInfo); //此时的打卡，算再次出去 txtDepatureNumber_KeyDown(null, new KeyEventArgs(Keys.Enter)); &#125; else //30分钟内回来，正常 &#123; //30min内 出去返回 正常记录一条出去记录 EmployeeDealLogic(employeeInfo); &#125; &#125; &#125; else &#123; MessageBox.Show("不存在此员工编号" + id); &#125; this.txtDepatureNumber.Text = ""; &#125;&#125; 员工回来打卡实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879private void EmployeeDealLogic(EmployeeInfo employeeInfo)&#123; //离开集合存在 说明确实出去了，否则输入应为无效 if (depatureList.Contains(employeeInfo)) &#123; // 员工回来，从集合移除该对象 depatureList.Remove(employeeInfo); //记录回来时的时间 employeeInfo.ComeBackTime.Add(System.DateTime.Now); //离岗次数记录 int count = employeeInfo.DepatureTime.Count; if (employeeInfo.Isforget != "是") &#123; //超过10分钟没回，记录到离开超时集合中 if (employeeInfo.DepatureTime[count - 1].AddSeconds(5) &lt; employeeInfo.ComeBackTime[count - 1]) &#123; //得到员工姓名+超时时间信息 string info = employeeInfo.Name + " " + (employeeInfo.ComeBackTime[count - 1] - employeeInfo.DepatureTime[count - 1].AddSeconds(5)); //设置写excel中 是否超时标题头下 写 是 employeeInfo.IsOverTime = "是"; //在对象集合属性中，增加这条超时信息 employeeInfo.Leaveinfo2.Add(info); //加入到 离岗超时展示集合中 界面上展示 this.ListdepatureTimeOut.Items.Add(info); &#125; &#125; else //是漏打卡 &#123; string info = employeeInfo.Name + " 漏打卡"; //加入到 离岗超时展示集合中 界面上展示 this.ListdepatureTimeOut.Items.Add(info); &#125; //员工离岗次数加1 employeeInfo.LeaveCount++; //离岗次数超过3次 if (employeeInfo.LeaveCount &gt; 3) &#123; //修改对象 离岗超次数信息，方便界面显示 employeeInfo.Leaveinfo1 = employeeInfo.Name + "超 " + (employeeInfo.LeaveCount - 3) + " 次"; employeeInfo.IsOverOut = "是"; //防止一个对象多次加入 界面离岗超次数 一个人只展示一次 if (LeaveOverCountList.Contains(employeeInfo)) &#123; LeaveOverCountList.Remove(employeeInfo); LeaveOverCountList.Add(employeeInfo); &#125; else &#123; LeaveOverCountList.Add(employeeInfo); &#125; &#125; excelOperationObj.writeEmployeeInfo(employeeInfo); //记录写入excel后 ，为了 人工看excel好直接定位 employeeInfo.IsOverTime = ""; employeeInfo.Isforget = ""; &#125; else &#123; return; &#125;&#125; Excel操作类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class ExcelOperation&#123; //系统进程操作 [DllImport("User32.dll")] public static extern int GetWindowThreadProcessId(IntPtr hWnd, out int Processid); //存放Excel所在路径 public string Path &#123; get; set; &#125; public Excel.Application excelApp = null; public Excel.Workbook workbook = null; public Excel.Worksheet worksheet = null; //Process 需要 using System.Diagnostics; 静态成员，方便进程的销毁 static List&lt;Process&gt; processes = new List&lt;Process&gt;(); //通过构造函数传入路径 public ExcelOperation(string path) &#123; this.Path = path; //创建Excel操作对象 excelApp = new Excel.Application(); excelApp.Visible = false; excelApp.DisplayAlerts = false; //获取工作薄----使用命名参数 workbook = excelApp.Workbooks.Open(Filename:Path,Password:"654321"); //加入到进程集合中 processes.Add(GetExcelProcess(excelApp)); worksheet = excelApp.ActiveSheet as Excel.Worksheet; &#125; Process GetExcelProcess(Excel.Application excelApp) &#123; int id; IntPtr intptr = new IntPtr(excelApp.Hwnd); GetWindowThreadProcessId(intptr, out id); return Process.GetProcessById(id); &#125; public void writeEmployeeInfo(EmployeeInfo employeeInfo) &#123; try &#123; //获取数据行数 int ExcelRowNumber = worksheet.UsedRange.Cells.Rows.Count; int writeRow = ExcelRowNumber + 1; worksheet.Cells[writeRow, "A"] = employeeInfo.Name; worksheet.Cells[writeRow, "B"] = employeeInfo.ID; worksheet.Cells[writeRow, "C"] = DateTime.Now.ToString("yyyy/MM/dd"); worksheet.Cells[writeRow, "D"] = employeeInfo.DepatureTime.Count==0? DateTime.Now : employeeInfo.DepatureTime.Last(); worksheet.Cells[writeRow, "E"] = employeeInfo.ComeBackTime.Count == 0 ? DateTime.Now : employeeInfo.ComeBackTime.Last(); worksheet.Cells[writeRow, "F"] = employeeInfo.LeaveCount; worksheet.Cells[writeRow, "G"] = employeeInfo.IsOverTime; worksheet.Cells[writeRow, "H"] = employeeInfo.IsOverOut; worksheet.Cells[writeRow, "I"] = employeeInfo.ISAbsent; worksheet.Cells[writeRow, "J"] = employeeInfo.Isforget; worksheet.Columns.EntireColumn.AutoFit();//列宽自适应。 workbook.Save(); &#125; catch (Exception ex) &#123; throw ex; &#125; &#125; public void excelClose() &#123; workbook.Close(); excelApp.Quit(); worksheet = null; workbook = null; excelApp = null; GC.Collect(); //可以这里直接杀进程，有时不会回收资源 // KillProcess(); &#125; public void KillProcess() &#123; for (int i = 0; i &lt; processes.Count; i++) &#123; if (processes[i] != null) &#123; processes[i].Kill(); processes[i].Dispose(); &#125; &#125; &#125;&#125; 窗体关闭优化工作 窗体关闭，还有员工未打开回来，此时记录一条信息漏打卡 软件实现漏打卡，涉及到从集合中移出元素,而遍历写漏打卡信息需要用到集合，所以需要深拷贝 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void MainForm_FormClosing(object sender, FormClosingEventArgs e)&#123; //窗体关闭确认 DialogResult result = MessageBox.Show("确认退出吗?", "操作提示", MessageBoxButtons.OKCancel, MessageBoxIcon.Information); if (result != DialogResult.OK) &#123; e.Cancel = true; &#125; else &#123; //关闭软件前，有还未返回打卡的员工，记录为忘打卡 foreach (var item in depatureList) &#123; item.Isforget = "是"; &#125; BindingList&lt;EmployeeInfo&gt; list = (BindingList&lt;EmployeeInfo&gt;)DeepClone(depatureList); foreach (var item in list) &#123; this.txtDepatureNumber.Text = item.ID; txtDepatureNumber_KeyDown(null, new KeyEventArgs(Keys.Enter)); &#125; excelOperationObj.excelClose(); &#125;&#125;public static object DeepClone(object obj)&#123; object objResult = null; using (MemoryStream ms = new MemoryStream()) &#123; BinaryFormatter bf = new BinaryFormatter(); bf.Serialize(ms, obj); ms.Position = 0; objResult = bf.Deserialize(ms); &#125; return objResult;&#125; 集合控件绑定数据源展示123456789101112131415161718192021222324252627282930313233343536public MainForm()&#123; InitializeComponent(); //为窗体控件 初始化数据绑定源 this.listAbsent.DataSource = absentList; this.listAbsent.DisplayMember = "Name"; this.listAbsent.ValueMember = "ID"; this.listDepature.DataSource = depatureList; this.listDepature.DisplayMember = "Name"; this.listDepature.ValueMember = "ID"; this.ListLeaveOverCount.DataSource = LeaveOverCountList; this.ListLeaveOverCount.DisplayMember = "Leaveinfo1"; this.ListLeaveOverCount.ValueMember = "ID"; initConfig(); ReadEmployeeInfo(); initExcel(); this.txtDepatureNumber.Select();&#125;//员工信息集合--读取配置文件获取，用来判断输入的准确性private List&lt;EmployeeInfo&gt; employeeInfos = new List&lt;EmployeeInfo&gt;();// 旷工集合private BindingList&lt;EmployeeInfo&gt; absentList = new BindingList&lt;EmployeeInfo&gt;();//离岗未回集合private BindingList&lt;EmployeeInfo&gt; depatureList = new BindingList&lt;EmployeeInfo&gt;();//员工离岗超次数集合private BindingList&lt;EmployeeInfo&gt; LeaveOverCountList = new BindingList&lt;EmployeeInfo&gt;(); 消息框自动计时关闭功能1234[DllImport("user32.dll")]public static extern int MessageBoxTimeoutA(IntPtr hWnd, string msg, string Caps, int type, int Id, int time);//引用DLLMessageBoxTimeoutA((IntPtr)0, "不存在该员工编号！", "消息框", 0, 0, 1000);// 直接调用 1秒后自动关闭 父窗口句柄没有直接用0代替]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>工作小软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基本知识小结]]></title>
    <url>%2F2019%2F02%2F14%2FHTML%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[了解WEB标准、网页的基本组成、基本网页排版标签、图像、链接、列表、表单、表格标签 认识网页网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及Flash等。 1思考： 网页是如何形成的呢? 常见浏览器介绍浏览器是网页运行的平台，常用的浏览器有IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera等。我们平时称为五大浏览器。 查看浏览器占有的市场份额（知晓）查看网站： http://tongji.baidu.com/data/browser 浏览器内核（理解）12345浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。渲染引擎 它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。JS 引擎 则是解析 Javascript 语言，执行 javascript语言来实现网页的动态效果。最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了一个 ACID 来测试引擎的兼容性和性能。内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有10多种，但是常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit。 （1）Trident(IE内核) 国内很多的双核浏览器的其中一核便是 Trident，美其名曰 “兼容模式”。 代表： IE、傲游、世界之窗浏览器、Avant、腾讯TT、猎豹安全浏览器、360极速浏览器、百度浏览器等。 Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。 （2）Gecko(firefox) Gecko(Firefox 内核)： Mozilla FireFox(火狐浏览器) 采用该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。 可惜这几年已经没落了， 比如 打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。 （3） webkit(Safari) Safari 是苹果公司开发的浏览器，所用浏览器内核的名称是大名鼎鼎的 WebKit。 现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了），苹果感觉像被别人抢了媳妇，都哭晕再厕所里面了。 代表浏览器：傲游浏览器3、 Apple Safari (Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器， （4） Chromium/Bink(chrome) 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。 ​ 大部分国产浏览器最新版都采用Blink内核。 （5） Presto(Opera) Presto 是挪威产浏览器 opera 的 “前任” 内核，为何说是 “前任”，因为最新的 opera 浏览器早已将之抛弃从而投入到了谷歌怀抱了。 1了解一点： 移动端的浏览器内核主要说的是系统内置浏览器的内核。 目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。 Web标准（重点）通过以上浏览器的内核不同，我们知道他们工作原理、解析肯定不同，显示就会有差别。 1问： 哪个语言再全国基本都可以听得懂？ Web 标准的好处1、让Web的发展前景更广阔2、内容能被更广泛的设备访问3、更容易被搜寻引擎搜索4、降低网站流量费用5、使网站更易于维护6、提高页面浏览速度 Web 标准构成 Web标准不是某一个标准，而是由W3C和其他标准化组织制定的一系列标准的集合。主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。 123结构标准：结构用于对网页元素进行整理和分类，主要包括XML和XHTML两个部分。样式标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。行为标准：行为是指网页模型的定义及交互的编写，主要包括DOM和ECMAScript两个部分 理想状态我们的源码： .HTML .css .js 1专业的人，写专业的代码 直观感受： 总结WEB标准： 结构标准： 决定你是否有个好天然身体 样式标准： 决定你是否打扮的美丽外观 行为标准： 决定你是否有吸引人的行为 HTML 初识一般先学习HTML+CSS， 这里我们先定一个小目标，先学HTML,后学习CSS。 HTML（英文Hyper Text Markup Language的缩写）中文译为“超文本标签语言”，主要是通过HTML标签对网页中的文本、图片、声音等内容进行描述。 1&lt;strong&gt; 我是加粗的字体 &lt;/strong&gt; 注意： 体会 文本 标签 语言 几个词语 HTML骨架格式日常生活的书信，我们要遵循共同的约定。 同理：HTML 有自己的语言语法骨架格式： 1234567&lt;HTML&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/HTML&gt; 课堂练习1： 书写我们的第一个HTML 页面！ 新建一个demo 的 TXT 文件。 里面写入刚才的HTML 骨架。 把后缀名改为 .HTML。 右击–谷歌浏览器打开。 1234567891011121314151617181920211 HTML标签：作用所有HTML中标签的一个根节点。2 head标签：作用：用于存放：title,meta,base,style,script,link注意在head标签中我们必须要设置的标签是title3.title标签：作用：让页面拥有一个属于自己的标题。4.body标签：作用：页面在的主体部分，用于存放所有的HTML标签：p,h,a,b,u,i,s,em,del,ins,strong,img 为了便于记忆，我们请出刚才要辞职回家养猪的二师兄来帮忙， 我称之为 猪八戒记忆法 HTML标签分类 在HTML页面中，带有“&lt; &gt;”符号的元素被称为HTML标签，如上面提到的 &lt;HTML&gt;、&lt;head&gt;、&lt;body&gt;都是HTML标签。所谓标签就是放在“&lt; &gt;” 标签符中表示某个功能的编码命令，也称为HTML标签或 HTML元素 1.双标签 1&lt;标签名&gt; 内容 &lt;/标签名&gt; 该语法中“&lt;标签名&gt;”表示该标签的作用开始，一般称为“开始标签（start tag）”，“&lt;/标签名&gt;” 表示该标签的作用结束，一般称为“结束标签（end tag）”。和开始标签相比，结束标签只是在前面加了一个关闭符“/”。 1比如 &lt;body&gt;我是文字 &lt;/body&gt; 2.单标签 1&lt;标签名 /&gt; 单标签也称空标签，是指用一个标签符号即可完整地描述某个功能的标签。 12&gt; 比如 &lt;br /&gt;&gt; HTML标签关系标签的相互关系就分为两种： 1.嵌套关系 1&lt;head&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; 2.并列关系 12&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 测试题： 1请问下列哪个标签是错误的？ 1A &lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 1B &lt;strong&gt;&lt;div&gt;&lt;/div&gt;&lt;/strong&gt; 1C &lt;head&gt;&lt;title&gt;&lt;/head&gt;&lt;/title&gt; 1D &lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt; 倡议： 如果两个标签之间的关系是嵌套关系，子元素最好缩进一个tab键的身位。如果是并列关系，最好上下对齐。 开发工具 这些工具你认识几个？ 普通青年 Dreamweaver 文艺青年 sublime 高手和傻子 用记事本 其实。。。。 sublime 一些常用快捷键 点我查看 1234再页面中输入 以下2个单词1. html: 5 2. ! 在sublime里面然后按下tab键盘即可生成HTML骨架 文档类型&lt;!DOCTYPE&gt;1&lt;!DOCTYPE html&gt; 这句话就是告诉我们使用哪个html版本？ 我们使用的是 html 5 的版本。 html有很多版本，那我们应该告诉用户和浏览器我们使用的版本号。 &lt;!DOCTYPE&gt; 标签位于文档的最前面，用于向浏览器说明当前文档使用哪种 HTML 或 XHTML 标准规范，必需在开头处使用&lt;!DOCTYPE&gt;标签为所有的XHTML文档指定XHTML版本和类型，只有这样浏览器才能按指定的文档类型进行解析。 注意： 一些老网站可能用的还是老版本的文档类型比如 XHTML之类的，但是我们学的是HTML5,而且HTML5的文档类型兼容很好(向下兼容的原则)，所以大家放心的使用HTML5的文档类型就好了。 字符集 utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。 gb2312 简单中文 包括6763个汉字 BIG5 繁体中文 港澳台等用 GBK包含全部中文字符 是GB2312的扩展，加入对繁体字的支持，兼容GB2312 UTF-8则包含全世界所有国家需要用到的字符 1记住一点，以后我们统统使用UTF-8 字符集, 这样就避免出现字符集不统一而引起乱码的情况了。 HTML标签的语义化白话： 所谓标签语义化，就是指标签的含义。 为什么要有语义化标签 方便代码的阅读和维护 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容 使用语义化标签会具有更好地搜索引擎优化 核心：合适的地方给一个最为合理的标签。 语义是否良好： 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。 不管是谁都能看懂这块内容是什么。 遵循的原则：先确定语义的HTML ，再选合适的CSS。 HTML标签 首先 HTML和CSS是两种完全不同的语言，我们学的是结构，就只写HTML标签，认识标签就可以了。 不会再给结构标签指定样式了。 HTML标签有很多，这里我们学习最为常用的，后面有些较少用的，我们可以查下手册就可以了。 排版标签排版标签主要和css搭配使用，显示网页结构的标签，是网页布局最常用的标签。 标题标签 (熟记) 单词缩写： head 头部. 标题 为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即 &lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;和&lt;h6&gt; 1标题标签语义： 作为标题使用，并且依据重要性递减 其基本语法格式如下： 1&lt;hn&gt; 标题文本 &lt;/hn&gt; 注意： h1 标签因为重要，尽量少用，不要动不动就向你扔了一个h1。 一般h1 都是给logo使用。 段落标签( 熟记)单词缩写： paragraph 段落 在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是 1&lt;p&gt; 文本内容 &lt;/p&gt; 是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 水平线标签(认识)单词缩写： horizontal 横线 在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，就是创建横跨网页水平线的标签。其基本语法格式如下： 1&lt;hr /&gt;是单标签 在网页中显示默认样式的水平线。 课堂练习2： 新闻页面 换行标签(熟记)单词缩写： break 打断 ,换行 在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 1&lt;br /&gt; 这时如果还像在word中直接敲回车键换行就不起作用了。 div span标签(重点)div span 是没有语义的 是我们网页布局主要的2个盒子 div 就是 division 的缩写 分割， 分区的意思 其实有很多div 来组合网页。 span, 跨度，跨距；范围 语法格式： 1&lt;div&gt; 这是头部 &lt;/div&gt; &lt;span&gt;今日价格&lt;/span&gt; 文本格式化标签(熟记)在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。 b i s u 只有使用 没有 强调的意思 strong em del ins 语义更强烈 标签属性 属性就是特性 比如 手机的颜色 手机的尺寸 ，总结就是手机的。。 使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本语法格式如下： 1&lt;标签名 属性1="属性值1" 属性2="属性值2" …&gt; 内容 &lt;/标签名&gt; 在上面的语法中， 1.标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。 2.属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。 3.任何标签的属性都有默认值，省略该属性则取默认值。 采取 键值对 的格式 key=”value” 的格式 比如: 1&lt;hr width="400" /&gt; 属性 是 宽度 值 是 400 提倡： 尽量不使用 样式属性。 图像标签img (重点)单词缩写： image 图像 HTML网页中任何元素的实现都要依靠HTML标签，要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签&lt;img /&gt;以及和他相关的属性。其基本语法格式如下： 该语法中src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。 1&lt;img src="图像URL" /&gt; 链接标签(重点)单词缩写： anchor 的缩写 。基本解释 锚, 铁锚 的 在HTML中创建超链接非常简单，只需用标签环绕需要被链接的对象即可，其基本语法格式如下： 1&lt;a href="跳转目标" target="目标窗口的弹出方式"&gt;文本或图像&lt;/a&gt; href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接的功能。 Hypertext Reference的缩写。意思是超文本引用 target：用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，_blank为在新窗口中打开方式。 注意： 1.外部链接 需要添加 http:// www.baidu.com 2.内部链接 直接链接内部页面名称即可 比如 &lt; a href=”index.html”&gt; 首页 3.如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=”#”)，表示该链接暂时为一个空链接。 4.不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。 锚点定位 （难点）通过创建锚点链接，用户能够快速定位到目标内容。创建锚点链接分为两步： 1231.使用“a href=”#id名&gt;“链接文本"&lt;/a&gt;创建链接文本。2.使用相应的id名标注跳转目标的位置。 base 标签base 可以设置整体链接的打开状态 base 写到 之间 特殊字符标签 （理解） 注释标签在HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。其基本语法格式如下：​ 1&lt;!-- 注释语句 --&gt; 注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。 注释重要性： 路径(重点、难点) 实际工作中，通常新建一个文件夹专门用于存放图像文件，这时再插入图像，就需要采用“路径”的方式来指定图像文件的位置。 路径可以分为： 相对路径和绝对路径 相对路径 图像文件和HTML文件位于同一文件夹：只需输入图像文件的名称即可，如&lt;img src=”logo.gif” /&gt;。 图像文件位于HTML文件的下一级文件夹：输入文件夹名和文件名，之间用“/”隔开，如&lt;img src=”img/img01/logo.gif” /&gt;。 图像文件位于HTML文件的上一级文件夹：在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推，如&lt;img src=”../logo.gif” /&gt;。 绝对路径绝对路径 “D:\web\img\logo.gif”，或完整的网络地址，例如“http://www.itcast.cn/images/logo.gif”。 列表标签什么是列表？ 把…制成表,以表显示 容器里面装载着文字或图表的一种形式，叫列表。 列表最大的特点就是 整齐 、整洁、 有序 无序列表 ul （重点）无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下： 123456&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ul&gt; 比如下面这些，新闻是没有顺序的，不用排队，先到先得，后发布先显示。 脚下留心： 1231. &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。2. &lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。3. 无序列表会带有自己样式属性，放下那个样式，一会让CSS来！ 有序列表 ol （了解） 有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下： 123456&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ol&gt; 所有特性基本与ul 一致。 但是实际工作中， 较少用 ol ，因此我们用一句话来总结下 ol： 自定义列表（理解）定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下： 12345678910&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ... &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ...&lt;/dl&gt; 用的还可以： 总结 每一天都有一个主题 我们HTML第一天的主题就是 &lt;认识标签&gt; 学HTML 之前 觉得 很神秘 等你学完之后忽然发现 总结今天的思路贯穿线： 表格 table(会使用)存在即是合理的。 表格的现在还是较为常用的一种标签，但不是用来布局，常见处理、显示表格式数据。 ps: 这些地方用表格，你会觉得生活还是那么美好。。。。忍不住想说 PPAP i hava a pen 创建表格在HTML网页中，要想创建表格，就需要使用表格相关的标签。创建表格的基本语法格式如下： 1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ...&lt;/table&gt; 在上面的语法中包含三对HTML标签，分别为 &lt;table&gt;&lt;/table&gt;、&lt;tr&gt;&lt;/tr&gt;、&lt;td&gt;&lt;/td&gt;，他们是创建表格的基本标签，缺一不可，下面对他们进行具体地解释 123451.table用于定义一个表格。2.tr 用于定义表格中的一行，必须嵌套在 table标签中，在 table中包含几对 tr，就有几行表格。3.td /td：用于定义表格中的单元格，必须嵌套在&lt;tr&gt;&lt;/tr&gt;标签中，一对 &lt;tr&gt; &lt;/tr&gt;中包含几对&lt;td&gt;&lt;/td&gt;，就表示该行中有多少列（或多少个单元格）。 注意： 11. &lt;tr&gt;&lt;/tr&gt;中只能嵌套&lt;td&gt;&lt;/td&gt; 12. &lt;td&gt;&lt;/td&gt;标签，他就像一个容器，可以容纳所有的元素 表格属性 表头标签表头一般位于表格的第一行或第一列，其文本加粗居中，如下图所示，即为设置了表头的表格。设置表头非常简单，只需用表头标签&lt;th&gt;&lt;/th&gt;替代相应的单元格标签&lt;td&gt;&lt;/td&gt;即可。 表格结构（了解）12345678910在使用表格进行布局时，可以将表格划分为头部、主体和页脚（页脚因为有兼容性问题，我们不在赘述），具体 如下所示：&lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部。必须位于&lt;table&gt;&lt;/table&gt; 标签中，一般包含网页的logo和导航等头部信息。&lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体。位于&lt;table&gt;&lt;/table&gt;标签中，一般包含网页中除头部和底部之外的其他内容。 表格标题表格的标题： caption 定义和用法 caption 元素定义表格标题。 123&lt;table&gt; &lt;caption&gt;我是表格标题&lt;/caption&gt;&lt;/table&gt; caption 标签必须紧随 table 标签之后。您只能对每个表格定义一个标题。通常这个标题会被居中于表格之上。 合并单元格(难点)跨行合并：rowspan 跨列合并：colspan 合并单元格的思想： ​ 将多个内容合并的时候，就会有多余的东西，把它删除。 例如 把 3个 td 合并成一个， 那就多余了2个，需要删除。 ​ 公式： 删除的个数 = 合并的个数 - 1 合并的顺序 先上 先左 总结表格 表格提供了HTML 中定义表格式数据的方法。 表格中由行中的单元格组成。 表格中没有列元素，列的个数取决于行的单元格个数。 表格不要纠结于外观，那是CSS 的作用。 ​ 表格的学习要求： 能手写表格结构，并且能合并单元格。 表单标签(掌握)现实中的表单，类似我们去银行办理信用卡填写的单子。 如下图 目的是为了收集用户信息。 在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时也需要表单。 在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。 表单控件： ​ 包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息： ​ 一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。 表单域： ​ 他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 input 控件(重点)在上面的语法中，&lt;input /&gt;标签为单标签，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。除了type属性之外，&lt;input /&gt;标签还可以定义很多其他的属性，其常用属性如下表所示。 label标签(理解)label 标签为 input 元素定义标注（标签）。 作用： 用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点 如何绑定元素呢？ for 属性规定 label 与哪个表单元素绑定。 12&lt;label for="male"&gt;Male&lt;/label&gt;&lt;input type="radio" name="sex" id="male" value="male"&gt; textarea控件(文本域)如果需要输入大量的信息，就需要用到&lt;textarea&gt;&lt;/textarea&gt;标签。通过textarea控件可以轻松地创建多行文本输入框，其基本语法格式如下： 123&lt;textarea cols="每行中的字符数" rows="显示的行数"&gt; 文本内容&lt;/textarea&gt; 下拉菜单使用select控件定义下拉菜单的基本语法格式如下 123456&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ...&lt;/select&gt; 注意： &lt;select&gt;&lt;/select&gt;中至少应包含一对&lt;option&gt;&lt;/option&gt;。 在option 中定义selected =” selected “时，当前项即为默认选中项。 表单域在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。创建表单的基本语法格式如下： 123&lt;form action="url地址" method="提交方式" name="表单名称"&gt; 各种表单控件&lt;/form&gt; 常用属性： Action在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。 method用于设置表单数据的提交方式，其取值为get或post。 name用于指定表单的名称，以区分同一个页面中的多个表单。 注意： 每个表单都应该有自己表单域。 HTML5新标签与特性 文档类型设定 document HTML: sublime 输入 html:4s XHTML: sublime 输入 html:xt HTML5 sublime 输入 html:5 &lt;!DOCTYPE html&gt; 字符设定 ：HTML与XHTML中建议这样去写 ：HTML5的标签中建议这样去写 常用新标签 w3c 手册中文官网 : http://w3school.com.cn/ header：定义文档的页眉 头部 nav：定义导航链接的部分 footer：定义文档或节的页脚 底部 article：定义文章。 section：定义文档中的节（section、区段） aside：定义其所处内容之外的内容 侧边 123456&lt;header&gt; 语义 :定义页面的头部 页眉&lt;/header&gt;&lt;nav&gt; 语义 :定义导航栏 &lt;/nav&gt; &lt;footer&gt; 语义: 定义 页面底部 页脚&lt;/footer&gt;&lt;article&gt; 语义: 定义文章&lt;/article&gt;&lt;section&gt; 语义： 定义区域&lt;/section&gt;&lt;aside&gt; 语义： 定义其所处内容之外的内容 侧边&lt;/aside&gt; ​ datalist 标签定义选项列表。请与 input 元素配合使用该元素 123456789&lt;input type="text" value="输入明星" list="star"/&gt; &lt;!-- input里面用 list --&gt;&lt;datalist id="star"&gt; &lt;!-- datalist 里面用 id 来实现和 input 链接 --&gt; &lt;option&gt;刘德华&lt;/option&gt; &lt;option&gt;刘若英&lt;/option&gt; &lt;option&gt;刘晓庆&lt;/option&gt; &lt;option&gt;郭富城&lt;/option&gt; &lt;option&gt;张学友&lt;/option&gt; &lt;option&gt;郭郭&lt;/option&gt;&lt;/datalist&gt; ​ fieldset 元素可将表单内的相关元素分组，打包 legend 搭配使用 12345&lt;fieldset&gt; &lt;legend&gt;用户登录&lt;/legend&gt; 标题 用户名: &lt;input type="text"&gt;&lt;br /&gt;&lt;br /&gt; 密 码: &lt;input type="password"&gt;&lt;/fieldset&gt; ​ 新增的input type属性值： 类型** 使用示例** 含义** email** 输入邮箱格式 tel** 输入手机号码格式 url** 输入url格式 number** 输入数字格式 search** 搜索框（体现语义化） range** 自由拖动滑块 time** 小时分钟 date** 年月日 datetime** 时间 month** 月年 week** 星期 年 ## 常用新属性 属性** 用法** 含义** placeholder** 占位符 当用户输入的时候 里面的文字消失 删除所有文字，自动返回 autofocus** 规定当页面加载时 input 元素应该自动获得焦点 multiple** 多文件上传 autocomplete** 规定表单是否应该启用自动完成功能 有2个值，一个是on 一个是off on 代表记录已经输入的值 1.autocomplete 首先需要提交按钮 2.这个表单您必须给他名字 required** 必填项 内容不能为空 accesskey** 规定激活（使元素获得焦点）元素的快捷键 采用 alt + s的形式 综合案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;form action=""&gt; &lt;fieldset&gt; &lt;legend&gt;学生档案&lt;/legend&gt; &lt;label for="userName"&gt;姓名:&lt;/label&gt; &lt;input type="text" name="userName" id="userName" placeholder="请输入用户名"&gt; &lt;br&gt; &lt;label for="userPhone"&gt;手机号码:&lt;/label&gt; &lt;input type="tel" name="userPhone" id="userPhone" pattern="^1\d&#123;10&#125;$"&gt;&lt;br&gt; &lt;label for="email"&gt;邮箱地址:&lt;/label&gt; &lt;input type="email" required name="email" id="email"&gt;&lt;br&gt; &lt;label for="collage"&gt;所属学院:&lt;/label&gt; &lt;input type="text" name="collage" id="collage" list="cList" placeholder="请选择"&gt;&lt;br&gt; &lt;datalist id="cList"&gt; &lt;option value="前端与移动开发学院"&gt;&lt;/option&gt; &lt;option value="java学院"&gt;&lt;/option&gt; &lt;option value="c++学院"&gt;&lt;/option&gt; &lt;/datalist&gt;&lt;br&gt; &lt;label for="score"&gt;入学成绩:&lt;/label&gt; &lt;input type="number" max="100" min="0" value="0" id="score"&gt;&lt;br&gt; &lt;form action=""&gt; &lt;fieldset&gt; &lt;legend&gt;学生档案思密达&lt;/legend&gt; &lt;label&gt;姓名: &lt;input type="text" placeholder="请输入学生名字"/&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;手机号: &lt;input type="tel" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;邮箱: &lt;input type="email" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;所属学院: &lt;input type="text" placeholder="请选择学院" list="xueyuan"/&gt; &lt;datalist id="xueyuan"&gt; &lt;option&gt;java学院&lt;/option&gt; &lt;option&gt;前端学院&lt;/option&gt; &lt;option&gt;php学院&lt;/option&gt; &lt;option&gt;设计学院&lt;/option&gt; &lt;/datalist&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;出生日期: &lt;input type="date" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;成绩: &lt;input type="number" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;毕业时间: &lt;input type="date" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;input type="submit" /&gt; &lt;input type="reset" /&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;label for="inTime"&gt;入学日期:&lt;/label&gt; &lt;input type="date" id="inTime" name="inTime"&gt;&lt;br&gt; &lt;label for="leaveTime"&gt;毕业日期:&lt;/label&gt; &lt;input type="date" id="leaveTime" name="leaveTime"&gt;&lt;br&gt; &lt;input type="submit"&gt; &lt;/fieldset&gt;&lt;/form&gt; 多媒体标签 embed：标签定义嵌入的内容 audio：播放音频 video：播放视频 多媒体 embed（会使用）embed可以用来插入各种多媒体，格式可以是 Midi、Wav、AIFF、AU、MP3等等。url为音频或视频文件及其路径，可以是相对路径或绝对路径。 因为兼容性问题，我们这里只讲解 插入网络视频， 后面H5会讲解 audio 和video 视频多媒体。 1&lt;embed src="http://player.youku.com/player.php/sid/XMTI4MzM2MDIwOA==/v.swf" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"&gt;&lt;/embed&gt; ​ 优酷，土豆，爱奇艺，腾讯、乐视等等 先上传 在分享 多媒体 audioHTML5通过标签来解决音频播放的问题。 使用相当简单，如下图所示 并且可以通过附加属性可以更友好控制音频的播放，如： autoplay 自动播放 controls 是否显不默认播放控件 loop 循环播放 loop = 2 就是循环2次 loop 或者 loop = “-1” 无限循环 由于版权等原因，不同的浏览器可支持播放的格式是不一样的，如下图供参考 多浏览器支持的方案，如下图 多媒体 videoHTML5通过&lt;audio&gt;标签来解决音频播放的问题。 同音频播放一样，&lt;video&gt;使用也相当简单，如下图 同样，通过附加属性可以更友好的控制视频的播放 autoplay 自动播放 controls 是否显示默认播放控件 loop 循环播放 width 设置播放窗口宽度 height 设置播放窗口的高度 由于版权等原因，不同的浏览器可支持播放的格式是不一样的，如下图供参考 多浏览器支持的方案，如下图** 总结 HTML 第二天的主题： 熟悉列表— 会使用表格 — 掌握常用表单]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多台电脑使用hexo写博客]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[任意电脑都可以写自己的博客~ 场景需求工作以后大部分时间都是在用办公室里的电脑，现在想在笔记本和办公室的电脑上都能用hexo写博客。 思路 hexo生成的静态博客文件都是上传到GitHub上的, 且默认放在master分支上, 而一些相关的配置文件都在本地 hexo的源文件（部署环境文件）可以都放在hexo分支上（可以新创建一个hexo分支） 换新电脑时，直接git clone hexo分支 分析本地博客目录展示 新建一个 hexo 分支，把 hexo 的源文件都放到这个分支上。但是源文件有70多M，并不需要把所有文件都放在分支上。 node_modules目录可以用 npm install 命令生成 public目录可以使用 hexo g 命令生成（部署到master分支的内容） .deploy_git目录是hexo d命令生成，所以可以把这三个目录放在 .gitignore 里忽略提交。 实现步骤 建立hexo分支 将其设置为默认分支 将分支内容clone到本地 ​ git clone 仓库地址 hexo_branch 命令执行完毕 会创建hexo_branch文件夹（如果先前有写博客发布到master分支,那么目录下的内容就为hexo生成的静态资源–对应原本博客目录下的pulic文件下的内容) 将clone下来的静态文件全部删除 然后将自己博客目录下的文件夹内容拷贝到hexo_branch 目录里 git add . git commit -m “上传部署环境文件” git push 执行完毕后目录结构如下–至此部署环境文件放在了hexo分支 在新电脑上依次安装git node.js 然后安装hexo 1npm install -g hexo-cli 新电脑clone刚才的分支 然后执行 1npm install 安装所有依赖（生成 node_modules 目录）。 执行 1hexo g 生成博客的静态文件（即 public 目录） 执行 1hexo s //hexo server 运行 hexo 服务器，在浏览器中打开 http://localhost:4000 查看博客是否已经可以运行。 hexo new 文章名称 自己编辑好 重启服务可直接查看已编辑内容展示 执行 $ hexo g -d 或者 $ hexo d -g 将静态资源发布到master分支 然后访问自己的github查看 将更改提交到hexo分支 日常操作换到不同电脑上时，首先拉下 github 上的 hexo分支的更新]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客进阶配置]]></title>
    <url>%2F2019%2F02%2F13%2Fhexo%E8%BF%9B%E9%98%B6%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[为自己的hexo博客添加评论系统、统计阅读量、二维码、本地搜索….. Next 主题github上使用人比较多试了几种评论系统 Valine最好用（来必力加载太慢） hexo主题推荐Next 官方链接:clik me 按照官方指导 clone 下来 放在本地博客主题文件夹中 然后修改全局_config.yml文件 主题里面配置选项非常多，在官网里查看 Leancloud统计文章阅读量参考博文: clik me Hexo加上评论系统-Valine参考博文: clik me 文章末尾添加二维码利用 NexT 主题自带的wechat_subscriber功能在文章末尾添加网站二维码。首先生成你网站的二维码，放到网站根目录下的images文件夹中，然后修改主题配置文件 _config.yml，添加如下内容： 12345# Wechat Subscriberwechat_subscriber: enabled: true qcode: /images/wuxubj.png description: 扫一扫，用手机访问本站 写博客时添加图片参考博文: clik me 1npm install hexo-asset-image --save 博客添加本地搜索1npm install hexo-generator-searchdb --save 修改主题配置文件_config.yml (一定要先执行上面命令，否则链接会一直转圈) 12local_search: enable: true Hexo博客搭建之引用站内文章1&#123;% post_link 文章文件名（不要后缀） 文章标题（可选） %&#125; 如何设置「阅读全文」？1在文章中使用 &lt;!-- more --&gt; 手动进行截断，Hexo 提供的方式 推荐 内置标签设置：click me 取消“文章目录”对标题的自动编号？打开next主题下的配置文件 修改 toc：下配置 1234567891011toc: enable: true \# Automatically add list number to toc. number: false \# If true, all words will placed on next lines if header width longer then sidebar width. wrap: false 博客添加点击爱心效果参考博客 hexo next 配置 DaoVoice 实现在线聊天功能参考博客 网站底部字数统计 安装hexo插件，切换到根目录： 1npm install hexo-wordcount --save 在Blog/themes/next/layout/_partials/footer.swig末尾添加代码： 1234&lt;div class="theme-info"&gt; &lt;div class="powered-by"&gt;&lt;/div&gt; &lt;span class="post-count"&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 坑点1–全局语言配置全局配置文件 中关于站点语言配置 language: zh-Hans（我的配置为zh-CN会出问题） 坑点2 –百度分享功能实现123baidushare:type: slidebaidushare: true 解决百度分享https无法使用 NexT Pisces主题内容区宽度更改直接在source/css/_variables/custom.styl中使用Scheme Gemini 的参数即可 12$main-desktop = 75%$content-desktop = calc(100% - 252px) hexo页脚添加访客人数和总访问量参考博客 不蒜子访问统计官网 hexo 代码高亮问题在站点的配置文件中，搜索hightlight: 12345highlight: enable: true line_number: true auto_detect: true tab_replace: 文字自动检测默认不启动，所以改成true使其起作用。 再到主题的配置文件： highlight_theme: normal，注释显示有五种显示主题可用，分别是： normal night night eighties night blue night bright 包裹代码块方式 ```java 代码块 ``` 注意C# 是无效的的 一定要 csharp 代码拷贝功能实现代码块复制功能 #增加宠物 配置需要丢到站点配置文件中，不然不能切换图像项目地址]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客]]></title>
    <url>%2F2019%2F02%2F13%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[开始搭建属于自己的博客吧！ 背景​ 网上有很多github hexo搭建个人博客的教程，翻阅好多篇博客，简单熟悉以后发现官网教程带视频手把手更详细，更容易理解，不过对于初学者，很晕，不知从哪里看起，从上往下看，肯定是不可取的，在此留下官网资料学习步骤。 hexo官网1https://hexo.io/zh-cn/ 学习步骤 进入文档页面 概述 —了解hexo 建站 —个人博客的安装与本地查看 写作 —学习新建一篇博文、草稿、page页面(网页页面) Front-matter —-文件开头的一个YAML或JSON块，用于为您的文章配置设置 配置 —-在 _config.yml 中修改自己站点的配置 后期注意点 更换主题 写博客的本地图片资源文件夹 命令 —- 了解基本的建站 写作 生成静态资源 部署到类似github的网站命令 部署 —安装自动部署插件 设置部署地点 至此基本写作和部署完成 后续学习 更换博客主题 搭建多台电脑写博客 博客里面插入图片 Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake hexo博客进阶配置 hexo博客进阶配置]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 基本使用]]></title>
    <url>%2F2019%2F02%2F12%2FMarkdown-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[程序员怎么能不会Markdown基本用法 Markdown是什么？Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。 为什么要使用它？ 它是易读（看起来舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子。 兼容HTML，可以转换为HTML格式发布。 跨平台使用。 越来越多的网站支持Markdown。 更方便清晰地组织你的电子邮件。（Markdown-here, Airmail） 摆脱Word（我不是认真的）。 怎么使用？Markdown语法主要分为如下几大部分： 标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \，符号’`’。 标题Markdown支持6种级别的标题，对应html标签 h1 ~ h6 123456# h1## h2### h3#### h4##### h5###### h6 段落需要记住的是，Markdown其实就是一种易于编写的普通文本，只不过加入了部分渲染文本的标签而已。其最终依然会转换为html标签，因此使用Markdown分段非常简单，前后至少保留一个空行即可。 区块引用而另外一个比较常见的需求就是，我们可能希望对某段文字进行强调处理。Markdown提供了一个特殊符号&gt;用于段首进行强调，被强调的文字部分将会高亮显示 &gt; 这段文字将被高亮显示... 以上标记显示效果如下： 这段文字将被高亮显示… 在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如： > 区块引用>&gt; 嵌套引用 效果： 区块引用 嵌套引用 代码区块代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如普通段落： void main(){printf(“Hello, Markdown.”);} 代码区块： 1234void main()&#123; printf("Hello, Markdown.");&#125; 注意: 需要和普通段落之间存在空行。 强调在强调内容两侧分别加上*或者_，如： *斜体*，_斜体_**粗体**，__粗体__ 效果： 斜体，斜体粗体，粗体 列表Markdown支持有序列表和无序列表两种形式： 无序列表使用*或+或-标识 有序列表使用数字加.标识，例如：1. 123456789101112131415* 黄瓜* 玉米* 茄子+ 黄瓜+ 玉米+ 茄子- 黄瓜- 玉米- 茄子1. 黄瓜2. 玉米3. 茄子 以上标记显示效果如下： 黄瓜 玉米 茄子 黄瓜 玉米 茄子 黄瓜 玉米 茄子 黄瓜 玉米 茄子 分割线分割线最常使用就是三个或以上*，还可以使用-和_。 链接和图片Markdown针对链接和图片的处理也比较简单，可以使用下面的语法进行标记 12[点击跳转至百度](http://www.baidu.com)![图片](https://upload-images.jianshu.io/upload_images/703764-605e3cc2ecb664f6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 以上标记显示效果如下： 点击跳转至百度 注： 引用图片和链接的唯一区别就是在最前方添加一个感叹号。 反斜杠\相当于反转义作用。使符号成为普通符号。 符号 `起到标记作用。如： `ctrl+a` 效果： ctrl+a Markdown软件推荐手动去敲，有时还是挺麻烦的，推荐使用markdown软件编写文章，省去一些繁琐的工作 windows 推荐 typora typora官网mac 推荐 Macdown]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[右键-git bash here 还原！]]></title>
    <url>%2F2019%2F02%2F12%2F%E5%8F%B3%E9%94%AE%20git%20bash%20here%20%E8%BF%98%E5%8E%9F%EF%BC%81%2F</url>
    <content type="text"><![CDATA[召唤右键菜单git bash here ​问题场景​ 有时由于安装操作不当，或者后期一些优化软件，导致安装了git 然而鼠标右键菜单中没有git bash here ，每次都需要手动切入到相应的目录再进行操作，很不方便。 解决思路手动编辑注册表，添加到右键菜单 具体步骤具体注册表操作: 点击我查看链接 其他说明 建议安装Everything.exe 软件 方便查找到底安装在那个盘的那个位置]]></content>
      <categories>
        <category>注册表操作</category>
      </categories>
      <tags>
        <tag>注册表操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[右键-以VsCode打开]]></title>
    <url>%2F2019%2F02%2F11%2F%E5%8F%B3%E9%94%AE-%E4%BB%A5VsCode%E6%89%93%E5%BC%80%2F</url>
    <content type="text"><![CDATA[召唤右键菜单 用VsCode打开~ 操作说明 新建文本文件 将下面内容拷贝到文本中 改后缀名为xxx.reg形式 点击运行，同意写注册表 1234567891011121314151617181920212223242526Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\*\shell\VSCode]@="Open with Code""Icon"="C:\\Program Files\\Microsoft VS Code\\Code.exe"[HKEY_CLASSES_ROOT\*\shell\VSCode\command]@="\"C:\\Program Files\\Microsoft VS Code\\Code.exe\" \"%1\""Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\shell\VSCode]@="Open with Code""Icon"="C:\\Program Files\\Microsoft VS Code\\Code.exe"[HKEY_CLASSES_ROOT\Directory\shell\VSCode\command]@="\"C:\\Program Files\\Microsoft VS Code\\Code.exe\" \"%V\""Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\Background\shell\VSCode]@="Open with Code""Icon"="C:\\Program Files\\Microsoft VS Code\\Code.exe"[HKEY_CLASSES_ROOT\Directory\Background\shell\VSCode\command]@="\"C:\\Program Files\\Microsoft VS Code\\Code.exe\" \"%V\""]]></content>
      <categories>
        <category>注册表操作</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>右键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[右键-在此处打开CMD]]></title>
    <url>%2F2019%2F02%2F11%2F%E5%8F%B3%E9%94%AE-%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80CMD%2F</url>
    <content type="text"><![CDATA[召唤右键菜单 Open CMD in Here~ 操作说明新建文本文件，将后缀改为reg 然后点击运行 确认修改注册表 1234567891011121314151617181920212223242526272829Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\shell\OpenCmdHere]@="Open CMD in Here""Icon"="cmd.exe"[HKEY_CLASSES_ROOT\Directory\shell\OpenCmdHere\command]@="cmd.exe /s /k pushd "%V""[HKEY_CLASSES_ROOT\Directory\Background\shell\OpenCmdHere]@="Open CMD in Here""Icon"="cmd.exe"[HKEY_CLASSES_ROOT\Directory\Background\shell\OpenCmdHere\command]@="cmd.exe /s /k pushd \"%V\""[HKEY_CLASSES_ROOT\Drive\shell\OpenCmdHere]@="Open CMD in Here""Icon"="cmd.exe"[HKEY_CLASSES_ROOT\Drive\shell\OpenCmdHere\command]@="cmd.exe /s /k pushd \"%V\""[HKEY_CLASSES_ROOT\LibraryFolder\background\shell\OpenCmdHere]@="Open CMD in Here""Icon"="cmd.exe"[HKEY_CLASSES_ROOT\LibraryFolder\background\shell\OpenCmdHere\command]@="cmd.exe /s /k pushd \"%V\""]]></content>
      <categories>
        <category>注册表操作</category>
      </categories>
      <tags>
        <tag>右键</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[我来的第一天~ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Create a new post1hexo new "My New Post" More info: Writing Run server1hexo server More info: Server Generate static files1hexo generate More info: Generating Deploy to remote sites1hexo deploy More info: Deployment]]></content>
  </entry>
</search>
