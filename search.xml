<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[VUE动画、组件、路由]]></title>
    <url>%2F2019%2F06%2F12%2Fvue%E4%B9%8B%E5%8A%A8%E7%94%BB%E3%80%81%E7%BB%84%E4%BB%B6%E3%80%81%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[学习VUE动画、组件定义、前端路由的使用 Vue中的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能； 123456789101112131415161718&lt;body&gt; &lt;!-- 不使用动画 --&gt; &lt;div id="app"&gt; &lt;input type="button" value="toggle" @click="flag=!flag"&gt; &lt;!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 --&gt; &lt;h3 v-if="flag"&gt;这是一个H3&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt; 使用过渡类名123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 &lt;!-- 2. 自定义两组样式，来控制 transition 内部的元素实现动画 --&gt; &lt;style&gt; /* v-enter 【这是一个时间点】 是进入之前，元素的起始状态，此时还没有开始进入 */ /* v-leave-to 【这是一个时间点】 是动画离开之后，离开的终止状态，此时，元素 动画已经结束了 */ .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(150px); &#125; /* v-enter-active 【入场动画的时间段】 */ /* v-leave-active 【离场动画的时间段】 */ .v-enter-active, .v-leave-active&#123; transition: all 0.8s ease; &#125; /* &lt;transition name="my"&gt; 此处使用my开头 */ .my-enter, .my-leave-to &#123; opacity: 0; transform: translateY(70px); &#125; .my-enter-active, .my-leave-active&#123; transition: all 0.8s ease; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" value="toggle" @click="flag=!flag"&gt; &lt;!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 --&gt; &lt;!-- 1. 使用 transition 元素，把 需要被动画控制的元素，包裹起来 --&gt; &lt;!-- transition 元素，是 Vue 官方提供的 --&gt; &lt;transition&gt; &lt;h3 v-if="flag"&gt;这是一个H3&lt;/h3&gt; &lt;/transition&gt; &lt;hr&gt; &lt;input type="button" value="toggle2" @click="flag2=!flag2"&gt; &lt;transition name="my"&gt; &lt;h6 v-if="flag2"&gt;这是一个H6&lt;/h6&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false, flag2: false &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt; 使用第三方 CSS 动画库 导入动画类库： 1&lt;link rel="stylesheet" type="text/css" href="./lib/animate.css"&gt; 定义 transition 及属性： 123456&lt;transition enter-active-class="fadeInRight" leave-active-class="fadeOutRight" :duration="&#123; enter: 500, leave: 800 &#125;"&gt; &lt;div class="animated" v-show="isshow"&gt;动画哦&lt;/div&gt;&lt;/transition&gt; 12345678910111213141516171819202122232425262728293031323334353637&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="./lib/animate.css"&gt; &lt;!-- 入场 bounceIn 离场 bounceOut --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" value="toggle" @click="flag=!flag"&gt; &lt;!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 --&gt; &lt;!-- 使用 :duration="&#123; enter: 200, leave: 400 &#125;" 来分别设置 入场的时长 和 离场的时长 --&gt; &lt;transition enter-active-class="bounceIn" leave-active-class="bounceOut" :duration="&#123; enter: 200, leave: 400 &#125;" &gt; &lt;h3 v-if="flag" class="animated"&gt;这是一个H3&lt;/h3&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt; 使用动画钩子函数 定义动画过渡时长和样式： 123.show&#123; transition: all 0.4s ease; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;style&gt; .ball &#123; width: 15px; height: 15px; border-radius: 50%; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" value="快到碗里来" @click="flag=!flag"&gt; &lt;!-- 1. 使用 transition 元素把 小球包裹起来 --&gt; &lt;!-- 定义 transition 组件以及三个钩子函数：--&gt; &lt;transition @before-enter="beforeEnter" @enter="enter" @after-enter="afterEnter"&gt; &lt;div class="ball" v-show="flag"&gt;&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123;// 注意： 动画钩子函数的第一个参数：el，表示 要执行动画的那个DOM元素，是个原生的 JS DOM对象// 大家可以认为 ， el 是通过 document.getElementById('') 方式获取到的原生JS DOM对象 beforeEnter(el)&#123; // beforeEnter 表示动画入场之前，可以 在 beforeEnter 中，设置元素开始动画之前的起始样式// 设置小球开始动画之前的，起始位置 el.style.transform = "translate(0, 0)" &#125;, enter(el, done)&#123; // 这句话，没有实际的作用，但是，如果不写，出不来动画效果；可以认为 el.offsetWidth 会强制动画刷新 el.offsetWidth// enter 表示动画 开始之后的样式，这里，可以设置小球完成动画之后的，结束状态 el.style.transform = "translate(150px, 450px)" el.style.transition = 'all 1s ease'// 这里的 done， 起始就是 afterEnter 这个函数，也就是说：done 是 afterEnter 函数的引用 done() //立即执行，不然会有等待 &#125;, afterEnter(el)&#123;// 动画完成之后，会调用 afterEnter this.flag = !this.flag &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-for 的列表过渡 定义过渡样式： 定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来： 定义 VM中的结构： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;style&gt; li &#123; border: 1px dashed #999; margin: 5px; line-height: 35px; padding-left: 5px; font-size: 12px; width: 100%; &#125; li:hover &#123; background-color: hotpink; transition: all 0.8s ease; &#125; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateY(80px); &#125; .v-enter-active, .v-leave-active &#123; transition: all 0.6s ease; &#125;/* 下面的 .v-move 和 .v-leave-active 配合使用，能够实现删除后列表后续的元素，渐渐地漂上来的效果 */ .v-move &#123; transition: all 0.6s ease; &#125; .v-leave-active&#123; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;div&gt; &lt;label&gt; Id: &lt;input type="text" v-model="id"&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type="text" v-model="name"&gt; &lt;/label&gt; &lt;input type="button" value="添加" @click="add"&gt; &lt;/div&gt; &lt;!-- 在实现列表过渡的时候，如果需要过渡的元素，是通过 v-for 循环渲染出来的，不能使用 transition 包裹，需要使用 transitionGroup --&gt;&lt;!-- 如果要为 v-for 循环创建的元素设置动画，必须为每一个 元素 设置 :key 属性 --&gt; &lt;!-- 给 ransition-group 添加 appear 属性，实现页面刚展示出来时候，入场时候的效果 --&gt;&lt;!-- 通过 为 transition-group 元素，设置 tag 属性，指定 transition-group 渲染为指定的元素，如果不指定 tag 属性，默认，渲染为 span 标签 --&gt; &lt;transition-group appear tag="ul"&gt; &lt;li v-for="(item, i) in list" :key="item.id" @click="del(i)"&gt; &#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125; &lt;/li&gt; &lt;/transition-group&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; id: '', name: '', list: [ &#123; id: 1, name: '赵高' &#125;, &#123; id: 2, name: '秦桧' &#125;, &#123; id: 3, name: '严嵩' &#125;, &#123; id: 4, name: '魏忠贤' &#125; ] &#125;, methods: &#123; add() &#123; this.list.push(&#123; id: this.id, name: this.name &#125;) this.id = this.name = '' &#125;, del(i) &#123; this.list.splice(i, 1) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和： 123456.v-move&#123; transition: all 0.8s ease;&#125;.v-leave-active&#123; position: absolute;&#125; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 pagekit/vue-resource navicat如何导入sql文件和导出sql文件 贝塞尔在线生成器 定义Vue组件什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用； 全局组件定义的三种方式Vue.extend 配合 Vue.component1234567891011121314151617181920212223242526272829303132333435&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 如果要使用组件，直接，把组件的名称，以 HTML 标签的形式，引入到页面中，即可 --&gt; &lt;mycom1&gt;&lt;/mycom1&gt; &lt;/div&gt; &lt;script&gt;// 1.1 使用 Vue.extend 来创建全局的Vue组件var com1 = Vue.extend(&#123; // 通过 template 属性，指定了组件要展示的HTML结构 template: '&lt;h3&gt;这是使用 Vue.extend 创建的组件&lt;/h3&gt;' &#125;)// 1.2 使用 Vue.component('组件的名称', 创建出来的组件模板对象)// Vue.component('myCom1', com1)// 如果使用 Vue.component 定义全局组件的时候，组件名称使用了 驼峰命名，则在引用组件的时候，需要把 大写的驼峰改为小写的字母，同时，两个单词之前，使用 - 链接；// 如果不使用驼峰,则直接拿名称来使用即可; Vue.component('mycom1', com1)// Vue.component 第一个参数:组件的名称,将来在引用组件的时候,就是一个 标签形式 来引入 它的// 第二个参数: Vue.extend 创建的组件 ,其中 template 就是组件将来要展示的HTML内容 Vue.component('mycom1', Vue.extend(&#123; template: '&lt;h3&gt;这是使用 Vue.extend 创建的组件&lt;/h3&gt;' &#125;)) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt; 直接使用 Vue.component123456789101112131415161718192021&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 还是使用 标签形式,引入自己的组件 --&gt; &lt;mycom2&gt;&lt;/mycom2&gt; &lt;/div&gt; &lt;script&gt; // 注意:不论哪种方式创建出来的组件,组件的 template 属性指向的模板内容,必须有且只能有唯一的一个根元素 Vue.component('mycom2', &#123; template: '&lt;div&gt;&lt;h3&gt;这是直接使用 Vue.component 创建出来的组件&lt;/h3&gt;&lt;span&gt;123&lt;/span&gt;&lt;/div&gt;' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt; 将模板字符串，定义到script标签：123&lt;script id=&quot;tmpl&quot; type=&quot;x-template&quot;&gt; &lt;div&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;/div&gt; &lt;/script&gt; 同时，需要使用 Vue.component 来定义组件： 123Vue.component(&apos;account&apos;, &#123; template: &apos;#tmpl&apos; &#125;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;body&gt; &lt;div id="app"&gt; &lt;mycom3&gt;&lt;/mycom3&gt; &lt;/div&gt; &lt;div id="app2"&gt; &lt;mycom3&gt;&lt;/mycom3&gt; &lt;login&gt;&lt;/login&gt; &lt;/div&gt; &lt;!-- 在 被控制的 #app 外面,使用 template 元素,定义组件的HTML模板结构 --&gt; &lt;template id="tmpl"&gt; &lt;div&gt; &lt;h1&gt;这是通过 template 元素,在外部定义的组件结构,这个方式,有代码的只能提示和高亮&lt;/h1&gt; &lt;h4&gt;好用,不错!&lt;/h4&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id="tmpl2"&gt; &lt;h1&gt;这是私有的 login 组件&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; Vue.component('mycom3', &#123; template: '#tmpl' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;); var vm2 = new Vue(&#123; el: '#app2', data: &#123;&#125;, methods: &#123;&#125;, filters: &#123;&#125;, directives: &#123;&#125;, components: &#123; // 定义实例内部私有组件的 login: &#123; template: '#tmpl2' &#125; &#125;, beforeCreate() &#123; &#125;, created() &#123; &#125;, beforeMount() &#123; &#125;, mounted() &#123; &#125;, beforeUpdate() &#123; &#125;, updated() &#123; &#125;, beforeDestroy() &#123; &#125;, destroyed() &#123; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！ 组件中展示数据和响应事件 在组件中，data需要被定义为一个方法 返回一个对象 why components data must be a function 在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的data属性中的值，需要使用this来访问； 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;mycom1&gt;&lt;/mycom1&gt; &lt;/div&gt; &lt;script&gt;// 1. 组件可以有自己的 data 数据// 2.组件的 data 和 实例 data 有点不一样,实例中的 data 可以为一个对象,组件中的 data 必须是一个方法// 3. 组件中的 data 除了必须为一个方法之外,这个方法内部,还必须返回一个对象才行;// 4. 组件中 的data 数据,使用方式,和实例中的 data 使用方式完全一样!!! Vue.component('mycom1', &#123; template: '&lt;h1&gt;这是全局组件 --- &#123;&#123;msg&#125;&#125;&lt;/h1&gt;', data: function () &#123; return &#123; msg: '这是组件的中data定义的数据' &#125; &#125; &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657### 【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象避免 组件共享同一个实例 牵一发而动全身&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;counter&gt;&lt;/counter&gt; &lt;hr&gt; &lt;counter&gt;&lt;/counter&gt; &lt;hr&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; &lt;template id="tmpl"&gt; &lt;div&gt; &lt;input type="button" value="+1" @click="increment"&gt; &lt;h3&gt;&#123;&#123;count&#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var dataObj = &#123; count: 0 &#125; // 这是一个计数器的组件, 身上有个按钮,每当点击按钮,让 data 中的 count 值 +1 Vue.component('counter', &#123; template: '#tmpl', data: function () &#123; // return dataObj return &#123; count: 0 &#125; &#125;, methods: &#123; increment() &#123; this.count++ &#125; &#125; &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; components属性定义局部子组件 组件实例定义方式： 123456789101112131415161718&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, components: &#123; // 定义子组件 account: &#123; // account 组件 template: '&lt;div&gt;&lt;h1&gt;这是Account组件&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;login&gt;&lt;/login&gt;&lt;/div&gt;', // 在这里使用定义的子组件 components: &#123; // 定义子组件的子组件 login: &#123; // login 组件 template: "&lt;h3&gt;这是登录组件&lt;/h3&gt;" &#125; &#125; &#125; &#125; &#125;);&lt;/script&gt; 引用组件： 123&lt;div id=&quot;app&quot;&gt; &lt;account&gt;&lt;/account&gt;&lt;/div&gt; flag标识符结合v-if和v-else切换组件123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;a href="" @click.prevent="flag=true"&gt;登录&lt;/a&gt; &lt;a href="" @click.prevent="flag=false"&gt;注册&lt;/a&gt; &lt;login v-if="flag"&gt;&lt;/login&gt; &lt;register v-else="flag"&gt;&lt;/register&gt; &lt;/div&gt; &lt;script&gt; Vue.component('login', &#123; template: '&lt;h3&gt;登录组件&lt;/h3&gt;' &#125;) Vue.component('register', &#123; template: '&lt;h3&gt;注册组件&lt;/h3&gt;' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;= :is属性切换子组件,并添加切换动画 组件实例定义方式： 12345678910111213141516171819&lt;script&gt; // 组件名称是 字符串 Vue.component('login', &#123; template: '&lt;h3&gt;登录组件&lt;/h3&gt;' &#125;) Vue.component('register', &#123; template: '&lt;h3&gt;注册组件&lt;/h3&gt;' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; comName: 'login' // 当前 component 中的 :is 绑定的组件的名称 &#125;, methods: &#123;&#125; &#125;);&lt;/script&gt; 使用component标签，来引用组件，并通过:is属性来指定要加载的组件： 123456&lt;div id="app"&gt; &lt;a href="" @click.prevent="comName='login'"&gt;登录&lt;/a&gt; &lt;a href="" @click.prevent="comName='register'"&gt;注册&lt;/a&gt; &lt;component :is="comName"&gt;&lt;/component&gt;&lt;/div&gt; 添加切换样式： 1234567891011121314151617181920212223&lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(30px); &#125; .v-enter-active, .v-leave-active &#123; position: absolute; transition: all 0.3s ease; &#125; h3&#123; margin: 0; &#125;&lt;/style&gt;&lt;!-- 通过 mode 属性,设置组件切换时候的 模式 先走再进来 --&gt; &lt;transition mode="out-in"&gt; &lt;component :is="comName"&gt;&lt;/component&gt; &lt;/transition&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;a href="" @click.prevent="comName='login'"&gt;登录&lt;/a&gt; &lt;a href="" @click.prevent="comName='register'"&gt;注册&lt;/a&gt;&lt;!-- Vue提供了 component ,来展示对应名称的组件 --&gt;&lt;!-- component 是一个占位符, :is 属性,可以用来指定要展示的组件的名称 --&gt;&lt;!-- 通过 mode 属性,设置组件切换时候的 模式 --&gt; &lt;transition mode="out-in"&gt; &lt;component :is="comName"&gt;&lt;/component&gt; &lt;/transition&gt;&lt;!-- 总结:当前学习了几个 Vue 提供的标签了??? --&gt;&lt;!-- component, template, transition, transitionGroup --&gt; &lt;/div&gt; &lt;script&gt; // 组件名称是 字符串 Vue.component('login', &#123; template: '&lt;h3&gt;登录组件&lt;/h3&gt;' &#125;) Vue.component('register', &#123; template: '&lt;h3&gt;注册组件&lt;/h3&gt;' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; comName: 'login' // 当前 component 中的 :is 绑定的组件的名称 &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 回顾小球动画12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;style&gt; .ball &#123; width: 15px; height: 15px; background-color: red; border-radius: 50%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" value="加入购物车" @click="flag=!flag"&gt; &lt;transition @before-enter="beforeEnter" @enter="enter" @after-enter="afterEnter"&gt; &lt;div class="ball" v-show="flag"&gt;&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123; beforeEnter(el)&#123; el.style.transform = 'translate(0, 0)' &#125;, enter(el, done)&#123; el.offsetWidth el.style.transform = 'translate(150px, 450px)' el.style.transition = 'all 1s ease' done() &#125;, afterEnter(el)&#123; // 这句话， 第一个功能，是控制小球的显示与隐藏 // 第二个功能： 直接跳过后半场动画，让 flag 标识符 直接变为 false // 当第二次再点击 按钮的时候， flag false -&gt; true this.flag = !this.flag //不要后半场动画 // el.style.opacity = 0.5 // Vue 把一个完整的动画，使用钩子函数，拆分为了两部分： // 我们使用 flag 标识符，来表示动画的切换； // 刚以开始，flag = false -&gt; true -&gt; false（后半场动画） &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 组件定义12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;div id="app"&gt; &lt;!-- &lt;mylogin&gt;&lt;/mylogin&gt; --&gt; &lt;login&gt;&lt;/login&gt; &lt;/div&gt; &lt;script&gt;// 定义组件的时候，如果要定义全局的组件， Vue.component('组件的名称', &#123;&#125;)// 通过 对象 字面量的形式， 定义了一个 组件模板对象 var login = &#123; template: '&lt;h1&gt;1234&lt;/h1&gt;' &#125;// 通过 Vue.component 把, 组件模板对象，注册为一个全局的Vue 组件，同时，为这个组件起了一个名称，可以让我们 通过 标签形式，在页面中直接引入这个组件 Vue.component('mylogin' login) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, components: &#123; // '组件的名称': 组件的模板对象 // 'mylogin': login login &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;body&gt; &lt;div id="app"&gt;&lt;!-- 父组件，可以在引用子组件的时候， 通过 属性绑定（v-bind:） 的形式, 把 需要传递给 子组件的数据，以属性绑定的形式，传递到子组件内部，供子组件使用 --&gt; &lt;com1 v-bind:parentmsg="msg"&gt;&lt;/com1&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123 啊-父组件中的数据' &#125;, methods: &#123;&#125;, components: &#123;// 结论：经过演示，发现，子组件中，默认无法访问到 VM对对象 data 上的数据 和 methods 中的方法 com1: &#123; data() &#123; // 注意： 子组件中的 data 数据，并不是通过 父组件传递过来的，而是子组件自身私有的，比如： 子组件通过 Ajax ，请求回来的数据，都可以放到 data 身上； // data 上的数据，都是可读可写的； return &#123; title: '123', content: 'qqq' &#125; &#125;, template: '&lt;h1 @click="change"&gt;这是子组件 --- &#123;&#123; parentmsg &#125;&#125;&lt;/h1&gt;', // 注意： 组件中的 所有 props 中的数据，都是通过 父组件传递给子组件的// props 中的数据，都是只读的，无法重新赋值 props: ['parentmsg'],// 把父组件传递过来的 parentmsg 属性，先在 props 数组中，定义一下，这样，才能使用这个数据 directives: &#123;&#125;, filters: &#123;&#125;, components: &#123;&#125;, methods: &#123; change() &#123; this.parentmsg = '被修改了' &#125; &#125; &#125;//end of com1 &#125;//end of components &#125;); &lt;/script&gt;&lt;/body&gt; 使用v-bind或简化指令，将数据传递到子组件中： 123&lt;div id=&quot;app&quot;&gt; &lt;son :finfo=&quot;msg&quot;&gt;&lt;/son&gt; &lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 父组件向子组件 传递 方法，使用的是 事件绑定机制； v-on, 当我们自定义了 一个 事件属性之后，那么，子组件就能够，通过某些方式，来调用 传递进去的 这个 方法了 --&gt; &lt;!--父组件的show方法 --&gt; &lt;com2 @func="show"&gt;&lt;/com2&gt; &lt;/div&gt; &lt;template id="tmpl"&gt; &lt;div&gt; &lt;h1&gt;这是 子组件&lt;/h1&gt; &lt;input type="button" value="这是子组件中的按钮 - 点击它，触发 父组件传递过来的 func 方法" @click="myclick"&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt;// 定义了一个字面量类型的 组件模板对象 var com2 = &#123; template: '#tmpl', // 通过指定了一个 Id, 表示 说，要去加载 这个指定Id的 template 元素中的内容，当作 组件的HTML结构 data() &#123; return &#123; sonmsg: &#123; name: '小头儿子', age: 6 &#125; &#125; &#125;, methods: &#123; myclick() &#123;// 当点击子组件的按钮的时候，如何 拿到 父组件传递过来的 func 方法，并调用这个方法？？？// emit 英文原意： 是触发，调用、发射的意思 // this.$emit('func123', 123, 456) this.$emit('func', this.sonmsg) //func是绑定的属性 可以随意设置 &#125; &#125; &#125; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; datamsgFormSon: null &#125;, methods: &#123; show(data) &#123;// console.log('调用了父组件身上的 show 方法: --- ' + data)// console.log(data); this.datamsgFormSon = data &#125; &#125;, components: &#123; com2 // com2: com2 &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 1&lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt; 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 评论列表案例目标：主要练习父子组件之间传值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;body&gt; &lt;div id="app"&gt; &lt;cmt-box @func="loadComments"&gt;&lt;/cmt-box&gt; &lt;ul class="list-group"&gt; &lt;li class="list-group-item" v-for="item in list" :key="item.id"&gt; &lt;span class="badge"&gt;评论人： &#123;&#123; item.user &#125;&#125;&lt;/span&gt; &#123;&#123; item.content &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;template id="tmpl"&gt; &lt;div&gt; &lt;div class="form-group"&gt; &lt;label&gt;评论人：&lt;/label&gt; &lt;input type="text" class="form-control" v-model="user"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;评论内容：&lt;/label&gt; &lt;textarea class="form-control" v-model="content"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;input type="button" value="发表评论" class="btn btn-primary" @click="postComment"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var commentBox = &#123; data() &#123; return &#123; user: '', content: '' &#125; &#125;, template: '#tmpl', methods: &#123; postComment() &#123; // 发表评论的方法// 分析：发表评论的业务逻辑// 1. 评论数据存到哪里去？？？ 存放到了 localStorage 中 localStorage.setItem('cmts', '')// 2. 先组织出一个最新的评论数据对象// 3. 想办法，把 第二步中，得到的评论对象，保存到 localStorage 中：// 3.1 localStorage 只支持存放字符串数据， 要先调用 JSON.stringify // 3.2 在保存 最新的 评论数据之前，要先从 localStorage 获取到之前的评论数据（string）， 转换为 一个 数组对象， 然后，把最新的评论， push 到这个数组 (防止覆盖键相同的) // 3.3 如果获取到的 localStorage 中的 评论字符串，为空不存在， 则 可以 返回一个 '[]' 让 JSON.parse 去转换 // 3.4 把 最新的 评论列表数组，再次调用 JSON.stringify 转为 数组字符串，然后调用 localStorage.setItem() var comment = &#123; id: Date.now(), user: this.user, content: this.content &#125; // 从 localStorage 中获取所有的评论 var list = JSON.parse(localStorage.getItem('cmts') || '[]') list.unshift(comment) // 重新保存最新的 评论数据 localStorage.setItem('cmts', JSON.stringify(list)) this.user = this.content = '' // this.loadComments() // ????? this.$emit('func') &#125;//end of postComment &#125; //end of methond &#125;//end of commentbox // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; list: [ &#123; id: Date.now(), user: '李白', content: '天生我材必有用' &#125;, &#123; id: Date.now(), user: '江小白', content: '劝君更尽一杯酒' &#125;, &#123; id: Date.now(), user: '小马', content: '我姓马， 风吹草低见牛羊的马' &#125; ] &#125;, beforeCreate()&#123; // 注意：这里不能调用 loadComments 方法，因为在执行这个钩子函数的时候，data 和 methods 都还没有被初始化好 &#125;, created()&#123; this.loadComments() &#125;, methods: &#123; loadComments() &#123; // 从本地的 localStorage 中，加载评论列表 var list = JSON.parse(localStorage.getItem('cmts') || '[]') this.list = list &#125; &#125;, components: &#123; 'cmt-box': commentBox &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 使用 this.$refs 来获取元素和组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" value="获取元素" @click="getElement" ref="mybtn"&gt; &lt;h3 id="myh3" ref="myh3"&gt;哈哈哈， 今天天气太好了！！！&lt;/h3&gt; &lt;hr&gt; &lt;login ref="mylogin"&gt;&lt;/login&gt; &lt;/div&gt; &lt;script&gt; var login = &#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;', data() &#123; return &#123; msg: 'son msg' &#125; &#125;, methods: &#123; show() &#123; console.log('调用了子组件的方法') &#125; &#125; &#125; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement() &#123; // console.log(document.getElementById('myh3').innerText) // ref 是 英文单词 【reference】 值类型 和 引用类型 referenceError // console.log(this.$refs.myh3.innerText) // console.log(this.$refs.mylogin.msg) // this.$refs.mylogin.show() &#125; &#125;, components: &#123; login &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 什么是路由 后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 在 vue 中使用 vue-router 导入 vue-router 组件类库： 12&lt;!-- 1. 导入 vue-router 组件类库 --&gt; &lt;script src="./lib/vue-router-2.7.0.js"&gt;&lt;/script&gt; 使用 router-link 组件来导航——使用tag属性指定router-link渲染的标签类型- 12345678910111213&lt;!-- &lt;a href=&quot;#/login&quot;&gt;登录&lt;/a&gt; --&gt; &lt;!-- 每次写#不方便 使用下面的方式--&gt; &lt;!-- &lt;a href=&quot;#/register&quot;&gt;注册&lt;/a&gt; --&gt;&lt;!-- 2. 使用 router-link 组件来导航 --&gt;&lt;!-- router-link 默认渲染为一个a 标签 --&gt; &lt;router-link to=&quot;/login&quot; tag=&quot;span&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;&lt;!-- 这是 vue-router 提供的元素，专门用来 当作占位符的，将来，路由规则，匹配到的组件，就会展示到这个 router-view 中去 --&gt;&lt;!-- 所以： 我们可以把 router-view 认为是一个占位符 --&gt; &lt;transition mode=&quot;out-in&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!--//--设置路由切换动效--&gt; &lt;/transition&gt; 使用 router-view 组件来显示匹配到的组件 12&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 创建使用Vue.extend创建组件 123456789101112131415161718 // 4.1 使用 Vue.extend 来创建登录组件 var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;' &#125;); // 4.2 使用 Vue.extend 来创建注册组件 var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;' &#125;);// 组件的模板对象 var login = &#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;' &#125; var register = &#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;' &#125; 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则— 设置路由重定向 12345678910111213141516// 创建一个路由对象， 当导入 vue-router 包之后，在 window 全局对象中，就有了一个 路由的构造函数，叫做 VueRouter// 在 new 路由对象的时候，可以为 构造函数，传递一个配置对象 var routerObj = new VueRouter(&#123;// route // 这个配置对象中的 route 表示 【路由匹配规则】 的意思 routes: [ // 路由匹配规则 // 每个路由规则，都是一个对象，这个规则对象，身上，有两个必须的属性：// 属性1 是 path， 表示监听 哪个路由链接地址；// 属性2 是 component， 表示，如果 路由是前面匹配到的 path ，则展示 component 属性对应的那个组件// 注意： component 的属性值，必须是一个 组件的模板对象， 不能是 组件的引用名称； &#123; path: '/', redirect: '/login' &#125;, //进来默认路由到登录组件// 这里的 redirect 和 Node 中的 redirect 完全是两码事 &#123; path: '/login', component: login &#125;, //不能加'' &#123; path: '/register', component: register &#125; ], linkActiveClass: 'myactive' //更改链接激活使用的css类 &#125;) 使用 router 属性来使用路由规则 12345// 6. 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', router: routerObj // 将路由规则对象，注册到 vm 实例上，用来监听 URL 地址的变化，然后展示对应的组件 &#125;); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;!-- 1. 安装 vue-router 路由模块 --&gt; &lt;script src="./lib/vue-router-3.0.1.js"&gt;&lt;/script&gt; &lt;style&gt; .router-link-active, .myactive &#123; color: red; font-weight: 800; font-style: italic; font-size: 80px; text-decoration: underline; background-color: green; &#125; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(140px); &#125; .v-enter-active, .v-leave-active &#123; transition: all 0.5s ease; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;router-link to="/login" tag="span"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;transition mode="out-in"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; // 组件的模板对象 var login = &#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;' &#125; var register = &#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;' &#125; var routerObj = new VueRouter(&#123; routes: [ // 这里的 redirect 和 Node 中的 redirect 完全是两码事 &#123; path: '/', redirect: '/login' &#125;, //进来默认路由到登录组件 &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ], linkActiveClass: 'myactive' //实现路由高亮 &#125;) var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;,// 将路由规则对象，注册到 vm 实例上，用来监听 URL 地址的变化，然后展示对应的组件 router: routerObj &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在路由规则中定义参数123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;body&gt; &lt;!-- 方式一 $route.query --&gt; &lt;div id="app"&gt; &lt;!-- 如果在路由中，使用 查询字符串，给路由传递参数，则 不需要修改 路由规则的 path 属性 --&gt; &lt;router-link to="/login?id=10&amp;name=zs"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = &#123; template: '&lt;h1&gt;登录 --- &#123;&#123; $route.query.id &#125;&#125; --- &#123;&#123; $route.query.name &#125;&#125;&lt;/h1&gt;', data()&#123; return &#123; msg: '123' &#125; &#125;, created()&#123; // 组件的生命周期钩子函数 可以拿到路由数据 // console.log(this.$route) // console.log(this.$route.query.id) &#125; &#125; var register = &#123; template: '&lt;h1&gt;注册&lt;/h1&gt;' &#125; var router = new VueRouter(&#123; routes: [ &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ] &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, // router: router router &#125;); &lt;/script&gt;&lt;/body&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;body&gt; &lt;!-- 方式二 $route.params --&gt; &lt;div id="app"&gt; &lt;router-link to="/login/12/ls"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = &#123; template: '&lt;h1&gt;登录 --- &#123;&#123; $route.params.id &#125;&#125; --- &#123;&#123; $route.params.name &#125;&#125;&lt;/h1&gt;', data()&#123; return &#123; msg: '123' &#125; &#125;, created()&#123; // 组件的生命周期钩子函数 console.log(this.$route.params.id) &#125; &#125; var register = &#123; template: '&lt;h1&gt;注册&lt;/h1&gt;' &#125; var router = new VueRouter(&#123; routes: [ &#123; path: '/login/:id/:name', component: login &#125;, &#123; path: '/register', component: register &#125; ] &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, // router: router router &#125;); &lt;/script&gt;&lt;/body&gt; 在规则中定义参数： 1&#123; path: &apos;/register/:id&apos;, component: register &#125; 通过 this.$route.params来获取路由中的参数： 123var register = Vue.extend(&#123; template: &apos;&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt;&apos; &#125;); children 属性实现路由嵌套123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;body&gt; &lt;div id="app"&gt; &lt;router-link to="/account"&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 展示父组件 --&gt; &lt;/div&gt; &lt;template id="tmpl"&gt; &lt;div&gt; &lt;h1&gt;这是 Account 组件&lt;/h1&gt; &lt;router-link to="/account/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/account/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 展示子组件 --&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 组件的模板对象 var account = &#123; template: '#tmpl' &#125; var login = &#123; template: '&lt;h3&gt;登录&lt;/h3&gt;' &#125; var register = &#123; template: '&lt;h3&gt;注册&lt;/h3&gt;' &#125; var router = new VueRouter(&#123; routes: [ &#123; path: '/account', component: account, // 使用 children 属性，实现子路由，同时，子路由的 path 前面，不要带 / ，否则永远以根路径开始请求，这样不方便我们用户去理解URL地址 children: [ &#123; path: 'login', component: login &#125;, &#123; path: 'register', component: register &#125; ] &#125; // &#123; path: '/account/login', component: login &#125;, // &#123; path: '/account/register', component: register &#125; ] &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;/script&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id="app"&gt; &lt;router-link to="/account"&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; // 父路由中的组件 const account = Vue.extend(&#123; template: `&lt;div&gt; 这是account组件 &lt;router-link to="/account/login"&gt;login&lt;/router-link&gt; | &lt;router-link to="/account/register"&gt;register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;` &#125;); // 子路由中的 login 组件 const login = Vue.extend(&#123; template: '&lt;div&gt;登录组件&lt;/div&gt;' &#125;); // 子路由中的 register 组件 const register = Vue.extend(&#123; template: '&lt;div&gt;注册组件&lt;/div&gt;' &#125;); // 路由实例 var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/account/login' &#125;, // 使用 redirect 实现路由重定向 &#123; path: '/account', component: account, children: [ // 通过 children 数组属性，来实现路由的嵌套 &#123; path: 'login', component: login &#125;, // 注意，子路由的开头位置，不要加 / 路径符 &#123; path: 'register', component: register &#125; ] &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, components: &#123; account &#125;, router: router &#125;);&lt;/script&gt; 命名视图实现经典布局 标签代码结构： 1234567&lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class="content"&gt; &lt;router-view name="a"&gt;&lt;/router-view&gt; &lt;router-view name="b"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; JS代码： 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; var header = Vue.component('header', &#123; template: '&lt;div class="header"&gt;header&lt;/div&gt;' &#125;); var sidebar = Vue.component('sidebar', &#123; template: '&lt;div class="sidebar"&gt;sidebar&lt;/div&gt;' &#125;); var mainbox = Vue.component('mainbox', &#123; template: '&lt;div class="mainbox"&gt;mainbox&lt;/div&gt;' &#125;); // 创建路由对象 var router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; default: header, a: sidebar, b: mainbox &#125; &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;/script&gt; CSS 样式： 12345678910111213141516171819&lt;style&gt; .header &#123; border: 1px solid red; &#125; .content&#123; display: flex; &#125; .sidebar &#123; flex: 2; border: 1px solid green; height: 500px; &#125; .mainbox&#123; flex: 8; border: 1px solid blue; height: 500px; &#125;&lt;/style&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;script src="./lib/vue-router-3.0.1.js"&gt;&lt;/script&gt; &lt;style&gt; html, body &#123; margin: 0; padding: 0; &#125; .header &#123; background-color: orange; height: 80px; &#125; h1 &#123; margin: 0; padding: 0; font-size: 16px; &#125; .container &#123; display: flex; height: 600px; &#125; .left &#123; background-color: lightgreen; flex: 2; &#125; .main &#123; background-color: lightpink; flex: 8; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class="container"&gt; &lt;router-view name="left"&gt;&lt;/router-view&gt; &lt;!-- 注意名称 方的是组件名称 --&gt; &lt;router-view name="main"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var header = &#123; template: '&lt;h1 class="header"&gt;Header头部区域&lt;/h1&gt;' &#125; var leftBox = &#123; template: '&lt;h1 class="left"&gt;Left侧边栏区域&lt;/h1&gt;' &#125; var mainBox = &#123; template: '&lt;h1 class="main"&gt;mainBox主体区域&lt;/h1&gt;' &#125; // 创建路由对象 var router = new VueRouter(&#123; routes: [ /* &#123; path: '/', component: header &#125;, &#123; path: '/left', component: leftBox &#125;, &#123; path: '/main', component: mainBox &#125; */ &#123; path: '/', components: &#123; // 一个路径挂在三个组件 default: header, //属性名称可以不加单引号 'left': leftBox, 'main': mainBox &#125; &#125; ] &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; watch属性(可用监听路由)考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 分析： --&gt; &lt;!-- 1. 我们要监听到 文本框数据的改变，这样才能知道 什么时候去拼接 出一个 fullname --&gt; &lt;!-- 2. 如何监听到 文本框的数据改变呢？？？ --&gt; &lt;input type="text" v-model="firstname" @keyup="getFullname"&gt; + &lt;input type="text" v-model="lastname" @keyup="getFullname"&gt; = &lt;input type="text" v-model="fullname"&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstname: '', lastname: '', fullname: '' &#125;, methods: &#123; getFullname() &#123; this.fullname = this.firstname + '-' + this.lastname &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 监听data中属性的改变： 123456789101112131415161718192021222324252627&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; + &lt;input type="text" v-model="lastName"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen', fullName: 'jack - chen' &#125;, methods: &#123;&#125;, watch: &#123; //如果是first-Name属性必须加'' 'first-Name' firstName: function (newVal, oldVal) &#123; // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + ' - ' + this.lastName; &#125;, lastName: function (newVal, oldVal) &#123; this.fullName = this.firstName + ' - ' + newVal; &#125; &#125; &#125;); &lt;/script&gt; 监听路由对象的改变： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;!-- 1. 导入包 --&gt; &lt;script src="./lib/vue-router-3.0.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;router-link to="/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;!-- 容器 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; // 2. 创建子组件 var login = &#123; template: '&lt;h3&gt;这是登录子组件，这个组件是 奔波霸 开发的。&lt;/h3&gt;' &#125; var register = &#123; template: '&lt;h3&gt;这是注册子组件，这个组件是 霸波奔 开发的。&lt;/h3&gt;' &#125; // 3. 创建一个路由对象 var router = new VueRouter(&#123; routes: [ // 路由规则数组 &#123; path: '/', redirect: '/login' &#125;, &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ], linkActiveClass: 'myactive' // 和激活相关的类 &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, // router: router router, watch: &#123; // this.$route.path '$route.path': function (newVal, oldVal) &#123; // console.log(newVal + ' --- ' + oldVal) if (newVal === '/login') &#123; console.log('欢迎进入登录页面') &#125; else if (newVal === '/register') &#123; console.log('欢迎进入注册页面') &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; computed计算属性的使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-model="firstname"&gt; + &lt;input type="text" v-model="middlename"&gt; + &lt;input type="text" v-model="lastname"&gt; = &lt;input type="text" v-model="fullname"&gt; &lt;p&gt;&#123;&#123; fullname &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; fullname &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; fullname &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstname: '', lastname: '', middlename: '' &#125;, methods: &#123;&#125;, computed: &#123; // 在 computed 中，可以定义一些 属性，这些属性，叫做 【计算属性】， 计算属性的，本质，就是 一个方法，只不过，我们在使用 这些计算属性的时候，是把 它们的 名称，直接当作 属性来使用的；并不会把 计算属性，当作方法去调用；// 注意1： 计算属性，在引用的时候，一定不要加 () 去调用，直接把它 当作 普通 属性去使用就好了；// 注意2： 只要 计算属性，这个 function 内部，所用到的 任何 data 中的数据发送了变化，就会 立即重新计算 这个 计算属性的值// 注意3： 计算属性的求值结果，会被缓存起来，方便下次直接使用； 如果 计算属性方法中，所以来的任何数据，都没有发生过变化，则，不会重新对 计算属性求值； 'fullname': function () &#123; console.log('ok') return this.firstname + '-' + this.middlename + '-' + this.lastname &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 默认只有getter的计算属性： 1234567891011121314151617181920212223&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; + &lt;input type="text" v-model="lastName"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123;&#125;, computed: &#123; fullName() &#123; return this.firstName + ' - ' + this.lastName; &#125; &#125; &#125;); &lt;/script&gt; 定义有getter和setter的计算属性： 123456789101112131415161718192021222324252627282930313233343536&lt;div id="app"&gt; &lt;input type="text" v-model="firstName"&gt; &lt;input type="text" v-model="lastName"&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type="button" value="修改fullName" @click="changeName"&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123; changeName() &#123; this.fullName = 'TOM - chen2'; &#125; &#125;, computed: &#123; fullName: &#123; get: function () &#123; return this.firstName + ' - ' + this.lastName; &#125;, set: function (newVal) &#123; var parts = newVal.split(' - '); this.firstName = parts[0]; this.lastName = parts[1]; &#125; &#125; &#125; &#125;); &lt;/script&gt; watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； nrm的安装使用作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 相关文件 URL中的hash（井号）]]></content>
      <categories>
        <category>前端框架</category>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE过滤器、自定义指令、生命周期]]></title>
    <url>%2F2019%2F06%2F08%2FVUE%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E6%8C%87%E4%BB%A4%E3%80%81vue-resource%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[学习VUE过滤器、自定义指令、生命周期、从接口获取数据 品牌管理案例功能点：添加新品牌 删除品牌 根据条件筛选品牌 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;!-- 引入bootstrap --&gt; &lt;link rel="stylesheet" href="./lib/bootstrap-3.3.7.css"&gt; &lt;!-- 需要用到Jquery吗？？？ --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- &#123;&#123;1+1&#125;&#125; --&gt; &lt;div class="panel panel-primary"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt;添加品牌&lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body form-inline"&gt; &lt;label&gt; Id: &lt;input type="text" class="form-control" v-model="id"&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;!--注意： @keyup.enter --&gt; &lt;input type="text" class="form-control" v-model="name" @keyup.enter="add"&gt; &lt;/label&gt; &lt;!-- 在Vue中，使用事件绑定机制，为元素指定处理函数的时候，如果加了小括号，就可以给函数传参了 --&gt; &lt;input type="button" value="添加" class="btn btn-primary" @click="add()"&gt; &lt;label&gt; 搜索名称关键字： &lt;!-- 注意： Vue中所有的指令，在调用的时候，都以 v- 开头 --&gt; &lt;input type="text" class="form-control" v-model="keywords" id="search" v-focus v-color="'green'"&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class="table table-bordered table-hover table-striped"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Ctime&lt;/th&gt; &lt;th&gt;Operation&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!-- 之前， v-for 中的数据，都是直接从 data 上的list中直接渲染过来的 --&gt; &lt;!-- 现在， 我们自定义了一个 search 方法，同时，把 所有的关键字，通过传参的形式，传递给了 search 方法 --&gt; &lt;!-- 在 search 方法内部，通过 执行 for 循环， 把所有符合 搜索关键字的数据，保存到 一个新数组中，返回 --&gt; &lt;tr v-for="item in search(keywords)" :key="item.id"&gt; &lt;td&gt;&#123;&#123; item.id &#125;&#125;&lt;/td&gt; &lt;td v-text="item.name"&gt;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.ctime | dateFormat() &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; // 全局的过滤器， 进行时间的格式化 // 所谓的全局过滤器，就是所有的VM实例都共享的 Vue.filter('dateFormat', function (dateStr, pattern = "") &#123; // 根据给定的时间字符串，得到特定的时间 var dt = new Date(dateStr) // yyyy-mm-dd var y = dt.getFullYear() var m = dt.getMonth() + 1 var d = dt.getDate() // return y + '-' + m + '-' + d if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; var hh = dt.getHours() var mm = dt.getMinutes() var ss = dt.getSeconds() return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125; &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; id: '', name: '', keywords: '', // 搜索的关键字 list: [ &#123; id: 1, name: '奔驰', ctime: new Date() &#125;, &#123; id: 2, name: '宝马', ctime: new Date() &#125; ] &#125;, methods: &#123; add() &#123; // 添加的方法 // 分析： // 1. 获取到 id 和 name ,直接从 data 上面获取 // 2. 组织出一个对象 // 3. 把这个对象，调用 数组的 相关方法，添加到 当前 data 上的 list 中 // 4. 注意：在Vue中，已经实现了数据的双向绑定，每当我们修改了 data 中的数据，Vue会默认监听到数据的改动，自动把最新的数据，应用到页面上； // 5. 当我们意识到上面的第四步的时候，就证明大家已经入门Vue了，我们更多的是在进行 VM中 Model 数据的操作，同时，在操作Model数据的时候，指定的业务逻辑操作； var car = &#123; id: this.id, name: this.name, ctime: new Date() &#125; this.list.push(car) this.id = this.name = '' &#125;, del(id) &#123; // 根据Id删除数据 // 分析： // 1. 如何根据Id，找到要删除这一项的索引 // 2. 如果找到索引了，直接调用 数组的 splice 方法 /* this.list.some((item, i) =&gt; &#123; if (item.id == id) &#123; this.list.splice(i, 1) // 在 数组的 some 方法中，如果 return true，就会立即终止这个数组的后续循环 return true; &#125; &#125;) */ var index = this.list.findIndex(item =&gt; &#123; if (item.id == id) &#123; return true; &#125; &#125;) // console.log(index) this.list.splice(index, 1) &#125;, search(keywords) &#123; // 根据关键字，进行数据的搜索 /* var newList = [] this.list.forEach(item =&gt; &#123; if (item.name.indexOf(keywords) != -1) &#123; newList.push(item) &#125; &#125;) return newList */ // 注意： forEach some filter findIndex 这些都属于数组的新方法， // 都会对数组中的每一项，进行遍历，执行相关的操作； return this.list.filter(item =&gt; &#123; // if(item.name.indexOf(keywords) != -1) // 注意 ： ES6中，为字符串提供了一个新方法，叫做 String.prototype.includes('要包含的字符串') // 如果包含，则返回 true ，否则返回 false // contain if (item.name.includes(keywords)) &#123; return item &#125; &#125;) // return newList &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 123456789101112131415&lt;tr v-for=&quot;item in list | filterBy searchName in &apos;name&apos;&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 123&lt;hr&gt; 输入筛选名称：&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot;&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 123456789101112131415&lt;tbody&gt; &lt;tr v-for=&quot;item in search(searchName)&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 1234567search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125; 调试工具vue-devtools的安装Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 123456789 // 过滤器的定义语法 // Vue.filter('过滤器的名称', function()&#123;&#125;) // 过滤器中的 function ，第一个参数，已经被规定死了，永远都是 过滤器 管道符前面 传递过来的数据 /* Vue.filter('过滤器的名称', function (data) &#123; return data + '123' &#125;) */&lt;!-- 过滤器调用时候的格式 &#123;&#123; name | 过滤器的名称 &#125;&#125; --&gt; 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123; msg | msgFormat('疯狂+1', '123') | test &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 定义一个 Vue 全局的过滤器，名字叫做 msgFormat Vue.filter('msgFormat', function (msg, arg, arg2) &#123; // 字符串的 replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则 return msg.replace(/单纯/g, arg + arg2) &#125;) Vue.filter('test', function (msg) &#123; return msg + '========' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人' &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt; 私有过滤器 HTML元素： 1&lt;td&gt;&#123;&#123;item.ctime | dataFormat('yyyy-mm-dd')&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 1234567891011121314151617181920212223242526272829303132333435363738filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = "") &#123; // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器 (所有的vm实例使用)123456789101112131415161718192021222324252627282930313233343536373839// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 12345678910111213141516171819202122232425262728293031323334353637383940// 如何自定义一个私有的过滤器（局部）var vm2 = new Vue(&#123; el: '#app2', data: &#123; dt: new Date() &#125;, methods: &#123;&#125;, filters: &#123; // 定义私有过滤器 过滤器有两个 条件 【过滤器名称 和 处理函数】 // 过滤器调用的时候，采用的是就近原则，如果私有过滤器和全局过滤器名称一致了，这时候 优先调用私有过滤器 dateFormat: function (dateStr, pattern = '') &#123; // 根据给定的时间字符串，得到特定的时间 var dt = new Date(dateStr) // yyyy-mm-dd var y = dt.getFullYear() var m = (dt.getMonth() + 1).toString().padStart(2, '0') var d = dt.getDate().toString().padStart(2, '0') if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; var hh = dt.getHours().toString().padStart(2, '0') var mm = dt.getMinutes().toString().padStart(2, '0') var ss = dt.getSeconds().toString().padStart(2, '0') return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125; ~~~~~~~` &#125; &#125; &#125;, directives: &#123; // 自定义私有指令 'fontweight': &#123; // 设置字体粗细的 bind: function (el, binding) &#123; el.style.fontWeight = binding.value &#125; &#125;, 'fontsize': function (el, binding) &#123; // 注意：这个 function 等同于 把 代码写到了 bind 和 update 中去 el.style.fontSize = parseInt(binding.value) + 'px' &#125; &#125;&#125;) 键盘修饰符、自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】1Vue.directive(&apos;on&apos;).keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 1Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 1&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt; 自定义指令全局和局部指令 （例子：获取焦点） 自定义全局和局部的 自定义指令： 123456789101112131415161718192021222324252627282930313233343536373839404142 // 自定义全局按键修饰符 Vue.config.keyCodes.f2 = 113// 使用 Vue.directive() 定义全局的指令 v-focus// 参数1 ： 指令的名称，注意，在定义的时候，指令的名称前面，不需要加 v- 前缀, // 但是： 在调用的时候，必须 在指令名称前 加上 v- 前缀来进行调用// 参数2： 是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作 Vue.directive('focus', &#123; bind: function (el) &#123; // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，只执行一次 // 注意： 在每个 函数中，第一个参数，永远是 el ，表示 被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象 // 在元素 刚绑定了指令的时候，还没有 插入到 DOM中去，这时候，调用 focus 方法没有作用 // 因为，一个元素，只有插入DOM之后，才能获取焦点 // el.focus() &#125;, inserted: function (el) &#123; // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 el.focus() // 和JS行为有关的操作，最好在 inserted 中去执行，放置 JS行为不生效 &#125;, updated: function (el) &#123; // 当VNode更新的时候，会执行 updated， 可能会触发多次 &#125; &#125;) // 自定义一个 设置字体颜色的 指令 Vue.directive('color', &#123; // 样式，只要通过指令绑定给了元素，不管这个元素有没有被插入到页面中去，这个元素肯定有了一个内联的样式 // 将来元素肯定会显示到页面中，这时候，浏览器的渲染引擎必然会解析样式，应用给这个元素 bind: function (el, binding) &#123; // el.style.color = 'red' // console.log(binding.name) // 和样式相关的操作，一般都可以在 bind 执行 // console.log(binding.value) // console.log(binding.expression) el.style.color = binding.value &#125; &#125;) 12345678910111213141516171819202122// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive('focus', &#123; inserted: function (el) &#123; // inserted 表示被绑定元素插入父节点时调用 el.focus(); &#125;&#125;);// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: &#123; color: &#123; // 为元素设置指定的字体颜色 bind(el, binding) &#123; el.style.color = binding.value;//获取指令绑定的值 &#125; &#125;, 'font-weight': function (el, binding2) &#123; // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; &#125; &#125; 自定义指令的使用方式： 1&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot; v-focus v-color=&quot;&apos;red&apos;&quot; v-font-weight=&quot;900&quot;&gt; Vue 1.x 中 自定义元素指令【已废弃】12345Vue.elementDirective(&apos;red-color&apos;, &#123; bind: function () &#123; this.el.style.color = &apos;red&apos;; &#125;&#125;); 使用方式： 1&lt;red-color&gt;1232&lt;/red-color&gt; vue实例的生命周期 生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'ok' &#125;, methods: &#123; show() &#123; console.log('执行了show方法') &#125; &#125;, beforeCreate() &#123; // 这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前，会执行它 // console.log(this.msg) // this.show() // 注意： 在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的 数据都还没有没初始化 &#125;, created() &#123; // 这是遇到的第二个生命周期函数 // console.log(this.msg) // this.show() // 在 created 中，data 和 methods 都已经被初始化好了！ // 如果要调用 methods 中的方法，或者操作 data 中的数据，最早，只能在 created 中操作 &#125;, beforeMount() &#123; // 这是遇到的第3个生命周期函数，表示 模板已经在内存中编辑完成了，但是尚未把 模板渲染到 页面中 // console.log(document.getElementById('h3').innerText) // 在 beforeMount 执行的时候，页面中的元素，还没有被真正替换过来，只是之前写的一些模板字符串 &#125;, mounted() &#123; // 这是遇到的第4个生命周期函数，表示，内存中的模板，已经真实的挂载到了页面中，用户可以看到渲染好的页面 // console.log(document.getElementById('h3').innerText)// 注意： mounted 是 实例创建期间的最后一个生命周期函数，当执行完 mounted 就表示，实例已经被完全创建好了，此时，如果没有其它操作的话，这个实例，就静静的 躺在我们的内存中，一动不动 &#125;, // 接下来的是运行中的两个事件 beforeUpdate() &#123; // 这时候，表示 我们的界面还没有被更新【数据被更新了吗？ 数据肯定被更新了】 /* console.log('界面上元素的内容：' + document.getElementById('h3').innerText) console.log('data 中的 msg 数据是：' + this.msg) */ // 得出结论： 当执行 beforeUpdate 的时候，页面中的显示的数据，还是旧的，此时 data 数据是最新的，页面尚未和 最新的数据保持同步 &#125;, updated() &#123; console.log('界面上元素的内容：' + document.getElementById('h3').innerText) console.log('data 中的 msg 数据是：' + this.msg) // updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的 &#125; &#125;); &lt;/script&gt; vue-resource 实现 get, post, jsonp请求除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的URL请求资源地址： get请求地址： http://vue.studyit.io/api/getlunbo post请求地址：http://vue.studyit.io/api/post jsonp请求地址：http://vue.studyit.io/api/jsonp JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 带大家通过 Node.js ，来手动实现一个JSONP的请求例子； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;!-- 注意：vue-resource 依赖于 Vue，所以先后顺序要注意 --&gt; &lt;!-- this.$http.jsonp --&gt; &lt;script src="./lib/vue-resource-1.3.4.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" value="get请求" @click="getInfo"&gt; &lt;input type="button" value="post请求" @click="postInfo"&gt; &lt;input type="button" value="jsonp请求" @click="jsonpInfo"&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getInfo() &#123; // 发起get请求 // 当发起get请求之后， 通过 .then 来设置成功的回调函数 this.$http.get('http://vue.studyit.io/api/getlunbo').then(function (result) &#123; // 通过 result.body 拿到服务器返回的成功的数据 console.log(result.body) &#125;) &#125;, postInfo() &#123; // 发起 post 请求 application/x-wwww-form-urlencoded // 手动发起的 Post 请求，默认没有表单格式，所以，有的服务器处理不了 // 通过 post 方法的第三个参数， &#123; emulateJSON: true &#125; 设置 提交的内容类型 为 普通表单数据格式 this.$http.post('http://vue.studyit.io/api/post', &#123;&#125;, &#123; emulateJSON: true &#125;).then(result =&gt; &#123; console.log(result.body) &#125;) &#125;, jsonpInfo() &#123; // 发起JSONP 请求 this.$http.jsonp('http://vue.studyit.io/api/jsonp').then(result =&gt; &#123; console.log(result.body) &#125;) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435const http = require('http');// 导入解析 URL 地址的核心模块const urlModule = require('url');const server = http.createServer();// 监听 服务器的 request 请求事件，处理每个请求server.on('request', (req, res) =&gt; &#123; const url = req.url; // 解析客户端请求的URL地址 var info = urlModule.parse(url, true); // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据 if (info.pathname === '/getjsonp') &#123; // 获取客户端指定的回调函数的名称 var cbName = info.query.callback; // 手动拼接要返回给客户端的数据对象 var data = &#123; name: 'zs', age: 22, gender: '男', hobby: ['吃饭', '睡觉', '运动'] &#125; // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法： var result = `$&#123;cbName&#125;($&#123;JSON.stringify(data)&#125;)`; // 将拼接好的方法的调用，返回给客户端去解析执行 res.end(result); &#125; else &#123; res.end('404'); &#125;&#125;);server.listen(3000, () =&gt; &#123; console.log('server running at http://127.0.0.1:3000');&#125;); vue-resource 的配置步骤： 直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 发送get请求： 12345getInfo() &#123; // get 方式获取数据 this.$http.get('http://127.0.0.1:8899/api/getlunbo').then(res =&gt; &#123; console.log(res.body); &#125;)&#125; 发送post请求： 12345678910postInfo() &#123; var url = 'http://127.0.0.1:8899/api/post'; // post 方法接收三个参数： // 参数1： 要请求的URL地址 // 参数2： 要发送的数据对象 // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded this.$http.post(url, &#123; name: 'zs' &#125;, &#123; emulateJSON: true &#125;).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 发送JSONP请求获取数据： 123456jsonpInfo() &#123; // JSONP形式从服务器获取数据 var url = 'http://127.0.0.1:8899/api/jsonp'; this.$http.jsonp(url).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 品牌管理改造123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133&lt;body&gt; &lt;div id="app"&gt; &lt;div class="panel panel-primary"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt;添加品牌&lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body form-inline"&gt; &lt;label&gt; Name: &lt;input type="text" v-model="name" class="form-control"&gt; &lt;/label&gt; &lt;input type="button" value="添加" @click="add" class="btn btn-primary"&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class="table table-bordered table-hover table-striped"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Ctime&lt;/th&gt; &lt;th&gt;Operation&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for="item in list" :key="item.id"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; // 如果我们通过全局配置了，请求的数据接口 根域名，则 ，在每次单独发起 http 请求的时候，请求的 url 路径，应该以相对路径开头，前面不能带 / ，否则 不会启用根路径做拼接； Vue.http.options.root = 'http://vue.studyit.io/'; // 全局启用 emulateJSON 选项 Vue.http.options.emulateJSON = true; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; name: '', list: [ // 存放所有品牌列表的数组 ] &#125;, created() &#123; // 当 vm 实例 的 data 和 methods 初始化完毕后，vm实例会自动执行created 这个生命周期函数 this.getAllList() &#125;, methods: &#123; getAllList() &#123; // 获取所有的品牌列表 // 1. 由于已经导入了 Vue-resource这个包，所以 ，可以直接通过 this.$http 来发起数据请求 // 2. 根据接口API文档，知道，获取列表的时候，应该发起一个 get 请求 // 3. this.$http.get('url').then(function(result)&#123;&#125;) // 4. 当通过 then 指定回调函数之后，在回调函数中，可以拿到数据服务器返回的 result // 5. 先判断 result.status 是否等于0，如果等于0，就成功了，可以 把 result.message 赋值给 this.list ; 如果不等于0，可以弹框提醒，获取数据失败！（返回的是对象，有status属性和message属性） this.$http.get('api/getprodlist').then(result =&gt; &#123; // 注意： 通过 $http 获取到的数据，都在 result.body 中放着 var result = result.body if (result.status === 0) &#123; // 成功了 this.list = result.message &#125; else &#123; // 失败了 alert('获取数据失败！') &#125; &#125;) &#125;, add() &#123; // 添加品牌列表到后台服务器 // 分析： // 1. 听过查看 数据API接口，发现，要发送一个 Post 请求， this.$http.post // 2. this.$http.post() 中接收三个参数： // 2.1 第一个参数： 要请求的URL地址 // 2.2 第二个参数： 要提交给服务器的数据 ，要以对象形式提交给服务器 &#123; name: this.name &#125;// 2.3 第三个参数： 是一个配置对象，要以哪种表单数据类型提交过去， &#123; emulateJSON: true &#125;, 以普通表单格式，将数据提交给服务器 application/x-www-form-urlencoded // 3. 在 post 方法中，使用 .then 来设置成功的回调函数，如果想要拿到成功的结果，需要 result.body /* this.$http.post('api/addproduct', &#123; name: this.name &#125;, &#123; emulateJSON: true &#125;).then(result =&gt; &#123; if (result.body.status === 0) &#123; // 成功了！ // 添加完成后，只需要手动，再调用一下 getAllList 就能刷新品牌列表了 this.getAllList() // 清空 name this.name = '' &#125; else &#123; // 失败了 alert('添加失败！') &#125; &#125;) */ this.$http.post('api/addproduct', &#123; name: this.name &#125;).then(result =&gt; &#123; if (result.body.status === 0) &#123; // 成功了！ // 添加完成后，只需要手动，再调用一下 getAllList 就能刷新品牌列表了 this.getAllList() // 清空 name this.name = '' &#125; else &#123; // 失败了 alert('添加失败！') &#125; &#125;) &#125;, del(id) &#123; // 删除品牌 this.$http.get('api/delproduct/' + id).then(result =&gt; &#123; if (result.body.status === 0) &#123; // 删除成功 this.getAllList() &#125; else &#123; alert('删除失败！') &#125; &#125;) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>前端框架</category>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE基础指令和绑定使用]]></title>
    <url>%2F2019%2F06%2F05%2FVUE%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4%E5%92%8C%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[认识VUE 什么是Vue.js Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责MVC中的V这一层；主要工作就是和界面打交道，来制作前端页面效果； 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 企业中，使用框架，能够提高开发的效率； 提高开发效率的发展历程：原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心DOM是如何渲染的了】） 在Vue中，一个核心的概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑； 增强自己就业时候的竞争力 人无我有，人有我优 你平时不忙的时候，都在干嘛？ 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 ​ node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从Jquery 切换到 Zepto 从 EJS 切换到 art-templateNode（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了MVC还要有MVVM Vue.js 代码结构和插值表达式1234567891011121314151617181920&lt;body&gt; &lt;!-- 将来 new 的Vue实例，会控制这个 元素中的所有内容 --&gt; &lt;!-- Vue 实例所控制的这个元素区域，就是我们的 V --&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 2. 创建一个Vue的实例 // 当我们导入包之后，在浏览器的内存中，就多了一个 Vue 构造函数 // 注意：我们 new 出来的这个 vm 对象，就是我们 MVVM中的 VM调度者 var vm = new Vue(&#123; el: '#app', // 表示，当前我们 new 的这个 Vue 实例，要控制页面上的哪个区域 // 这里的 data 就是 MVVM中的 M，专门用来保存 每个页面的数据的 data: &#123; // data 属性中，存放的是 el 中要用到的数据 msg: '欢迎学习Vue' // 通过 Vue 提供的指令，很方便的就能把数据渲染到页面上，程序员不再手动操作DOM元素了【前端的Vue之类的框架，不提倡我们去手动操作DOM元素了】 &#125; &#125;) &lt;/script&gt;&lt;/body&gt; VUE基本绑定指令v-cloak v-text和v-html（文本）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 解决闪烁问题 */ [v-cloak] &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 使用 v-cloak 能够解决 插值表达式闪烁的问题 (网速慢的时候，js还没加载完毕，没替换)--&gt; &lt;p v-cloak&gt;++++++++ &#123;&#123; msg &#125;&#125; ----------&lt;/p&gt; &lt;h4 v-text="msg"&gt;==================&lt;/h4&gt; &lt;!-- v-cloak v-text 的区别 --&gt; &lt;!-- 默认 v-text 是没有闪烁问题的 --&gt; &lt;!-- v-text会覆盖元素中原本的内容，但是 插值表达式 只会替换自己的这个占位符，不会把 整个元素的内容清空 --&gt; &lt;div&gt;&#123;&#123;msg2&#125;&#125;&lt;/div&gt; &lt;!-- 普通文本输出 --&gt; &lt;div v-text="msg2"&gt;&lt;/div&gt; &lt;div v-html="msg2"&gt;1212112&lt;/div&gt; &lt;!-- html输出 --&gt; &lt;!-- v-bind: 是 Vue中，提供的用于绑定属性的指令 --&gt; &lt;input type="button" value="按钮" v-bind:title="mytitle + '123'"&gt; &lt;!-- 注意： v-bind: 指令可以被简写为 :要绑定的属性 --&gt; &lt;!-- v-bind 中，可以写合法的JS表达式 --&gt; &lt;!-- Vue 中提供了 v-on: 事件绑定机制 --&gt; &lt;!-- &lt;input type="button" value="按钮" :title="mytitle + '123'" v-on:click="alert('hello')"&gt; --&gt; &lt;!-- 会把alert当成一个变量去vue对象中找 出错！！！ --&gt; &lt;input type="button" value="按钮" @click="show"&gt; &lt;/div&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123', msg2: '&lt;h1&gt;哈哈，我是一个大大的H1， 我大，我骄傲&lt;/h1&gt;', mytitle: '这是一个自己定义的title' &#125;, methods: &#123; // 这个 methods属性中定义了当前Vue实例所有可用的方法 show: function () &#123; alert('Hello'); &#125; &#125; &#125;) /* document.getElementById('btn').onclick = function()&#123; alert('Hello') &#125; */ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 1. 如何定义一个基本的Vue代码结构 --&gt;&lt;!-- 2. 插值表达式 和 v-text --&gt;&lt;!-- 3. v-cloak --&gt;&lt;!-- 4. v-html --&gt;&lt;!-- 5. v-bind Vue提供的属性绑定机制 缩写是 : --&gt;&lt;!-- 6. v-on Vue提供的事件绑定机制 缩写是 @ --&gt; v-bind的三种用法（绑定属性） 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot; v-on之跑马灯效果(绑定事件)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 1. 导入Vue包 --&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 2. 创建一个要控制的区域 --&gt; &lt;div id="app"&gt; &lt;input type="button" value="浪起来" @click="lang"&gt; &lt;input type="button" value="低调" @click="stop"&gt; &lt;h4&gt;&#123;&#123; msg &#125;&#125;&lt;/h4&gt; &lt;/div&gt; &lt;script&gt; // 注意：在 VM实例中，如果想要获取 data 上的数据，或者 想要调用 methods 中的 方法，必须通过 this.数据属性名 或 this.方法名 来进行访问，这里的this，就表示 我们 new 出来的 VM 实例对象 var vm = new Vue(&#123; el: '#app', data: &#123; msg: '猥琐发育，别浪~~！', intervalId: null // 在data上定义 定时器Id &#125;, methods: &#123; //ES6写法 自动把方法名映射为属性名 lang() &#123; // console.log(this.msg) // 获取到头的第一个字符 // this if (this.intervalId != null) return; this.intervalId = setInterval(() =&gt; &#123; var start = this.msg.substring(0, 1) // 获取到 后面的所有字符 var end = this.msg.substring(1) // 重新拼接得到新的字符串，并赋值给 this.msg this.msg = end + start &#125;, 400) // 注意： VM实例，会监听自己身上 data 中所有数据的改变，只要数据一发生变化，就会自动把 最新的数据，从data 上同步到页面中去；【好处：程序员只需要关心数据，不需要考虑如何重新渲染DOM页面】 &#125;, stop() &#123; // 停止定时器 clearInterval(this.intervalId) // 每当清除了定时器之后，需要重新把 intervalId 置为 null this.intervalId = null; &#125; &#125; &#125;) // 分析： // 1. 给 【浪起来】 按钮，绑定一个点击事件 v-on @ // 2. 在按钮的事件处理函数中，写相关的业务逻辑代码：拿到 msg 字符串，然后 调用 字符串的 substring 来进行字符串的截取操作，把 第一个字符截取出来，放到最后一个位置即可； // 3. 为了实现点击下按钮，自动截取的功能，需要把 2 步骤中的代码，放到一个定时器中去； &lt;/script&gt;&lt;/body&gt; v-on的缩写和事件修饰符 .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调—只负责自己 别人冒泡的 不会阻止传递 .once 事件只触发一次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;style&gt; .inner &#123; height: 150px; background-color: darkcyan; &#125; .outer &#123; padding: 40px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 使用 .stop 阻止冒泡 --&gt; &lt;div class="inner" @click="div1Handler"&gt; &lt;input type="button" value="戳他" @click.stop="btnHandler"&gt; &lt;/div&gt; &lt;!-- 使用 .prevent 阻止默认行为 --&gt; &lt;a href="http://www.baidu.com" @click.prevent="linkClick"&gt;有问题，先去百度&lt;/a&gt; &lt;!-- 使用 .capture 实现捕获触发事件的机制 --&gt; &lt;div class="inner" @click.capture="div1Handler"&gt; &lt;input type="button" value="戳他" @click="btnHandler"&gt; &lt;/div&gt; &lt;!-- 使用 .self 实现只有点击当前元素时候，才会触发事件处理函数 --&gt; &lt;div class="inner" @click.self="div1Handler"&gt; &lt;input type="button" value="戳他" @click="btnHandler"&gt; &lt;/div&gt; &lt;!-- 使用 .once 只触发一次事件处理函数 --&gt; &lt;a href="http://www.baidu.com" @click.prevent.once="linkClick"&gt;有问题，先去百度&lt;/a&gt; &lt;!-- 演示： .stop 和 .self 的区别 --&gt; &lt;div class="outer" @click="div2Handler"&gt; &lt;div class="inner" @click="div1Handler"&gt; &lt;input type="button" value="戳他" @click.stop="btnHandler"&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- .self 只会阻止自己身上冒泡行为的触发，并不会真正阻止 冒泡的行为 --&gt; &lt;div class="outer" @click="div2Handler"&gt; &lt;div class="inner" @click.self="div1Handler"&gt; &lt;input type="button" value="戳他" @click="btnHandler"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; div1Handler() &#123; console.log('这是触发了 inner div 的点击事件') &#125;, btnHandler() &#123; console.log('这是触发了 btn 按钮 的点击事件') &#125;, linkClick() &#123; console.log('触发了连接的点击事件') &#125;, div2Handler() &#123; console.log('这是触发了 outer div 的点击事件') &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; v-model和双向数据绑定1234567891011121314151617181920212223&lt;div id="app"&gt; &lt;h4&gt;&#123;&#123; msg &#125;&#125;&lt;/h4&gt; &lt;!-- v-bind 只能实现数据的单向绑定，从 M 自动绑定到 V， 无法实现数据的双向绑定 --&gt; &lt;input type="text" v-bind:value="msg" style="width:100%;"&gt; &lt;!-- 使用 v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定 --&gt; &lt;!-- 注意： v-model 只能运用在 表单元素中 --&gt; &lt;!-- input(radio, text, address, email....) select checkbox textarea --&gt; &lt;input type="text" style="width:100%;" v-model="msg"&gt;&lt;/div&gt;&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '大家都是好学生，爱敲代码，爱学习，爱思考，简直是完美，没瑕疵！' &#125;, methods: &#123; &#125; &#125;);&lt;/script&gt; 简易计算器案例 HTML 代码结构 12345678910111213141516&lt;div id="app"&gt; &lt;input type="text" v-model="n1"&gt; &lt;select v-model="opt"&gt; &lt;option value="+"&gt;+&lt;/option&gt; &lt;option value="-"&gt;-&lt;/option&gt; &lt;option value="*"&gt;*&lt;/option&gt; &lt;option value="/"&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input type="text" v-model="n2"&gt; &lt;input type="button" value="=" @click="calc"&gt; &lt;input type="text" v-model="result"&gt;&lt;/div&gt; Vue实例代码： 123456789101112131415161718192021222324252627282930313233343536&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; n1: 0, n2: 0, result: 0, opt: '+' &#125;, methods: &#123; calc() &#123; // 计算器算数的方法 // 逻辑： /* switch (this.opt) &#123; case '+': this.result = parseInt(this.n1) + parseInt(this.n2) break; case '-': this.result = parseInt(this.n1) - parseInt(this.n2) break; case '*': this.result = parseInt(this.n1) * parseInt(this.n2) break; case '/': this.result = parseInt(this.n1) / parseInt(this.n2) break; &#125; */ // 注意：这是投机取巧的方式，正式开发中，尽量少用 var codeStr = 'parseInt(this.n1) ' + this.opt + ' parseInt(this.n2)' this.result = eval(codeStr) &#125; &#125; &#125;);&lt;/script&gt; Vue指令之v-for和key属性 迭代数组 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123;list[0]&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;list[1]&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;list[2]&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;list[3]&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;list[4]&#125;&#125;&lt;/p&gt; &lt;p v-for="(item, i) in list"&gt;索引值：&#123;&#123;i&#125;&#125; --- 每一项：&#123;&#123;item&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; list: [1, 2, 3, 4, 5, 6] &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021&lt;body&gt; &lt;div id="app"&gt; &lt;p v-for="(user, i) in list"&gt;Id：&#123;&#123; user.id &#125;&#125; --- 名字：&#123;&#123; user.name &#125;&#125; --- 索引：&#123;&#123;i&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; list: [ &#123; id: 1, name: 'zs1' &#125;, &#123; id: 2, name: 'zs2' &#125;, &#123; id: 3, name: 'zs3' &#125;, &#123; id: 4, name: 'zs4' &#125; ] &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt; 迭代对象中的属性 123&lt;!-- 循环遍历对象身上的属性 --&gt; &lt;div v-for=&quot;(val, key, i) in userInfo&quot;&gt;&#123;&#123;val&#125;&#125; --- &#123;&#123;key&#125;&#125; --- &#123;&#123;i&#125;&#125;&lt;/div&gt; 123456789101112131415161718192021&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 注意：在遍历对象身上的键值对的时候， 除了 有 val key ,在第三个位置还有 一个 索引 --&gt; &lt;p v-for="(val, key, i) in user"&gt;值是： &#123;&#123; val &#125;&#125; --- 键是： &#123;&#123;key&#125;&#125; -- 索引： &#123;&#123;i&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; user: &#123; id: 1, name: '托尼·屎大颗', gender: '男' &#125; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt; 迭代数字 1&lt;p v-for=&quot;i in 10&quot;&gt;这是第 &#123;&#123;i&#125;&#125; 个P标签&lt;/p&gt; 12345678910111213141516&lt;body&gt; &lt;div id="app"&gt; &lt;!-- in 后面我们放过 普通数组，对象数组，对象， 还可以放数字 --&gt; &lt;!-- 注意：如果使用 v-for 迭代数字的话，前面的 count 值从 1 开始 --&gt; &lt;p v-for="count in 10"&gt;这是第 &#123;&#123; count &#125;&#125; 次循环&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;body&gt; &lt;div id="app"&gt; &lt;div&gt; &lt;label&gt;Id: &lt;input type="text" v-model="id"&gt; &lt;/label&gt; &lt;label&gt;Name: &lt;input type="text" v-model="name"&gt; &lt;/label&gt; &lt;input type="button" value="添加" @click="add"&gt; &lt;/div&gt; &lt;!-- 注意： v-for 循环的时候，key 属性只能使用 number获取string --&gt; &lt;!-- 注意： key 在使用的时候，必须使用 v-bind 属性绑定的形式，指定 key 的值 --&gt; &lt;!-- 在组件中，使用v-for循环的时候，或者在一些特殊情况中，如果 v-for 有问题，必须 在使用 v-for 的同时，指定 唯一的 字符串/数字 类型 :key 值 --&gt; &lt;p v-for="item in list" :key="item.id"&gt; &lt;input type="checkbox"&gt;&#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125; &lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; id: '', name: '', list: [ &#123; id: 1, name: '李斯' &#125;, &#123; id: 2, name: '嬴政' &#125;, &#123; id: 3, name: '赵高' &#125;, &#123; id: 4, name: '韩非' &#125;, &#123; id: 5, name: '荀子' &#125; ] &#125;, methods: &#123; add() &#123; // 添加方法 this.list.unshift(&#123; id: this.id, name: this.name &#125;) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; Vue指令之v-if和v-show 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。 12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;div id="app"&gt; &lt;!-- &lt;input type="button" value="toggle" @click="toggle"&gt; --&gt; &lt;input type="button" value="toggle" @click="flag=!flag"&gt; &lt;!-- v-if 的特点：每次都会重新删除或创建元素 --&gt; &lt;!-- v-show 的特点： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式 --&gt; &lt;!-- v-if 有较高的切换性能消耗 --&gt; &lt;!-- v-show 有较高的初始渲染消耗 --&gt; &lt;!-- 如果元素涉及到频繁的切换，最好不要使用 v-if, 而是推荐使用 v-show --&gt; &lt;!-- 如果元素可能永远也不会被显示出来被用户看到，则推荐使用 v-if --&gt; &lt;h3 v-if="flag"&gt;这是用v-if控制的元素&lt;/h3&gt; &lt;h3 v-show="flag"&gt;这是用v-show控制的元素&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123; /* toggle() &#123; this.flag = !this.flag &#125; */ &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 在Vue中使用样式（:class :style）使用class样式 数组 class本来就是属性 通过vue属性绑定 不方便 1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中使用三元表达式—-isactive当做vue 对象属性去寻找–改造后使用类 1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, isactive?&apos;active&apos;:&apos;&apos;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中嵌套对象 1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, &#123;&apos;active&apos;: isactive&#125;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 直接使用对象—对象的属性是类名 所以可以不用加引号 1&lt;h1 :class=&quot;&#123;red:true, italic:true, active:true, thin:true&#125;&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;style&gt; .red &#123; color: red; &#125; .thin &#123; font-weight: 200; &#125; .italic &#123; font-style: italic; &#125; .active &#123; letter-spacing: 0.5em; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- &lt;h1 class="red thin"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; --&gt; &lt;!-- 第一种使用方式，直接传递一个数组，注意： 这里的 class 需要使用 v-bind 做数据绑定 --&gt; &lt;h1 :class="['thin', 'italic']"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; &lt;!-- 在数组中使用三元表达式 不写''会去vue对象中找flag--&gt; &lt;h1 :class="['thin', 'italic', flag?'active':'']"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; &lt;!-- 在数组中使用 对象来代替三元表达式，提高代码的可读性 --&gt; &lt;h1 :class="['thin', 'italic', &#123;'active':flag&#125; ]"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; &lt;!-- 在为 class 使用 v-bind 绑定 对象的时候，对象的属性是类名，由于 对象的属性可带引号，也可不带引号，所以 这里我没写引号； 属性的值 是一个标识符 --&gt; &lt;h1 :class="classObj"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: true, classObj: &#123; red: true, thin: true, italic: false, active: false &#125; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用内联样式(:style) 直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style=&quot;&#123;color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;&#125;&quot;&gt;这是一个善良的H1&lt;/h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 在data上定义样式： 123data: &#123; h1StyleObj: &#123; color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;, &apos;font-weight&apos;: &apos;200&apos; &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style=&quot;h1StyleObj&quot;&gt;这是一个善良的H1&lt;/h1&gt; 在 :style 中通过数组，引用多个 data 上的样式对象 在data上定义样式： 1234data: &#123; h1StyleObj: &#123; color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;, &apos;font-weight&apos;: &apos;200&apos; &#125;, h1StyleObj2: &#123; fontStyle: &apos;italic&apos; &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style=&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是一个善良的H1&lt;/h1&gt; 1234567891011121314151617181920&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 对象就是无序键值对的集合 --&gt; &lt;h1 :style="styleObj1"&gt;这是一个h1&lt;/h1&gt; &lt;h1 :style="[ styleObj1, styleObj2 ]"&gt;这是一个h1&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; styleObj1: &#123; color: 'red', 'font-weight': 200 &#125;, styleObj2: &#123; 'font-style': 'italic' &#125; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt; 小结1234567891011121314151617&lt;!-- 1. MVC 和 MVVM 的区别 --&gt;&lt;!-- 2. 学习了Vue中最基本代码的结构 --&gt;&lt;!-- 3. 插值表达式 v-cloak v-text v-html v-bind（缩写是:） v-on（缩写是@） v-model v-for v-if v-show --&gt;&lt;!-- 4. 事件修饰符 ： .stop .prevent .capture .self .once --&gt;&lt;!-- 5. el 指定要控制的区域 data 是个对象，指定了控制的区域内要用到的数据 methods 虽然带个s后缀，但是是个对象，这里可以自定义了方法 --&gt;&lt;!-- 6. 在 VM 实例中，如果要访问 data 上的数据，或者要访问 methods 中的方法， 必须带 this --&gt;&lt;!-- 7. 在 v-for 要会使用 key 属性 （只接受 string / number） --&gt;&lt;!-- 8. v-model 只能应用于表单元素 --&gt;&lt;!-- 9. 在vue中绑定样式两种方式 v-bind:class v-bind:style --&gt;]]></content>
      <categories>
        <category>前端框架</category>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.net core 安全]]></title>
    <url>%2F2019%2F06%2F01%2FAsp.net%20core%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[asp.net core Web安全概述 Principal和Identity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Program &#123; static void Main(string[] args) &#123; SetupPrincipal(); ShowPrincipalInfo(); QueryScore(); try &#123; InputScore(); ModifyScore(); &#125; catch (Exception ex) &#123; Console.WriteLine(ex); &#125; Console.ReadKey(); &#125; private static void SetupPrincipal() &#123; //写代码验证用户传入的凭证（如用户名、密码等）是否有效 //有效的话，就可以创建Identity var id = new GenericIdentity("JinXuLiang"); //JinXuLiang拥有两个角色 var roles = new string[] &#123; "Student", "Teacher" &#125;; //给用户以合适的身份，以便授权访问特定的资源 var teacher = new GenericPrincipal(id, roles); //设定线程所使用的用户身份 Thread.CurrentPrincipal = teacher; //张三是一个学生 var student = new GenericPrincipal( new GenericIdentity("张三"), new string[] &#123; "Student" &#125;); Thread.CurrentPrincipal = student; &#125; /// &lt;summary&gt; /// 显示Principal的基本信息 /// &lt;/summary&gt; private static void ShowPrincipalInfo() &#123; var p = Thread.CurrentPrincipal; SecurityHelper.PrintIIdentityInfo(p.Identity); &#125; public static void QueryScore() &#123; Console.WriteLine("所有人都可以查询考试成绩"); &#125; /// &lt;summary&gt; /// 只有教师才能输入成绩（使用代码进行验证） /// &lt;/summary&gt; public static void InputScore() &#123; new PrincipalPermission(null, "Teacher").Demand(); Console.WriteLine("只有教师才能输入考试成绩"); &#125; /// &lt;summary&gt; /// 只有教师才能修改成绩 /// &lt;/summary&gt; [PrincipalPermission(SecurityAction.Demand, Role = "Teacher")] public static void ModifyScore() &#123; Console.WriteLine("只有教师才能修改考试成绩"); &#125; &#125; 123456789101112public static class SecurityHelper &#123; public static void PrintIIdentityInfo(IIdentity identity) &#123; if (identity == null) &#123; return; &#125; string authenticationType=string.IsNullOrEmpty(identity.AuthenticationType)?"未指定":identity.AuthenticationType; Console.WriteLine($"AuthenticationType:&#123;authenticationType&#125;, Name:&#123;identity.Name&#125;,IsAuthenticated:&#123;identity.IsAuthenticated&#125;"); &#125; &#125; Claims 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105namespace UseClaim&#123; class Program &#123; static void Main(string[] args) &#123; UsePrincipal(); //useCustomIdentity(); Console.ReadKey(true); &#125; private static ClaimsPrincipal SetupPrincipal() &#123; //在创建Claim时，除了直接指定字符串作为Key，也可以直接使用ClaimTypes所定义的一大堆常量 //这些常量都是诸如“http://schemas.xmlsoap.org/ws/2009/09/identity/claims/actor”这样的字符串 //有好多…… var claims = new List&lt;Claim&gt; &#123; new Claim("name","jxl"), new Claim("Email","jinxuliang@bit.edu.cn"), new Claim("Role","Admin"), //如果有多个角色，则声明多条Claim new Claim("Role","Teacher") &#125;; //ClaimsIdentity一旦创建之后，不能修改。 var id = new ClaimsIdentity(claims, authenticationType: "console App", //不指明此参数的话，则id.IsAuthenticated一定返回false nameType: "Name", //指明Identity.Name从哪个Claim中取，不区分大小写 roleType: "role" //指明Identity.IsInRole从检查哪些名字的Claim，不区分大小写 ); //前面定义好了两个Role，如果返回ClaimsPrincipal，则角色无法再加新的，就前面指定的了 // return new ClaimsPrincipal(id); //注意：GenericPrincipal是ClaimsPrincipal()的子类，在实例化它时，可以再给Principle //添加角色，此处添加的角色，将直接影响到IsInRole()方法的返回值 //本例中，当前用户有4个角色了 //添加的角色，将放在GenericPrincipal的Claims集合中，但它所包容的ClaimsIdentity中的Claims集合不会更新 //简单地说，GenericPrincipal的Claims集合实际上是复制第一个ClaimsIdentity中的Claims集合 //再加上构造函数中新增加的Role而完成的。 return new GenericPrincipal(id, new string[] &#123; "Role1", "Role2" &#125;); &#125; private static void UsePrincipal() &#123; Thread.CurrentPrincipal = SetupPrincipal(); //在实际开发中，我们可以使用这句直接获取当前线程的CurrentPrincipal ClaimsPrincipal p = ClaimsPrincipal.Current; //使用ClaimsPrincipal后，其Identity实际上引用的是它的Identities集合中的第一个成员 Console.WriteLine($"ClaimsPrincipal的Identity属性引用的是它的Identities集合中的第一个成员？&#123;p.Identity == p.Identities.ElementAt(0)&#125;"); Console.WriteLine($"本Principal的primary indentity名字：&#123;p.Identity.Name&#125;,IsAuthenticated:&#123;p.Identity.IsAuthenticated&#125;"); Console.WriteLine($"&#123;p.GetType()&#125;属于角色Admin？&#123;p.IsInRole("Admin")&#125;"); Console.WriteLine($"&#123;p.GetType()&#125;属于角色Role1？&#123;p.IsInRole("Role1")&#125;"); //查询特定的Claims值 var email = p.FindFirst("Email").Value; Console.WriteLine($"电子邮件：&#123;email&#125;"); Console.WriteLine(); PrintClaimsPrincipalInfo(p); &#125; /// &lt;summary&gt; /// 输出指定Principle的所有Claims /// &lt;/summary&gt; /// &lt;param name="p"&gt;&lt;/param&gt; private static void PrintClaimsPrincipalInfo(ClaimsPrincipal p) &#123; Console.WriteLine($"Principal“&#123;p.Identity.Name&#125;”包容的所有Claim："); foreach (var claim in p.Claims) &#123; Console.WriteLine("Type:&#123;0&#125;\n,Value:&#123;1&#125;\n,ValueType:&#123;2&#125;\n,Issuer:&#123;3&#125;\n,OriginalIssuer:&#123;4&#125;\n,Subject:&#123;5&#125;\n", claim.Type, claim.Value, claim.ValueType, claim.Issuer, claim.OriginalIssuer, claim.Subject); Console.WriteLine("-------------------------"); &#125; &#125; static void useCustomIdentity() &#123; var id = new MyCustomIdentity("JinXuLiang","MyCompany",30, "BeiJin Hai Dian"); Thread.CurrentPrincipal = new GenericPrincipal(id,new String[]&#123;"Admin"&#125;); ClaimsPrincipal cp = ClaimsPrincipal.Current; MyCustomIdentity my = cp.Identity as MyCustomIdentity; Console.WriteLine($"&#123;my.Name&#125;属于角色Admin？&#123;cp.IsInRole("Admin")&#125;"); Console.WriteLine($"认证类型：&#123;my.AuthenticationType&#125;,IsAuthenticated=&#123;my.IsAuthenticated&#125;"); Console.WriteLine($"地址：&#123;my.Address&#125;"); Console.WriteLine($"年纪：&#123;my.Age&#125;"); Console.WriteLine(); PrintClaimsPrincipalInfo(cp); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839namespace UseClaim&#123; /// &lt;summary&gt; /// 可以基于.NET基类库的ClaimsIdentity，定制自己的Identity /// 其中封装一些新的属性,其值其实是保存在Claims中的， /// 自定义Identity的好处就在于它是强类型的，可以通过特定属性直接提取相应的信息 /// 而不需要先Find，再进行类型转换 /// &lt;/summary&gt; public class MyCustomIdentity:ClaimsIdentity &#123; // 注意：authenticationType比较特殊，此值未设定时，则identity.IsAuthenticated()一定返回false // 而此属性只能在构建时赋值 public MyCustomIdentity(string name, string authenticationType, int age, string address) :base(authenticationType) &#123; // name比较关键，构建时，应该指定Key为ClaimTypes.Name AddClaim(new Claim(ClaimTypes.Name, name)); AddClaim(new Claim("Age", age.ToString())); AddClaim(new Claim("Address", address)); &#125; public int Age &#123; get &#123; return Convert.ToInt32(FindFirst("Age").Value); &#125; &#125; public string Address &#123; get &#123; return FindFirst("Address").Value; &#125; &#125; &#125;&#125; 身份认证 授权 单页面应用中的授权]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>asp.net core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[asp.net core技术精要下]]></title>
    <url>%2F2019%2F05%2F25%2Fasp.net-core%E6%8A%80%E6%9C%AF%E7%B2%BE%E8%A6%81%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[asp.net core 服务端代码信息交换方式 Action to View ViewModel 模型绑定机制 Get方式通过查询字符串传送信息 Post方式传送信息 1234567891011121314151617181920212223242526272829303132333435363738@model InformationExchange.MyViewModel @&#123; ViewBag.Title = "Calcute"; &#125; &lt;h2&gt;Get And Post&lt;/h2&gt; @using (Html.BeginForm()) &#123; @Html.ValidationSummary(true) &lt;fieldset&gt; &lt;legend&gt;输入相关信息&lt;/legend&gt; &lt;div&gt; @Html.LabelFor(model =&gt; model.Value) &lt;/div&gt; &lt;div&gt; @Html.EditorFor(model =&gt; model.Value) &lt;/div&gt; &lt;div&gt; @Html.LabelFor(model =&gt; model.Information) &lt;/div&gt; &lt;div&gt; @Html.EditorFor(model =&gt; model.Information) &lt;/div&gt; &lt;p&gt; &lt;br /&gt; &lt;input type="submit" value="提交" /&gt; &lt;/p&gt; &lt;/fieldset&gt; &#125; &lt;div&gt; @Html.ActionLink("返回", "Index") &lt;/div&gt; Action To Action 数据验证 数据验证的两大类型 数据校验的两大场景 MVC Controller中的数据验证 Web API控制器中的数据验证 REST基础 REST是一种架构风格 具体设计 版本问题解决 CRUD AutoMapper 纯MVC实现的CRUD REST风格的CRUD 集成JavaScript管理前端框架 Web服务端代码与JavaScript代码的互动]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>asp.net core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[asp.net core技术精要上]]></title>
    <url>%2F2019%2F05%2F20%2Fasp.net-core%E6%8A%80%E6%9C%AF%E7%B2%BE%E8%A6%81%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[asp.net core Web API与移动互联应用开发Web API 与 MVC的不同使用场景 与Web API的初次见面 ASP.NET core 起航 控制器与Action 了解Controller的生存期 Controller中的静态成员 MVC网页中的线程 访问MVC控制器的URL 查询字符串填充Action方法的参数 视图的位置约定与Razor引擎 ASP.NET core管线基础管线基础 配置管线的两个主要步骤 构建处理管线演练 Middleware辨析 使用独立的类实现中间件 支持配置的中间件 处理管线的“短路” 在中间件中传送信息 依赖注入DIP原则与IoC容器 IoC容器实例：Ninject ASP.NET core中的依赖注入 依赖注入对象的生命周期管理 路由系统 处理静态资源（文件） 内容根文件夹 Web根文件夹 让项目支持静态文件访问 访问放在其他位置的静态文件 启用目录浏览 浏览特定的文件夹中的文件 “一统天下”的UseFileServer 处理动态资源路由系统 主要功能 定义“全局性”路由 使用Attribute定义的路由规则 设定路由参数 路由规则与路由表 设计视图MVC视图与HTML生成 视图的合成 Razor引擎与视图设计 Taghelper]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>asp.net core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[asp.net core 扬帆起航]]></title>
    <url>%2F2019%2F05%2F15%2F%E6%89%AC%E5%B8%86%E8%B5%B7%E8%88%AA%2F</url>
    <content type="text"><![CDATA[asp.net core 起步 互联网开发须知1、互联网编程概述计算机网络VS互联网 Web Server的含义(特殊程序 承载多个web程序) URL组成 Web网页的定位过程 子“应用程序”和“虚拟目录” 应用程序vs虚拟目录 应用程序域和应用程序池 2、Web资源与URL 两种形式的资源 两种风格的URL 3、URL深入剖析 fragment 查询字符串与编码 4、MME与内容协商 如何标识web资源类型 IIS没有设定相应的MIME类型映射 内容协商 关于HTTP，你知道多少HTTP消息 HTTP方法与状态码 HTTP请求与响应过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990namespace UseHttpViaSocket&#123; class Program &#123; static void Main(string[] args) &#123; Console.Write("请输入一个有效的Web主机地址（不要输入http://,仅是主机域名或IP地址)："); string host=Console.ReadLine(); int port = 80; Console.WriteLine(); string result = SocketSendReceive(host, port); Console.WriteLine(result); Console.ReadKey(); &#125; /// &lt;summary&gt; /// 创建Socket /// &lt;/summary&gt; /// &lt;param name="server"&gt;&lt;/param&gt; /// &lt;param name="port"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static Socket ConnectSocket(string server, int port) &#123; Socket s = null; IPHostEntry hostEntry = null; //访问DNS Server，以获取主机的IP地址 hostEntry = Dns.GetHostEntry(server); //依次连接各个IP地址，有一个成功时就退出循环 foreach (IPAddress address in hostEntry.AddressList) &#123; //指定IP终结点 IPEndPoint ipe = new IPEndPoint(address, port); //使用TCP协议 Socket tempSocket = new Socket(ipe.AddressFamily, SocketType.Stream, ProtocolType.Tcp); //尝试连接 tempSocket.Connect(ipe); if (tempSocket.Connected) &#123; s = tempSocket; break; &#125; else &#123; continue; &#125; &#125; return s; &#125; /// &lt;summary&gt; /// 向Web Server发送HTTP请求，返回Server发回的数据 /// &lt;/summary&gt; /// &lt;param name="server"&gt;&lt;/param&gt; /// &lt;param name="port"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static string SocketSendReceive(string server, int port) &#123; //依据HTTP协议规范，构建HTTP请求 string request = "GET / HTTP/1.1\r\nHost: " + server + "\r\nConnection: Close\r\n\r\n"; byte[] bytesSent = Encoding.UTF8.GetBytes(request); byte[] bytesReceived = new byte[1024]; // 获取一个己连接的socket Socket s = ConnectSocket(server, port); if (s == null) return ($"无法连接主机&#123;server&#125;:&#123;port&#125;"); // 发送HTTP请求 s.Send(bytesSent, bytesSent.Length, 0); int bytes = 0; var mem = new MemoryStream();//用于缓存数据 do &#123; bytes = s.Receive(bytesReceived, bytesReceived.Length, 0); mem.Write(bytesReceived, 0, bytes); &#125; while (bytes &gt; 0);//循环接收数据 //返回服务端发回的所有数据（转换为UTF8编码的字符串) return Encoding.UTF8.GetString(mem.ToArray()); &#125; &#125;&#125; 工欲善其事必先利其器工具 httpclient 基本编程技巧 Asp.net core 简介ASP.NET core是什么？ ASP.NET core特点 ASP.NET core MVC 初识概述 Visual Studio开发MVC应用 ASP.NET core 网站的发布]]></content>
      <categories>
        <category>.NET Core</category>
      </categories>
      <tags>
        <tag>asp.net core</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端之AngularJs]]></title>
    <url>%2F2019%2F05%2F13%2Fweb%E5%89%8D%E7%AB%AF%E4%B9%8BAngularJs%2F</url>
    <content type="text"><![CDATA[AngularJS访问服务器 与服务端交互——$qweb前端开发场景 关于$q $q异步编程模式 12345678910111213141516171819202122232425262728293031323334353637383940414243 &lt;script&gt; (function () &#123; var app = angular.module('app', []); //$q必须被“注入”到控制器中 app.controller("MyCtl", ['$scope', '$q', MyCtl]); function MyCtl($scope, $q) &#123; //集中定义promise对象的回调函数 function success(result) &#123; alert(result); &#125; function error(reason) &#123; alert(reason); &#125; function notify(progress) &#123; alert(progress); &#125; $scope.invokeResolve = function () &#123; //创建deffered对象 var defer = $q.defer(); //请在控制台窗口中查询defer对象的奥秘 console.info(defer); //通过promise对象挂接回调函数 defer.promise.then(success, error, notify); //解析结果，引发success函数被调用 defer.resolve(" Resolve:工作顺利完成。"); &#125;; $scope.invokeReject = function () &#123; var defer = $q.defer(); defer.promise.then(success, error, notify); defer.reject(" Reject：工作中出了问题，未能达到预期工作目标。"); &#125;; $scope.invokeNotify = function () &#123; var defer = $q.defer(); defer.promise.then(success, error, notify); defer.notify( " Notify：工作任务己经完成了50%。"); &#125;; &#125; &#125;()); &lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="lib/bootstrap/dist/css/bootstrap.css" rel="stylesheet" /&gt; &lt;link href="lib/bootstrap/dist/css/bootstrap-theme.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;Promise链&lt;/h2&gt; &lt;p class="well"&gt;可以连续地级联then调用，构成一个promise链,请到Console中观察结果&lt;/p&gt; &lt;div ng-controller="MyCtl"&gt; &lt;button class="btn btn-default" ng-click="invokeDefer()"&gt; 测试级联调用 &lt;/button&gt; &lt;/div&gt; &lt;script src="lib/angular/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.controller("MyCtl", ['$scope', '$q', MyCtl]); function MyCtl($scope, $q) &#123; //生成一个defer对象 var defer = $q.defer(); //用于探索技术奥秘 console.info("defer", defer); //promise对象的then方法,返回一个promise对象，可以级联定义 var thenResult = defer.promise.then(function (argu) &#123; console.info("first:" + argu); //此处返回的参数将会传送到下一个then方法的参数中 return "将结果改为：abcd"; &#125;); //用于搜索技术奥秘 console.info("thenResult", thenResult); var thenResult2 = thenResult.then(function (argu) &#123; console.info("second:" + argu); &#125;); //用于搜索技术奥秘 console.info("thenResult2", thenResult2); $scope.invokeDefer = function () &#123; //调用此方法，将导致所有级联的then()方法顺序执行 defer.resolve("第一个参数"); &#125;; &#125; &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$q.all()示例&lt;/title&gt; &lt;link href="lib/bootstrap/dist/css/bootstrap.css" rel="stylesheet" /&gt; &lt;link href="lib/bootstrap/dist/css/bootstrap-theme.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="myModule"&gt; &lt;h2&gt;$q.all()示例&lt;/h2&gt; &lt;p class="well"&gt; 可以把多个promise打包放到一起，当其所有都resolve时，执行特定的后继工作。只要有一个reject，就不做后面的事。 &lt;/p&gt; &lt;div ng-controller="MyCtl"&gt; &lt;button class="btn btn-default" ng-click="resolve1($event)" ng-disabled="!button1Enable"&gt; 第一人表达意见 &lt;/button&gt; &lt;button class="btn btn-default" ng-click="resolve2()" ng-disabled="!button2Enable"&gt; 第二人表达意见 &lt;/button&gt; &lt;button class="btn btn-primary" ng-click="showResult()" ng-disabled="!canShowResult"&gt; 得到最终决议 &lt;/button&gt; &lt;h4 class="well" ng-show="message"&gt; &#123;&#123;message&#125;&#125; &lt;/h4&gt; &lt;/div&gt; &lt;script src="lib/angular/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('myModule', []); app.controller('MyCtl', ['$scope', '$q',MyCtl]); function MyCtl($scope,$q) &#123; //供张三和李四表达意见 function showInfo(result) &#123; $scope.message = result; &#125; //张三的deffered对象 var deferred1 = $q.defer(); $scope.button1Enable = true; //第一个参数表示“同意”回调函数，第二个参数表示“拒绝”回调函数 deferred1.promise.then(showInfo, showInfo); //李四的deffered对象 var deferred2 = $q.defer(); $scope.button2Enable = true; deferred2.promise.then(showInfo, showInfo); //此变量用于保存最终结果 var conclusion = null; //调用$q.all等待两人投票同意 var finalPromise = $q.all([deferred1.promise, deferred2.promise]); //看看$q.all返回啥？ console.info(finalPromise); finalPromise.then(function (agree) &#123; //两人都同意，此方法将立即被执行 console.info("finalPromise(resolve):", agree); $scope.canShowResult = true; conclusion = agree; &#125;, function (reject) &#123; //只有一人不同意，此方法会被立即调用！ console.info("finalPromise(reject):",reject); &#125;); //用于显示最终结果 $scope.showResult = function () &#123; $scope.message = conclusion; &#125; //开始投票表决 $scope.resolve1 = function (env) &#123; // deferred1.resolve('张三同意！'); deferred1.reject('张三不同意！'); $scope.button1Enable = false; &#125; $scope.resolve2 = function () &#123; deferred2.resolve('李四同意！'); //deferred2.reject('李四不同意！'); $scope.button2Enable = false; &#125; &#125; &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; $q与service实现异步调用流程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$q使用示例-异步版本&lt;/title&gt; &lt;link href="lib/bootstrap/dist/css/bootstrap.css" rel="stylesheet" /&gt; &lt;link href="lib/bootstrap/dist/css/bootstrap-theme.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;$q使用示例-异步版本&lt;/h2&gt; &lt;div ng-controller="BooksController"&gt; &lt;ul class="well list-unstyled" ng-show="messages.length&gt;0"&gt; &lt;li ng-repeat=" message in messages"&gt; &#123;&#123;message&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;All Books&lt;/h3&gt; &lt;div&gt; &lt;table class="table table-bordered table-condensed table-striped"&gt; &lt;thead class="bg-primary"&gt; &lt;tr&gt; &lt;td&gt;书名&lt;/td&gt; &lt;td&gt;作者&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr ng-repeat="book in allBooks"&gt; &lt;td&gt; &#123;&#123; book.title &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; book.author &#125;&#125; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;h3&gt;All Readers&lt;/h3&gt; &lt;div&gt; &lt;table class="table table-bordered table-condensed table-striped"&gt; &lt;thead class="bg-primary"&gt; &lt;tr&gt; &lt;td&gt;ID&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr ng-repeat="reader in allReaders"&gt; &lt;td&gt; &#123;&#123; reader.reader_id &#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123; reader.name &#125;&#125; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="lib/angular/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; 'use strict'; var app = angular.module('app', []); //service app.factory('dataService', ['$q', '$timeout', dataService]); function dataService($q, $timeout) &#123; return &#123; getAllBooks: getAllBooks, getAllReaders: getAllReaders &#125;; //用于提取图书信息，返回一个promise对象，延时1秒后resolve function getAllBooks() &#123; var booksArray = [ &#123; book_id: 1, title: 'Harry Potter and the Deathly Hallows', author: 'J.K. Rowling', yearPublished: 2000 &#125;, &#123; book_id: 2, title: 'The Cat in the Hat', author: 'Dr. Seuss', yearPublished: 1957 &#125;, &#123; book_id: 3, title: 'Encyclopedia Brown, Boy Detective', author: 'Donald J. Sobol', yearPublished: 1963 &#125; ]; var deferred = $q.defer(); //模仿服务端数据提取延迟 $timeout(function () &#123; //可手工修改此变量的值，用于模拟“数据提取成功”和“数据提取失败”两种情况 var successful = false; deferred.notify('正在提取图书信息...'); if (successful) &#123; deferred.notify('信息提取完毕，正在处理...'); //数据成功提取，返回结果 deferred.resolve(booksArray); &#125; else &#123; deferred.reject('图书数据提取失败'); &#125; &#125;, 1000); //返回一个promise对象 return deferred.promise; &#125; //用于提取读者信息，返回一个promise对象，延时1.5秒resolve function getAllReaders() &#123; var readersArray = [ &#123; reader_id: 1, name: '张三', &#125;, &#123; reader_id: 2, name: '李四', &#125;, &#123; reader_id: 3, name: '王五', &#125; ]; var deferred = $q.defer(); $timeout(function () &#123; deferred.resolve(readersArray); &#125;, 1500); return deferred.promise; &#125; &#125; //controller app.controller('BooksController', ['$scope', 'dataService', '$q', BooksController]); function BooksController($scope, dataService, $q) &#123; //用于保存所有信息 $scope.messages = []; //开始提取所有图书 var booksPromise = dataService.getAllBooks(); //为null的参数，可引用失败时的回调函数， //如果用它，就不要用catch()了，不用它，就用catch() booksPromise.then(getBooksSuccess, null, getBooksNotification) .catch(errorCallback) .finally(getAllBooksComplete); //------------提取书的回调函数------------- function getBooksSuccess(books) &#123; $scope.allBooks = books; &#125; function getBooksNotification(notification) &#123; $scope.messages.push(notification); &#125; function errorCallback(errorMsg) &#123; $scope.messages.push(errorMsg); &#125; function getAllBooksComplete() &#123; $scope.messages.push('图书信息处理完毕'); &#125; //----------------------------------------------- //------------提取读者信息的回调函数------------ function getReadersSuccess(readers) &#123; $scope.allReaders = readers; &#125; function getAllReadersComplete() &#123; $scope.messages.push('所有读者信息提取完毕'); &#125; //------------------------------------------- //开始提取读者信息 var readersPromise = dataService.getAllReaders(); //挂接读者回调函数 readersPromise.then(getReadersSuccess) .catch(errorCallback) .finally(getAllReadersComplete); //等待书和读者信息都提取完毕 $q.all([booksPromise, readersPromise]) .then(getAllDataSuccess) .catch(getAllDataError); //------------------------------ //数据全部提取完时的回调函数 function getAllDataSuccess(dataArray) &#123; $scope.allBooks = dataArray[0]; $scope.allReaders = dataArray[1]; $scope.messages.push("最终结果：全部数据提取完毕"); &#125; function getAllDataError(reason) &#123; $scope.messages.push("最终结果："+reason); &#125; //-------------------------------------- &#125; &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 与服务端交互——$http$http介绍 参数 配置参数对象 常用编程模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$http使用示例&lt;/title&gt; &lt;link href="lib/bootstrap/dist/css/bootstrap.css" rel="stylesheet" /&gt; &lt;link href="lib/bootstrap/dist/css/bootstrap-theme.css" rel="stylesheet" /&gt; &lt;style&gt; button &#123; display: block; margin: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="myModule"&gt; &lt;h2&gt;使用$http访问RESTful Service，实现CRUD&lt;/h2&gt; &lt;div ng-controller="MyCtl"&gt; &lt;div style="margin:10px;"&gt; &lt;button class="btn btn-primary" ng-click="getById(100)"&gt;使用$http.get()提取Id=100的对象&lt;/button&gt; &lt;br /&gt; &lt;button class="btn btn-primary" ng-click="httpGet()"&gt;使用配置对象发出GET请求，通过查询字符串和自定义header传送信息&lt;/button&gt; &lt;br /&gt; &lt;button class="btn btn-primary" ng-click="httpPost()"&gt;测试使用Post新建数据&lt;/button&gt; &lt;br /&gt; &lt;button class="btn btn-primary" ng-click="httpPut(100)"&gt;测试使用Put更新ID=100数据&lt;/button&gt; &lt;br /&gt; &lt;button class="btn btn-primary" ng-click="httpDelete(1000)"&gt;测试使用Delete删除Id=1000的数据&lt;/button&gt; &lt;br /&gt; &lt;button class="btn btn-primary" ng-click="httpDelete2(1000)"&gt;测试使用Delete删除Id=1000的数据,同时附加一个数据对象&lt;/button&gt; &lt;br /&gt; &lt;/div&gt; &lt;p class="well" ng-show="message"&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src="lib/angular/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('myModule', []); app.factory('dataService', ['$http', '$q', dataService]); function dataService($http, $q) &#123; //使用$http.get提取指定Id值的对象 var getById = function (id) &#123; var deffered = $q.defer(); $http.get("api/example/getById/" + id) .success(function (data, status, headers, config) &#123; deffered.resolve(data); &#125;) .error(function (data, status, headers, config) &#123; deffered.reject(&#123; "data": data, "status": status &#125;); &#125;); return deffered.promise; &#125; //使用配置对象发出GET请求，通过查询字符串和自定义header传送信息 var getData = function () &#123; var deffered = $q.defer(); var headervalue = new Date().toJSON(); $http(&#123; method: 'GET', params: &#123; info: "Hello" &#125;, //生成查询字符串 url: 'api/example', headers: &#123; 'myheader': headervalue &#125; //自定义Header &#125;) .success(function (data, status, headers, config) &#123; deffered.resolve(data); &#125;) .error(function (data, status, headers, config) &#123; deffered.reject(&#123; "data": data, "status": status &#125;); &#125;); return deffered.promise; &#125;; //使用POST方法提交数据 var postData = function () &#123; var deffered = $q.defer(); var httpObj = $http(&#123; method: 'POST', data: &#123; info: "a new object" &#125;, //要Post的数据 url: 'api/example' &#125;) .success(function (data, status, headers, config) &#123; //在此访问原始响应结果 var result = &#123; "status": status, "location": headers("location"), "data": data &#125;; //仅向外界返回需要的数据，其它信息进行隐藏 //也可以将数据保存于本Service中（在这些数据需要在多个Controller中共享的情况下） deffered.resolve(result); &#125;) .error(function (data, status, headers, config) &#123; deffered.reject(&#123; "data": data, "status": status &#125;); &#125;); //此代码用于查看$http对象的成员 console.info(httpObj); return deffered.promise; &#125;; //使用Put方法提交数据 var putData = function (id, dataObj) &#123; var deffered = $q.defer(); var httpObj = $http(&#123; method: 'put', data: dataObj, url: 'api/example/' + id &#125;) .success(function (data, status, headers, config) &#123; //在此访问原始结果 var result = &#123; "status": status, "data": data &#125;; deffered.resolve(result); &#125;) .error(function (data, status, headers, config) &#123; deffered.reject(&#123; "data": data, "status": status &#125;); &#125;); return deffered.promise; &#125;; //使用delete方法删除数据 var deleteData = function (id) &#123; var deffered = $q.defer(); var url = 'api/example/' + id; $http(&#123; method: 'DELETE', url: url &#125;) .success( function (data, status, headers, config) &#123; //在此访问原始结果 var result = &#123; "status": status, "data": data &#125;; deffered.resolve(result); &#125;) .error(function (data, status, headers, config) &#123; deffered.reject(&#123; "data": data, "status": status &#125;); &#125;); return deffered.promise; &#125;; //使用delete方法删除数据，同时在Body中Post一些数据到Server端 var deleteWithAttachedData = function (id, attachedData) &#123; var deffered = $q.defer(); var url = 'api/example/delete2/' + id; //当使用DELETE请求附加一些数据时，要设定Content-Type值 //否则Server端将不知道如何解析这些数据，从而返回一个405响应（未知媒体类型）。 $http(&#123; method: 'DELETE', url: url, data: attachedData, //要Post的数据，自动被序列为Json headers: &#123; 'Content-Type': 'application/json' &#125; &#125;) .success( function (data, status, headers, config) &#123; //在此访问原始结果 var result = &#123; "status": status, "data": data &#125;; deffered.resolve(result); &#125;) .error(function (data, status, headers, config) &#123; deffered.reject(&#123; "data": data, "status": status &#125;); &#125;); return deffered.promise; &#125;; return &#123; getById: getById, getData: getData, postData: postData, putData: putData, deleteData: deleteData, deleteWithAttachedData: deleteWithAttachedData &#125; &#125; app.controller('MyCtl', ['$scope', 'dataService', MyCtl]); function MyCtl($scope, dataService) &#123; $scope.getById = function (id) &#123; dataService.getById(id).then( function (result) &#123; $scope.message = result; &#125;, function (error) &#123; $scope.message = error.status; &#125;); &#125; $scope.httpGet = function () &#123; dataService.getData().then( function (result) &#123; $scope.message = result; &#125;, function (error) &#123; $scope.message = error.status; &#125;); &#125;; $scope.httpPost = function () &#123; dataService.postData(&#123; info: "a new object" &#125;).then( function (result) &#123; $scope.message = result; &#125;, function (error) &#123; $scope.message = error.status; &#125;); &#125;; $scope.httpPut = function (id) &#123; dataService.putData(100, &#123; id: 100, info: "要更新的数据" &#125;).then( function (result) &#123; $scope.message = result; &#125;, function (error) &#123; $scope.message = error.status; &#125;); &#125;; $scope.httpDelete = function (id) &#123; dataService.deleteData(id).then( function (result) &#123; $scope.message = result; &#125;, function (error) &#123; $scope.message = error.status; &#125;); &#125;; $scope.httpDelete = function (id) &#123; dataService.deleteData(id).then( function (result) &#123; $scope.message = result; &#125;, function (error) &#123; $scope.message = error.status; &#125;); &#125;; $scope.httpDelete2 = function (id) &#123; dataService.deleteWithAttachedData(id, &#123; info: '一个从客户端送上来的数据对象' &#125;).then( function (result) &#123; $scope.message = result; &#125;, function (error) &#123; $scope.message = error.status; &#125;); &#125;; &#125; &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; UI-Router参考 AngularUI Router使用基础 定义UI—Router路由 理解“状态” 处理参数 Resolve属性与依赖注入 命名视图 父子状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="lib/bootstrap/dist/css/bootstrap.css" rel="stylesheet" /&gt; &lt;link href="lib/bootstrap/dist/css/bootstrap-theme.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="UIRouteApp"&gt; &lt;h2&gt;UI Route Demos&lt;/h2&gt; &lt;div ng-controller="MainCtl"&gt; &lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt; &lt;a ng-click="reload()" class="btn btn-warning"&gt;回到初始状态&lt;/a&gt; &lt;br /&gt;&lt;br /&gt; &lt;a href="#/simplest" class="btn btn-default"&gt;使用URL激活Simplest状态&lt;/a&gt; &lt;a ui-sref="simplest" class="btn btn-default"&gt;使用名字激活Simplest状态&lt;/a&gt; &lt;a ng-click="goToSimplestState()" class="btn btn-default"&gt;代码激活Simplest状态&lt;/a&gt; &lt;br /&gt;&lt;br /&gt; &lt;a ui-sref="home" class="btn btn-info"&gt;状态home:使用模板和控制器&lt;/a&gt; &lt;a ui-sref="argument(&#123;argu1:'hello',argu2:'world'&#125;)" class="btn btn-info"&gt;状态argument:路由参数与路由事件&lt;/a&gt; &lt;a ui-sref="resolve" class="btn btn-info"&gt;状态resolve：依赖注入与附加属性&lt;/a&gt; &lt;br /&gt;&lt;br /&gt; &lt;a ui-sref="namedView" class="btn btn-primary"&gt;测试命名的视图&lt;/a&gt; &lt;a ui-sref="parent.child" class="btn btn-primary"&gt;显示子视图&lt;/a&gt; &lt;hr /&gt; &lt;div ui-view&gt; &lt;/div&gt; &lt;div ui-view="one"&gt;&lt;/div&gt; &lt;div ui-view="two"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src="lib/jquery/dist/jquery.js"&gt;&lt;/script&gt; &lt;script src="lib/bootstrap/dist/js/bootstrap.js"&gt;&lt;/script&gt; &lt;script src="lib/angular/angular.js"&gt;&lt;/script&gt; &lt;script src="lib/angular-ui-router/release/angular-ui-router.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; 'use strict'; var app = angular.module('UIRouteApp', ['ui.router']); app.config(['$stateProvider', function ($stateProvider) &#123; $stateProvider .state('simplest', &#123; url: '/simplest', template: '&lt;h3&gt;最简单的UI Router状态&lt;/h3&gt;' &#125;) .state('home', &#123; url: '/home', controller: 'HomeController', templateUrl: 'templates/home.html' &#125;) .state('argument', &#123; url: '/argument/:argu1/nouse/:argu2', controller: 'ArguCtl', templateUrl: 'templates/argument.html', onEnter: function ($state) &#123; console.info('进入argument状态', $state); &#125;, onExit: function ($state) &#123; console.info('退出argument状态', $state); &#125; &#125;) .state('resolve', &#123; url: '/resolve', controller: 'ResolveCtl', templateUrl: 'templates/resolve.html', resolve: &#123; objs: function () &#123; return &#123; id: 100, information: "依赖注入到控制器中的对象" &#125;; &#125; &#125;, data: &#123; name: 'my name', desc: 'Fun!' &#125;, foo: &#123; myFoo: 'bar' &#125; &#125;) .state('namedView', &#123; url: "/namedView", views: &#123; 'one': &#123; template: '&lt;h4&gt;name="one" 的视图&lt;/h4&gt;' &#125;, 'two': &#123; template: '&lt;h4&gt;name="two"的视图&lt;/h4&gt;' &#125; &#125; &#125;) .state('parent', &#123; url: '/parent', abstract: true, templateUrl: 'templates/parent.html', controller: 'ParentCtl', resolve: &#123; now: function () &#123; return new Date().toLocaleString(); &#125; &#125;, data: &#123; info: '来自于父亲的数据' &#125; &#125;) .state('parent.child', &#123; url: '/child', templateUrl: 'templates/child.html', controller: 'ChildCtl' &#125; ); &#125;]); app.controller('MainCtl', ['$scope', '$state', '$location', MainCtl]); function MainCtl($scope,$state,$location) &#123; $scope.title = "Angular UI Router特性展示"; $scope.reload = function () &#123; $location.path("/"); window.location.reload(); &#125; $scope.goToSimplestState = function () &#123; $state.go('simplest'); &#125;; &#125; app.run(['$rootScope', function ($rootScope) &#123; $rootScope.$on('$stateChangeSuccess', function (event, toState, toParams, fromState, fromParams) &#123; console.info('状态转换成功'); console.info(event, toState, toParams, fromState, fromParams); &#125;); &#125;]); &#125;)(); &lt;/script&gt; &lt;script src="js/homecontroller.js"&gt;&lt;/script&gt; &lt;script src="js/argumentcontroller.js"&gt;&lt;/script&gt; &lt;script src="js/resolve.js"&gt;&lt;/script&gt; &lt;script src="js/ParentAndChildCtl.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 深入理解HTML表单 input textarea select checkbox radio Angular表单数据验证 验证手段 三个条件 必填项处理 内置常用数据验证指令 数据验证状态service Angluar HTML表单编程技巧]]></content>
      <categories>
        <category>前端框架</category>
        <category>AngularJS</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS]]></title>
    <url>%2F2019%2F05%2F10%2FAngularJS%2F</url>
    <content type="text"><![CDATA[AngularJS初识 Angular概述适用场景 SPA基本原理 Angular的特色 学习AngularJs的建议 初识AngularJS 模块与控制器模块 作用 定义与获取 控制器传统模式 现代模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;html &gt;&lt;head&gt; &lt;title&gt;模块与控制器&lt;/title&gt; &lt;link href="../Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body style="text-align:center" class="container" &gt; &lt;h2&gt;模块与控制器（现代写法）&lt;/h2&gt; &lt;p class="well"&gt;使用新的写法，可以不需要在控制器函数中指定$scope&lt;/p&gt; &lt;!-- 关联模块 --&gt; &lt;div ng-app="myModule"&gt; &lt;!-- 关联控制器，并指明它的别外 --&gt; &lt;div ng-controller="myCtl as vm"&gt; &lt;!-- 使用绑定表达式提取数据信息 --&gt; &lt;h2&gt;“&#123;&#123;vm.dataObject.info&#125;&#125;”&lt;/h2&gt; &lt;img ng-src="&#123;&#123;vm.dataObject.src&#125;&#125;" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; //使用立即函数封装所有代码 (function () &#123; //启用严格模式 'use strict'; //创建模块 var myModule = angular.module('myModule', []); //“现代”风格的控制器，不需要显式定义一个名为$scope的参数 var MyCtl = function () &#123; //“模型”代表了程序要处理或显示的数据 this.dataObject = &#123; info: "雪中的房屋", src: "/images/house.jpg" &#125;; &#125;; //控制器需要在模块中注册 myModule.controller('myCtl', MyCtl); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;title&gt;AngularJS的使用&lt;/title&gt; &lt;link href="../Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center"&gt; &lt;div ng-app="app"&gt; &lt;h2&gt;事件响应&lt;/h2&gt; &lt;p class="well"&gt;ng-click指令将指定的函数与浏览器中的mouseup事件绑定在一起&lt;/p&gt; &lt;div ng-controller="MyController"&gt; &lt;h4 class="text-danger"&gt;&lt;strong&gt;&#123;&#123;info&#125;&#125;&lt;/strong&gt;&lt;/h4&gt; &lt;!--&lt;h4 class="text-info"&gt;&lt;strong&gt;事件参数：&lt;/strong&gt;&#123;&#123;eventObject &#125;&#125;&lt;/h4&gt;--&gt; &lt;button class="btn btn-primary" ng-click="showInfo($event)"&gt;点击我！&lt;/button&gt; &lt;ul class="text-left list-group"&gt; &lt;li ng-repeat="info in infos" class="list-group-item list-group-item-info"&gt; &lt;p&gt;&lt;strong&gt;属性名: &lt;/strong&gt;&#123;&#123;info.key&#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;strong&gt;值：&lt;/strong&gt;&lt;span&gt;&#123;&#123;info.value&#125;&#125;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; angular.module('app', []) .controller('MyController', function ($scope) &#123; $scope.info = ""; $scope.eventObject = ""; var count = 0; $scope.showInfo = function (evt) &#123; count++; $scope.info = "我被扁了" + count + "次"; var infos = []; for (var prop in evt) &#123; infos.push(&#123; key: prop, value: evt[prop] +""&#125;); &#125; $scope.infos = infos; &#125;; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 控制器职责 数据绑定数据绑定表达式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;Angular中的绑定表达式&lt;/h2&gt; &lt;div ng-controller="MyController"&gt; &lt;table class="table table-bordered"&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;表达式&lt;/td&gt; &lt;td&gt;解析结果&lt;/td&gt; &lt;td&gt;说明&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td ng-non-bindable&gt; &#123;&#123;1+1&#125;&#125; &lt;/td&gt; &lt;td&gt;&#123;&#123;1+1&#125;&#125;&lt;/td&gt; &lt;td&gt;解析算术表达式&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td ng-non-bindable&gt; &#123;&#123;"Hello,"+" World!" &#125;&#125; &lt;/td&gt; &lt;td&gt;&#123;&#123;"Hello,"+" World!" &#125;&#125;&lt;/td&gt; &lt;td&gt;解析标准JavaScript表达式&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td ng-non-bindable&gt; &#123;&#123;"Good Bye"| lowercase&#125;&#125; &lt;/td&gt; &lt;td&gt;&#123;&#123;"Good Bye"| lowercase&#125;&#125;&lt;/td&gt; &lt;td&gt; 利用过滤器格式化数据后再显示 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td ng-non-bindable&gt; &#123;&#123;"当前时间是："+ now&#125;&#125; &lt;/td&gt; &lt;td&gt;&#123;&#123;"当前时间是："+ now&#125;&#125;&lt;/td&gt; &lt;td&gt; 从$scope对象属性中提取数据 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td ng-non-bindable&gt; &#123;&#123;"1+2="+add(1,2)&#125;&#125; &lt;/td&gt; &lt;td&gt;&#123;&#123;"1+2="+add(1,2)&#125;&#125;&lt;/td&gt; &lt;td&gt; 可以在表达式中嵌入$scope中定义的函数 &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.controller('MyController', function ($scope) &#123; $scope.now = new Date().toLocaleTimeString(); $scope.add = function (x, y) &#123; return x + y; &#125; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 绑定表达式解析过程 数据绑定类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt; &lt;style&gt; div &#123; margin: 5px; padding: 4px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;双向绑定&lt;/h2&gt; &lt;p class="well"&gt; 当使用ng-model创建数据绑定时，Angular会自动在它所属的Scope中添加相应的属性(如果它没有找到的话)。 因此，当使用“.”指定绑定的Model属性时，我们将在当前的Scope中得到一个唯一的对象，它拥有input元素所绑定的属性。 从而可以在Click事件中直接使用它作为参数。 &lt;/p&gt; &lt;div ng-controller="MyController" class="well"&gt; &lt;div class="row"&gt; &lt;label class="col-xs-1 col-xs-offset-2"&gt;name:&lt;/label&gt;&lt;input class="col-xs-6" ng-model="data.name" /&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;label class="col-xs-1 col-xs-offset-2"&gt;info:&lt;/label&gt; &lt;input class="col-xs-6" ng-model="data.info" /&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;button class="btn btn-default col-xs-4 col-xs-offset-5" ng-click="modifyData(data)"&gt;用代码修改数据对象&lt;/button&gt; &lt;/div&gt; &lt;div class="row" ng-show="data"&gt; &lt;h3&gt;&lt;strong&gt;name:&lt;/strong&gt;&lt;span class="text-danger"&gt;&#123;&#123;data.name || '无'&#125;&#125;&lt;/span&gt; &lt;/h3&gt; &lt;h3&gt;&lt;strong&gt;info:&lt;/strong&gt;&lt;span class="text-danger"&gt;&#123;&#123;data.info||'无'&#125;&#125;&lt;/span&gt; &lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.controller('MyController', function ($scope) &#123; $scope.modifyData = function (obj) &#123; if (!!obj) &#123; obj.name = "obj.name modified @" + new Date().toLocaleTimeString(); obj.info = "obj.info modified @" + new Date().toLocaleTimeString(); &#125; else &#123; alert('未找到数据模型对象'); &#125; &#125;; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="../Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="myModule"&gt; &lt;h2&gt;Angular中的数据绑定应用技巧&lt;/h2&gt; &lt;h3&gt;1 单向与双向绑定&lt;/h3&gt; &lt;div ng-controller="myCtl as vm"&gt; &lt;p class="text-primary"&gt;单向绑定：&lt;strong&gt;&#123;&#123;vm.info&#125;&#125;&lt;/strong&gt;&lt;/p&gt; &lt;label for="info"&gt;双向绑定：&lt;/label&gt; &lt;input ng-model="vm.info" /&gt; &lt;br /&gt;&lt;br /&gt; &lt;button class="btn btn-default" ng-click="vm.show(vm.info)"&gt; 显示用户输入的数据 &lt;/button&gt; &lt;hr /&gt; &lt;h3&gt;2 One Time绑定&lt;/h3&gt; &lt;p class="well"&gt;angular 1.3新增，仅在第一次时执行绑定，以后底层数据变化时，不再更新。可以提升性能。&lt;/p&gt; &lt;p class="text-primary"&gt;单向绑定：&lt;strong&gt;&#123;&#123;vm.message&#125;&#125;&lt;/strong&gt;&lt;/p&gt; &lt;label for="info"&gt;双向绑定：&lt;/label&gt; &lt;input ng-model="vm.message" /&gt; &lt;p class="text-danger"&gt;One Time绑定:&lt;strong&gt; &#123;&#123;::vm.message&#125;&#125;&lt;/strong&gt;&lt;/p&gt; &lt;/div&gt; &lt;hr /&gt; &lt;div ng-controller='StudentListController'&gt; &lt;h3&gt;3 动态添加数据对象&lt;/h3&gt; &lt;button class="btn btn-default" ng-click="insertNewStudent()"&gt; 添加新学生 &lt;/button&gt; &lt;br /&gt;&lt;br/&gt; &lt;ul class="list-group"&gt; &lt;li class="list-group-item" ng-repeat='student in students'&gt; &lt;p&gt;&#123;&#123;student.id&#125;&#125;:&#123;&#123;student.name&#125;&#125;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('myModule', []); var myCtl = function () &#123; this.info = ""; this.show = function (message) &#123; alert(message); &#125;; this.message = '初始值'; &#125;; app.controller('myCtl', [myCtl]); var count; var students = [&#123; name: '学生1', id: '1' &#125;, &#123; name: '学生2', id: '2' &#125;, &#123; name: '学生3', id: '3' &#125;]; count = students.length; function StudentListController($scope) &#123; $scope.students = students; $scope.insertNewStudent = function () &#123; count++; var newStudent = &#123; name: '学生' + count, id: count &#125;; $scope.students[count-1] = newStudent; &#125;; &#125;; app.controller('StudentListController', StudentListController); &#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Angular视图常用指令“视图”指的是啥？ ng-show/ng-hide 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="/Content/bootstrap.min.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body ng-app&gt; &lt;div class="container text-center"&gt; &lt;section&gt; &lt;h2&gt;ngIf指令示例&lt;/h2&gt; &lt;button class="btn btn-default" ng-click="on=true"&gt;on=true&lt;/button&gt; &lt;button class="btn btn-default" ng-click="on=false"&gt;on=false&lt;/button&gt; &lt;br /&gt; &lt;br /&gt; &lt;div ng-if="on" class="well"&gt; &lt;p&gt;当on=true时，这些文字看得到&lt;/p&gt; &lt;/div&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;ngShow指令示例&lt;/h2&gt; &lt;button class="btn btn-default" ng-click="show=!show"&gt;切换或隐藏&lt;/button&gt; &lt;br /&gt; &lt;br /&gt; &lt;div ng-show="show" class="well"&gt; &lt;p&gt;这是一段文字&lt;/p&gt; &lt;/div&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;ngSwitch指令示例&lt;/h2&gt; &lt;button class="btn btn-default" ng-click="slide='primary'"&gt;primary&lt;/button&gt; &lt;button class="btn btn-default" ng-click="slide='info'"&gt;info&lt;/button&gt; &lt;button class="btn btn-default" ng-click="slide='danger'"&gt;danger&lt;/button&gt; &lt;button class="btn btn-default" ng-click="slide='default'"&gt;default&lt;/button&gt; &lt;button class="btn btn-default" ng-click="slide='warning'"&gt;warning&lt;/button&gt; &lt;br /&gt; &lt;br /&gt; &lt;div ng-switch="slide"&gt; &lt;div ng-switch-when="primary" class="panel panel-primary"&gt; &lt;h3 class="text-center text-primary"&gt;primary&lt;/h3&gt; &lt;/div&gt; &lt;div ng-switch-when="info" class="panel panel-info"&gt; &lt;h3 class="text-center text-info"&gt;info&lt;/h3&gt; &lt;/div&gt; &lt;div ng-switch-when="danger" class="panel panel-danger"&gt; &lt;h3 class="text-center text-danger"&gt; danger&lt;/h3&gt; &lt;/div&gt; &lt;div ng-switch-when="default" class="panel panel-default"&gt; &lt;h3 class="text-center "&gt;default&lt;/h3&gt; &lt;/div&gt; &lt;div ng-switch-when="warning" class="panel panel-warning"&gt; &lt;h3 class="text-center text-warning"&gt; warning&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;section&gt; &lt;h2&gt;ngClass,ngBlur, ngFocus指令示例&lt;/h2&gt; &lt;!-- ng-class中放的实际上是一个对象字面量 --&gt; &lt;span ng-class="&#123;'label-success':focus&#125;" class="label label-default"&gt;Focus!&lt;/span&gt; &lt;span ng-class="&#123;'label-warning':!focus&#125;" class="label label-default"&gt;Blur!&lt;/span&gt; &lt;input ng-focus="focus=true" ng-blur="focus=false"/&gt; &lt;/section&gt; &lt;/div&gt; &lt;script src="/Scripts/angular.min.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ng-repeat 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt; &lt;style&gt; .odd &#123; background-color: #ccece6; &#125; .even &#123; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;div ng-controller="PeopleController"&gt; &lt;h2&gt;ngRepeat使用示例&lt;/h2&gt; &lt;div&gt; &lt;ul class="list-unstyled"&gt; &lt;!-- $even $index $odd ng-repeat提供 --&gt; &lt;li ng-repeat="person in people" ng-class="&#123;even: !$even, odd: !$odd&#125;" style="font-size:x-large;padding:5px;"&gt; &#123;&#123;$index+1&#125;&#125;: &#123;&#123;person.name&#125;&#125; 生活于 &#123;&#123;person.city&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;button class="btn btn-default" ng-click="items[items.length]=items.length"&gt; 新加数字 &lt;/button&gt; &lt;br /&gt; &lt;br /&gt; &lt;ul ng-repeat="item in items" class="list-group"&gt; &lt;li class="list-group-item"&gt;第&#123;&#123;$index+1&#125;&#125;项的值为&amp;nbsp;&lt;strong style="color:red"&gt;&#123;&#123;item&#125;&#125;&lt;/strong&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.controller('PeopleController', function ($scope) &#123; $scope.items = [0, 1, 2]; $scope.people = [ &#123; name: "张三", city: "北京" &#125;, &#123; name: "李四", city: "上海" &#125;, &#123; name: "王五", city: "广州" &#125;, &#123; name: "赵六", city: "深圳" &#125;, ]; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;ngRepeat和对象集合&lt;/h2&gt; &lt;p class="well"&gt;使用ngRepeat生成HTML列表元素时，可以直接把特定的元素与数据对象“绑定”到一起。&lt;/p&gt; &lt;div ng-controller="MyController"&gt; &lt;ul class="list-group"&gt; &lt;li class="list-group-item" ng-repeat="obj in dataObjects"&gt; &#123;&#123;obj.name&#125;&#125; &lt;button class="btn btn-default" ng-click="showDetail(obj)"&gt;显示详细信息&lt;/button&gt; &lt;button class="btn btn-default" ng-click="removeObject($index)"&gt;移除&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p class="text-info" ng-show="currentObj"&gt;“&lt;strong&gt;&#123;&#123;currentObj.name&#125;&#125;”己被移除&lt;/strong&gt;&lt;/p&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.controller('MyController', function ($scope) &#123; var objects = [ &#123; name: '张三', age: 30 &#125;, &#123; name: '李四', age: 40 &#125;, &#123; name: '王五', age: 50 &#125;, &#123; name: '赵六', age: 60 &#125;, &#123; name: '乐七', age: 70 &#125;]; $scope.dataObjects = objects; $scope.showDetail = function (obj) &#123; alert(angular.toJson(obj)); &#125; $scope.removeObject = function (index) &#123; $scope.currentObj = objects[index]; objects.splice(index, 1); &#125; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt; &lt;style&gt; .selected &#123; background-color: lightgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;点击高亮选中行&lt;/h2&gt; &lt;p class="well"&gt;使用ngClass,ngClick和$index配合实现&lt;/p&gt; &lt;table class="table table-bordered" ng-controller="MyController"&gt; &lt;tr ng-repeat='person in people' ng-click='selectPerson($index)' ng-class='&#123;selected: $index==selectedRow&#125;'&gt; &lt;td&gt;&#123;&#123;person.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;person.age&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.controller('MyController', function ($scope) &#123; $scope.people = [ &#123; name: "张三", age: 20 &#125;, &#123; name: "李四", age: 30 &#125;, &#123; name: "王五", age: 40 &#125;, &#123; name: "赵六", age: 50 &#125;, &#123; name: "马七", age: 60 &#125; ]; $scope.selectPerson = function (row) &#123; $scope.selectedRow = row; &#125;; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="/Content/bootstrap.min.css" rel="stylesheet" /&gt; &lt;style&gt; div &#123; margin: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;使用ngInclude加载模板&lt;/h2&gt; &lt;div ng-controller="MyController"&gt; &lt;div ng-repeat="student in students"&gt; &lt;!--&lt;div ng-include src="studentViewUrl"&gt;&lt;/div&gt;--&gt; &lt;ng-include src="studentViewUrl" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/Scripts/angular.min.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.controller('MyController', function ($scope) &#123; $scope.students = [ &#123; name: "张三", description: "一个好学生" &#125;, &#123; name: "李四", description: "学霸" &#125;, &#123; name: "王五", description: "天天玩游戏" &#125;, &#123; name: "赵六", description: "准备出国" &#125;, &#123; name: "马七", description: "积极向组织靠拢" &#125; ]; $scope.studentViewUrl = "student.html"; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567//student.html&lt;div class="well"&gt; &lt;h4&gt; &lt;strong class="text-primary"&gt;&#123;&#123;student.name&#125;&#125;:&lt;/strong&gt; &amp;nbsp;&#123;&#123;student.description&#125;&#125; &lt;/h4&gt;&lt;/div&gt; 过滤器数据绑定过滤器 代码调用过滤器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt; &lt;style&gt; h3,li&#123; color:blue;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;过滤器使用示例&lt;/h2&gt; &lt;p class="well"&gt; 可以使用两种过滤器：Angular官方内置过滤器和自定义过滤器 &lt;/p&gt; &lt;div ng-controller="MyController"&gt; &lt;h3&gt;abcd&#123;&#123;" 小写转大写：" | uppercase&#125;&#125;&lt;/h3&gt; &lt;h3&gt; 123.456789 &amp;nbsp;保留两位数字： &#123;&#123; 123.456789 | number:2 &#125;&#125; &lt;/h3&gt; &lt;h3&gt;以货币形式显示数字：&#123;&#123; 12.3 | currency | number:0 &#125;&#125;&lt;/h3&gt; &lt;h3&gt;时间格式化&lt;/h3&gt; &lt;ul style="text-align:left;width:400px;margin:0 auto;"&gt; &lt;li&gt;&#123;&#123; today | date:'medium' &#125;&#125; &lt;/li&gt; &lt;li&gt;&#123;&#123; today | date:'short' &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; today | date:'fullDate' &#125;&#125; &lt;/li&gt; &lt;li&gt;&#123;&#123; today | date:'longDate' &#125;&#125; &lt;/li&gt; &lt;li&gt;&#123;&#123; today | date:'mediumDate' &#125;&#125;&lt;/li&gt; &lt;li&gt; &#123;&#123; today | date:'shortDate' &#125;&#125; &lt;/li&gt; &lt;li&gt; &#123;&#123; today | date:'mediumTime' &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; today | date:'shortTime' &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;用自定义函数进行过滤&lt;/h3&gt; &lt;h4&gt;&#123;&#123; ['Ari','likes','to','travel'] | filter:isCapitalized &#125;&#125;&lt;/h4&gt; &lt;h3&gt;将JavaScript对象转换为json&lt;/h3&gt; &lt;h4&gt; &#123;&#123; &#123;'name': 'Ari', 'City': 'SanFrancisco'&#125; | json &#125;&#125;&lt;/h4&gt; &lt;h3&gt;使用自定义过滤器:大写并反转&lt;/h3&gt; &lt;h4&gt;&#123;&#123;'this is a test' | reverse:true &#125;&#125;&lt;/h4&gt; &lt;/div&gt; &lt;script src="../Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="../Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.controller('MyController', function ($scope) &#123; $scope.today = new Date(); $scope.isCapitalized = function (str) &#123; return str[0] == str[0].toUpperCase(); &#125;; &#125;); //自定义过滤器 app.filter('reverse', function () &#123; return function (input, uppercase) &#123; input = input || ''; var out = ""; for (var i = 0; i &lt; input.length; i++) &#123; out = input.charAt(i) + out; &#125; if (uppercase) &#123; out = out.toUpperCase(); &#125; return out; &#125;; &#125;) &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h3&gt;使用filter实现数据查找&lt;/h3&gt; &lt;div class="row"&gt; &lt;div class="col-xs-8 col-xs-offset-2"&gt; &lt;div class="text-left"&gt; &lt;label&gt;输入要找的人名：&lt;/label&gt; &lt;input type="search" ng-model="search_name" /&gt; &lt;/div&gt; &lt;div ng-controller="MyController"&gt; &lt;ul class="text-left"&gt; &lt;li ng-repeat="name in names | filter:search_name"&gt;&#123;&#123;name&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="text-left"&gt; &lt;label&gt;输入要找的人名或年纪：&lt;/label&gt; &lt;input type="search" ng-model="search_person" /&gt; &lt;/div&gt; &lt;div ng-controller="MyController"&gt; &lt;ul class="text-left"&gt; &lt;li ng-repeat="person in people | filter:search_person"&gt;&#123;&#123;person.name&#125;&#125;:&#123;&#123;person.age&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); var MyController = function ($scope) &#123; $scope.names = ["Tom", "Jeffrey", "Dan", "David", "Peter"]; $scope.people = [ &#123; name: "张三", age: 20 &#125;, &#123; name: "李四", age: 30 &#125;, &#123; name: "王五", age: 40 &#125;, &#123; name: "赵六", age: 50 &#125;, &#123; name: "马七", age: 60 &#125; ]; &#125;; app.controller('MyController', MyController); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; $scope探秘编译过程 作用和功能 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$rootScope示例&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;$rootScope示例&lt;/h2&gt; &lt;p class="well text-left"&gt; 任何具有ng-app属性的DOM元素都关联着一个$rootScope，它是作用域链的起始点，任何嵌套在ng-app内的指令或控制器都会继承它。 &lt;br /&gt; 在JavaScript代码中，可以在Module的run方法中访问到$rootScope并给它添加“全局”的属性与函数。 &lt;/p&gt; &lt;p class="text-info"&gt;&#123;&#123;info&#125;&#125;&lt;/p&gt; &lt;button class="btn btn-primary" ng-click="func()"&gt;点击我调用$rootScope中的方法&lt;/button&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.run(function ($rootScope) &#123; $rootScope.info = "$rootScope中定义的属性"; $rootScope.func = function () &#123; $rootScope.info = "定义在$rootScope中的方法被调用：" + new Date().toLocaleTimeString(); &#125; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; scope对象可以嵌套 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="../Content/bootstrap.css" rel="stylesheet" /&gt; &lt;style&gt; .ng-scope &#123; border: 1px solid red; margin: 3px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;父子控制器(字符串类型的属性)&lt;/h2&gt; &lt;p class="well"&gt; 本示例展示了嵌套控制器中，父子控制器修改“同一个”父控制器中定义的属性时的“诡异”特性。&lt;br /&gt; 分为两种情况：&lt;br /&gt; 一是属性是字符串类型的;&lt;br /&gt; 二是属性是对象类型的。&lt;br /&gt; 这两种情况下程序展示的行为特性是完全不一样的。 &lt;/p&gt; &lt;div ng-controller="ParentController" style="padding:5px;"&gt; &lt;h3 class="text-warning"&gt;父控制器：&#123;&#123;info&#125;&#125;&lt;/h3&gt; &lt;button class="btn btn-primary" ng-click="showInfo()"&gt;修改显示的信息&lt;/button&gt; &lt;div ng-controller="ChildController" style="padding:5px;"&gt; &lt;h3 class=" text-primary"&gt; 子控制器：&#123;&#123;info&#125;&#125; &lt;/h3&gt; &lt;button class="btn btn-primary" ng-click="showInfo()"&gt;修改显示的信息&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="../Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); //注意在Chrome的Developer窗口中观察其原型链 app.controller('ParentController', function ($scope, $rootScope) &#123; var orginalString = '定义在父控制器中的属性' $scope.info = orginalString; $scope.showInfo = function () &#123; $scope.info = orginalString + ' 被修改于：' + new Date().toLocaleTimeString(); &#125;; console.info("$rootScope", $rootScope); console.info("ParentController.$scope", $scope); &#125;); app.controller('ChildController', function ($scope) &#123; $scope.showInfo = function () &#123; $scope.info = "子控制器修改父控制器定义的属性：" + new Date().toLocaleTimeString(); &#125;; console.info("ChildController.$scope", $scope); &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="../Content/bootstrap.css" rel="stylesheet" /&gt; &lt;style&gt; .ng-scope &#123; border: 1px solid red; margin: 3px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;父子控制器（对象类型的属性）&lt;/h2&gt; &lt;p class="well"&gt; 本示例展示了嵌套控制器中，父子控制器修改“同一个”父控制器中定义的属性时的“诡异”特性。&lt;br /&gt; 分为两种情况：&lt;br /&gt; 一是属性是字符串类型的;&lt;br /&gt; 二是属性是对象类型的。&lt;br /&gt; 这两种情况下程序展示的行为特性是完全不一样的。 &lt;/p&gt; &lt;div ng-controller="ParentController" style="padding:5px;"&gt; &lt;h3 class="text-warning"&gt;父控制器：&#123;&#123;info.value&#125;&#125;&lt;/h3&gt; &lt;button class="btn btn-primary" ng-click="showInfo()"&gt;修改显示的信息&lt;/button&gt; &lt;div ng-controller="ChildController" style="padding:5px;"&gt; &lt;h3 class=" text-primary"&gt; 子控制器：&#123;&#123;info.value&#125;&#125;&lt;/h3&gt; &lt;button class="btn btn-primary" ng-click="showInfo()"&gt;修改显示的信息&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="../Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); //注意在Chrome的Developer窗口中观察其原型链 app.controller('ParentController', function ($scope, $rootScope) &#123; var orginalString = '定义在父控制器中的属性' $scope.info = &#123; value: orginalString &#125;; $scope.showInfo = function () &#123; $scope.info.value =orginalString+ ' 被修改于：' + new Date().toLocaleTimeString(); &#125;; console.info("$rootScope", $rootScope); console.info("ParentController.$scope", $scope); &#125;); app.controller('ChildController', function ($scope) &#123; $scope.showInfo = function () &#123; $scope.info.value = "子控制器修改父控制器定义的属性：" + new Date().toLocaleTimeString(); &#125;; console.info("ChildController.$scope", $scope); &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; $scope所提供的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="../Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;$watch和$parse&lt;/h2&gt; &lt;ul class="text-left list-group text-info"&gt; &lt;li class="list-group-item"&gt; 使用$watch可以监控变量值是否有改变，有改变时，调用指定的函数&lt;/li&gt; &lt;li class="list-group-item"&gt;使用$parse可以手动解析表达式&lt;/li&gt; &lt;li class="list-group-item"&gt; &lt;strong&gt;注意&lt;/strong&gt;:$parse需要以Controller的参数的形式“注入”到控制器中 &lt;/li&gt; &lt;/ul&gt; &lt;div ng-controller="MyController"&gt; &lt;input ng-model="expr" type="text" style="width:300px;" placeholder="请输入一个有效的Angular表达式" /&gt; &lt;h2&gt;&#123;&#123;parsedValue&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script src="../Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="../Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.controller('MyController', function ($scope, $parse) &#123; $scope.whatTimeIs = function () &#123; return new Date().toLocaleTimeString(); &#125; $scope.$watch('expr', function (newValue, oldValue, scope) &#123; console.info(newValue); if (newValue != oldValue) &#123; var parseFunc = $parse(newValue); $scope.parsedValue = parseFunc(scope); &#125; &#125;); &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Scope生命周期 事件循环 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Angular事件的传播&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt; &lt;style&gt; ul, li &#123; margin: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;Angular事件的传播&lt;/h2&gt; &lt;p class="well"&gt; 本例中，控制器使用$scope.$on()方法响应MyEvent事件。 利用ng-repeat这一指令，创建了三层嵌套的Scope，之后， 分别调用$emit()和$broadcast()方法触发一个MyEvent事件， 观察事件在Scope中的传播过程 &lt;/p&gt; &lt;hr /&gt; &lt;div ng-controller="MyController"&gt; 顶层 rootScope &lt;strong&gt;MyEvent&lt;/strong&gt; 激发次数: &#123;&#123;count&#125;&#125; &lt;ul class="list-unstyled"&gt; &lt;li ng-repeat="i in [1]" ng-controller="MyController"&gt; &lt;button class="btn btn-default" ng-click="$emit('MyEvent')"&gt; 中间层触发事件：$emit('MyEvent') &lt;/button&gt; &lt;button class="btn btn-primary" ng-click="$broadcast('MyEvent')"&gt; 中间层广播事件：$broadcast('MyEvent') &lt;/button&gt; &lt;hr /&gt; &lt;p class="text-danger"&gt; 中间层 scope &lt;strong&gt;MyEvent&lt;/strong&gt; 激发次数: &#123;&#123;count&#125;&#125; &lt;/p&gt; &lt;hr /&gt; &lt;ul class="list-unstyled"&gt; &lt;li ng-repeat="item in [1, 2]" ng-controller="MyController" class="text-info"&gt; 最底层 scope&#123;&#123;$index+1&#125;&#125; &lt;strong&gt;MyEvent&lt;/strong&gt; 激发次数: &#123;&#123;count&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.controller('MyController', function ($scope) &#123; $scope.count = 0; //注册事件监听器 $scope.$on('MyEvent', function () &#123; $scope.count++; &#125;); &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;title&gt;基于事件的控制器间通讯&lt;/title&gt; &lt;link href="../Content/bootstrap.min.css" rel="stylesheet" /&gt; &lt;style&gt; div,input&#123; margin:10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body class="container text-center"&gt; &lt;h2&gt;基于事件的控制器间通讯&lt;/h2&gt; &lt;p class="well"&gt; 在本示例中，定义了两个控制器，一个用于发布消息，另一个用于接收消息，消息由事件参数携带。 &lt;/p&gt; &lt;div class="container" ng-app="myModule"&gt; &lt;div ng-controller="PublisherCtl" class="panel panel-default" &gt; &lt;div class="panel-heading"&gt; 事件源(PublisherCtl) &lt;/div&gt; &lt;input class="input-sm" ng-model="info"/&gt; &lt;button class="btn btn-default" ng-click="publish()"&gt;发布消息&lt;/button&gt; &lt;/div&gt; &lt;div ng-controller="SubscriberCtl" class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; 事件响应（SubscriberCtl) &lt;/div&gt; &lt;h3&gt; &lt;strong&gt;收到消息：&lt;/strong&gt; &lt;span class="text-danger"&gt; &#123;&#123;receivedInfo || '没有新的消息'&#125;&#125; &lt;/span&gt; &lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="../Scripts/angular.min.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; 'use strict'; var app = angular.module('myModule', []); app.controller("PublisherCtl", ['$scope', '$rootScope', function ($scope,$rootScope) &#123; $scope.info = ""; $scope.publish = function () &#123; $rootScope.$broadcast('published', &#123; message: $scope.info &#125;); &#125; &#125;]); app.controller("SubscriberCtl", ['$scope', function ($scope) &#123; $scope.$on('published', function (event,data) &#123; console.info(event); $scope.receivedInfo = data.message; &#125;); $scope.receivedInfo = ""; &#125;]); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; AngularJS ServiceAngular Service概述作用 特点 如何使用 自定义Service 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;使用factory()方法创建Service&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;使用factory()方法创建Service&lt;/h2&gt; &lt;p&gt;使用这种方法创建Service，需要准备好一个函数，这个函数返回一个包容属性和方法的匿名对象&lt;/p&gt; &lt;div ng-controller="MyController"&gt; &lt;div class="well" style="font-size:larger"&gt; &lt;p&gt;&#123;&#123;info&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;time&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); //定义Service app.factory('myService', function () &#123; //内部数据 var data = &#123; info: "myService创建的对象" &#125;; //内数函数 var getTime = function () &#123; return new Date().toLocaleTimeString(); &#125;; //供外界使用Singleton对象 return &#123; data: data, //返回内部包容数据对象给外界使用 getTime: getTime //返回内部定义的函数供外界调用 &#125;; &#125;); //使用Service app.controller('MyController', ['$scope', 'myService', function ($scope, myService) &#123; $scope.info = myService.data.info; $scope.time = myService.getTime(); &#125;]); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;使用service()方法创建Service&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;使用service()方法创建Service&lt;/h2&gt; &lt;p&gt;使用这种方法创建Service，需要准备好一个构造函数，Angular在需要时会用new关键字调用它，创建一个Service对象&lt;/p&gt; &lt;div ng-controller="MyController"&gt; &lt;div class="well" style="font-size:larger"&gt; &lt;p&gt;&#123;&#123;info&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;time&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); //定义Service构造函数 var myServiceConstructor = function () &#123; this.data = &#123; info: "myService对象" &#125;; this.getTime = function () &#123; return new Date().toLocaleTimeString(); &#125;; &#125; //定义Service app.service('myService', myServiceConstructor); //使用Service app.controller('MyController', ['$scope', 'myService', function ($scope, myService) &#123; $scope.info = myService.data.info; $scope.time = myService.getTime(); &#125;]); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;div ng-controller="MyCtl"&gt; &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt; &lt;p class="well"&gt;&#123;&#123;description&#125;&#125;&lt;/p&gt; &lt;input type="number" ng-model="score" /&gt; &lt;h4 ng-show="score"&gt;你的考试成绩：&lt;strong class="text-danger"&gt;&#123;&#123;result&#125;&#125;&lt;/strong&gt;&lt;/h4&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); //constant()常用于定义常量 app.constant('constants', &#123; APP_TITLE: 'Service的value()和constant()方法', APP_DESCRIPTION: 'constant()常用于定义常量，value()常用于封装公用函数', &#125;); //value()常用于封装公用函数 app.value('scoreService', &#123; doYouPassed: doYouPassed &#125;); function doYouPassed(score) &#123; if (score &gt;= 60) &#123; return true; &#125; return false; &#125; app.controller('MyCtl', ['$scope', 'constants', 'scoreService', function ($scope, constants, scoreService) &#123; $scope.title = constants.APP_TITLE; $scope.description = constants.APP_DESCRIPTION; $scope.score = 60; //监控score属性的变化 $scope.$watch('score', function (newValue, oldValue, scope) &#123; $scope.result = scoreService.doYouPassed($scope.score) ? "过关了" : "没过关"; console.info($scope.result); &#125;); &#125;]); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 依赖注入与Service 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;跨模块的Service调用&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="myModule"&gt; &lt;h2&gt;跨模块的Service调用&lt;/h2&gt; &lt;p class="well"&gt; 在实际开发中，模块通常被当作AngularJS应用的基本构造块。它们也是代码重用的基本手段。&lt;br /&gt; 在本例中，创建一个common.service的模块，其中注册了一个MathService。&lt;br /&gt; 在另一个模块myModule的控制器中，直接调用MathService。 &lt;/p&gt; &lt;div ng-controller="MyController"&gt; &lt;input type="number" ng-model="num1" /&gt;+&lt;input type="number" ng-model="num2" /&gt; &lt;button class="btn btn-default" ng-click="calculate(num1,num2)"&gt;=&lt;/button&gt; &lt;p class="well text-primary" ng-if="!!result"&gt;&#123;&#123;num1&#125;&#125;+&#123;&#123;num2&#125;&#125;=&#123;&#123;result&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; //定义一个模块common.service，专门用于保存公用代码 var publicApp = angular.module('common.service', []); //将公用代码封装为Service，然后注册到common.service模块中 publicApp.factory('MathService', function () &#123; var add = function (x, y) &#123; return x + y; &#125; return &#123; add: add &#125; &#125;); //在需要使用common.service的模块中，声明对它的依赖 var app = angular.module('myModule', ['common.service']); //现在可以将MathService注入到控制器中 app.controller('MyController', ['$scope', 'MathService', function ($scope, MathService) &#123; $scope.calculate = function (x, y) &#123; $scope.result = MathService.add(x, y); &#125;; &#125;]); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Service应用实例 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$window&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;$window&lt;/h2&gt; &lt;p class="well"&gt; $window是Angular对JavaScript全局对象window的一个封装，其用法与window对象基本一致 &lt;/p&gt; &lt;div ng-controller="MyController"&gt; &lt;button class="btn btn-primary" ng-click="displayAlert()"&gt; 点击我显示alert()消息框 &lt;/button&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.controller('MyController', ['$scope', '$window', function ($scope, $window) &#123; $scope.displayAlert = function (msg) &#123; $window.alert('这是直接调用$window的alert()显示的消息框'); &#125; &#125;]); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$document&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;$document&lt;/h2&gt; &lt;p class="well"&gt; $document是Angular对window.document的一个封装,提供了一些额外的方法以方便使用。 &lt;/p&gt; &lt;div ng-controller="MyController"&gt; &lt;button class="btn btn-primary" ng-click="displayAlert()"&gt; 点击我 &lt;/button&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.controller('MyController', ['$scope', '$window', '$document', function ($scope, $window, $document) &#123; var count=0; var button = $document.find("button"); button.on("click", function (event) &#123; count++; $window.alert("按钮上的文字为：" + event.target.innerText); //修改按钮文本 button.html('点击我：&lt;strong&gt;' + count + '&lt;/strong&gt;'); &#125;); &#125;]); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;使用$location和$anchorScroll实现同页跳转&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;使用$location和$anchorScroll实现同页跳转&lt;/h2&gt; &lt;p class="well"&gt; 在页面给指定的元素定义id，然后，调用$location.hash(id)即可滚动到指定位置。&lt;br /&gt; 如果禁用了自动滚动特性，则可以在设定完hash值之后，手工调用$anchorScroll();方法进行强制滚动。 &lt;/p&gt; &lt;div ng-controller="MyController"&gt; &lt;div class="panel panel-default"&gt; &lt;h4 class="panel-heading"&gt;URL&lt;/h4&gt; &lt;div class="panel-body"&gt; &lt;p id="top"&gt;这是开头&lt;/p&gt; &lt;button class="btn btn-primary" ng-click="show('bottom')"&gt; 跳到结尾 &lt;/button&gt; &lt;p&gt; &lt;ul class="list-unstyled"&gt; &lt;li ng-repeat="item in items"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; &lt;p id="bottom"&gt;这是结尾&lt;/p&gt; &lt;button class="btn btn-primary" ng-click="show('top')"&gt;跳到开头&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.controller('MyController', ['$scope', '$location', '$anchorScroll', function ($scope,$location,$anchorScroll) &#123; $scope.itemCount = 50; $scope.items = []; for (var i = 0; i &lt; $scope.itemCount; i++) &#123; $scope.items[i] = "Item " + i; &#125; $scope.show = function (id) &#123; $location.hash(id); $anchorScroll(); &#125; //初始状态时，是显示开头 $location.hash('top'); &#125;]); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$timeout的使用示例&lt;/title&gt; &lt;link href="../Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2 &gt;$timeout的使用示例&lt;/h2&gt; &lt;p class="well"&gt;$timeout是对window.setTimeout()方法的封装。采用递归调用的方式实现定时刷新。&lt;/p&gt; &lt;div ng-controller="MyController"&gt; &lt;h2&gt;&lt;strong&gt;&#123;&#123;clock.now&#125;&#125;&lt;/strong&gt;&lt;/h2&gt; &lt;/div&gt; &lt;script src="../Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; function MyContorller($scope, $timeout) &#123; $scope.clock = &#123; now: new Date().toLocaleTimeString() &#125;; //采用递归调用的方式实现定时刷新 var updateClock = function () &#123; $scope.clock.now = new Date().toLocaleTimeString() $timeout(function () &#123; //递归调用updateClock $scope.$apply(updateClock); &#125;, 1000); &#125;; updateClock(); &#125;; angular.module('app', []) .controller('MyController', MyContorller); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$interval的使用示例&lt;/title&gt; &lt;link href="../Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;$interval的使用示例&lt;/h2&gt; &lt;p class="well"&gt;$interval是对window.setInterval()方法的封装。&lt;/p&gt; &lt;div ng-controller="MyController"&gt; &lt;h2&gt;&lt;strong&gt;&#123;&#123;time&#125;&#125;&lt;/strong&gt;&lt;/h2&gt; &lt;/div&gt; &lt;script src="../Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; function MyContorller($scope, $interval) &#123; $interval(function () &#123; $scope.time = new Date().toLocaleTimeString(); &#125;, 1000); &#125;; angular.module('app', []) .controller('MyController',['$scope','$interval', MyContorller]); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;基于Service实现数据的跨控制器传送&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;基于Service实现数据的跨控制器传送&lt;/h2&gt; &lt;p class="well"&gt;Service是单实例对象，因此，它能成为各Controller之间交换数据的公用存储区&lt;/p&gt; &lt;div ng-controller="FirstCtl"&gt; &lt;h3&gt;控制器FirstCtl&lt;/h3&gt; &lt;input type="text" ng-model="data.message" /&gt; &lt;/div&gt; &lt;hr /&gt; &lt;div ng-controller="SecondCtl"&gt; &lt;h3&gt;控制器SecondCtl&lt;/h3&gt; &lt;h4&gt;收到第一个控制器传来的数据：&lt;strong class="text-warning"&gt;&#123;&#123;data.message || '没有数据'&#125;&#125;&lt;/strong&gt;&lt;/h4&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); //Data Service用于保存需要在各个Controller间共享的信息 app.factory('Data', function () &#123; return &#123; message: "" &#125; &#125;); app.controller('FirstCtl', function ($scope,Data) &#123; $scope.data = Data; &#125;); app.controller('SecondCtl', function ($scope,Data) &#123; $scope.data = Data; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;示例：购物车&lt;/h2&gt; &lt;p class="well"&gt;本实例使用Service实现Controller之间的合作&lt;/p&gt; &lt;div class="row"&gt; &lt;div class="col-xs-8" ng-controller="BookController"&gt; &lt;h4&gt;可选的书&lt;/h4&gt; &lt;table class="table table-striped table-hover table-condensed"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;&amp;nbsp;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tr ng-repeat="book in booklist" ng-hide="book.selected"&gt; &lt;td&gt; &#123;&#123;book.name&#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123;book.author&#125;&#125; &lt;/td&gt; &lt;td&gt; &#123;&#123;book.price|currency&#125;&#125; &lt;/td&gt; &lt;td&gt; &lt;button class="btn btn-primary btn-xs" ng-click="selectBook(book)"&gt;Select&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class="col-xs-4 " ng-controller="ShoppingCartController"&gt; &lt;h4 class="text-info"&gt;选中的书:&lt;strong&gt;&#123;&#123;selectBooks.length&#125;&#125;&lt;/strong&gt;&lt;/h4&gt; &lt;div ng-if="selectBooks.length&gt;0" class="well"&gt; &lt;div class="row" ng-repeat="book in selectBooks"&gt; &lt;div class="col-md-12 "&gt; &lt;a href=""&gt;《&#123;&#123;book.name&#125;&#125;》&#123;&#123;book.price | currency&#125;&#125; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.service('bookService', function () &#123; var books = [&#123; name: '用AngularJS开发下一代Web应用', author: 'Brad Green，Sbyam Sesbadri', price: 40.9, selected: false &#125;, &#123; name: '精通AngularJS', author: 'Pawel Kozlowski，Peter Bacon Darwin ', price: 57.10, selected: false &#125;, &#123; name: 'AngularJS权威教程 ', author: 'Ari Lerner', price: 81.00, selected: false &#125;, &#123; name: 'Node.js+MongoDB+AngularJS Web开发 ', author: 'Brad Dayley', price: 75.10, selected: false &#125;, ]; return &#123; books: books &#125;; &#125;); //shoppingCart是一个Service,它用于保存用户选择的书 app.service('shoppingCart', function () &#123; var selectBooks = []; var selectBook = function (book) &#123; selectBooks.push(book); &#125;; return &#123; selecBook: selectBook, selectBooks: selectBooks &#125; &#125;); //BookController实现显示可选择书列表和选择书的功能 app.controller('BookController', function ($scope, bookService, shoppingCart) &#123; $scope.booklist = bookService.books; $scope.selectBook = function (book) &#123; book.selected = true; shoppingCart.selecBook(book); &#125; &#125;); //ShoppingCartController负责将购物车中的书显示在页面上 //日后还可以添加移除书，计算总价等功能 app.controller('ShoppingCartController', function ($scope, shoppingCart) &#123; $scope.selectBooks = shoppingCart.selectBooks; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 自定义指令自定义指令基础指令的分类 指令放在的地方 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;transclude示例&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;transclude示例&lt;/h2&gt; &lt;p class="well"&gt;使用ng-transclude指令，可以让自定义指令所包围的HTML代码，出现在指定的位置&lt;/p&gt; &lt;div ng-controller="MyController"&gt; &lt;my-dialog&gt; &lt;h2&gt; name&amp;nbsp;=&amp;nbsp; &lt;strong class="text-danger"&gt;&#123;&#123;name&#125;&#125;&lt;/strong&gt; &lt;/h2&gt; &lt;/my-dialog&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.controller('MyController', function ($scope) &#123; $scope.name = '张三'; &#125;); app.directive('myDialog', function () &#123; return &#123; restrict: 'E', transclude: true, template: '&lt;div class="alert" ng-transclude&gt;&lt;/div&gt;' &#125;; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 链接函数（Link Function） 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;链接函数&lt;/h2&gt; &lt;p class="well"&gt;所谓“链接函数”,实际上就是把文档中的HTML元素与scope中的数据关联起来，把DOM操作封装到指令内部。&lt;/p&gt; &lt;div&gt; &lt;p&gt;这是一个普通段落&lt;/p&gt; &lt;p high-light&gt;这是一个通过链接函数实现高亮的段落&lt;/p&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.directive('highLight', function () &#123; return &#123; restrict: 'A', link: function (scope, element, attrs) &#123; element.css("color", "red"); &#125; &#125;; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Link Function示例&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;Link Function示例&lt;/h2&gt; &lt;p&gt;使用自定义指令设定元素的mouseenter和mouseleave事件响应函数&lt;/p&gt; &lt;div&gt; &lt;div style="width:400px;height:200px; margin:30px auto;border:solid black 1px" enter="well" leave &gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.directive('enter', function () &#123; return function (scope, element, attrs) &#123; //鼠标移入时，添加特定的样式 element.bind('mouseenter', function () &#123; element.addClass(attrs.enter); &#125;); &#125; &#125;); app.directive('leave', function () &#123; return function (scope, element, attrs) &#123; //鼠标离开时，移除移入时添加的样式 element.bind('mouseleave', function () &#123; element.removeClass(attrs.enter); &#125;); &#125; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;支持拖动的元素&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;div ng-controller="MyController"&gt; &lt;h2&gt;支持拖动的元素&lt;/h2&gt; &lt;p class="well"&gt; 通过向指令中注入$document，我们可以在Link Function中响应DOM事件。 &lt;/p&gt; &lt;span my-draggable&gt;Drag ME&lt;/span&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.controller('MyController', function ($scope) &#123; &#125;); app.directive('myDraggable', ['$document', function ($document) &#123; return &#123; link: function (scope, element, attr) &#123; var startX = 0, startY = 0, x = 0, y = 0; element.css(&#123; position: 'relative', border: '1px solid red', backgroundColor: 'lightgrey', cursor: 'pointer' &#125;); element.on('mousedown', function (event) &#123; //鼠标按下时，初始化相关变量，挂接相应的事件 event.preventDefault(); startX = event.pageX - x; startY = event.pageY - y; $document.on('mousemove', mousemove); $document.on('mouseup', mouseup); &#125;); //鼠标移动时，通过修改样式移动元素 function mousemove(event) &#123; y = event.pageY - startY; x = event.pageX - startX; element.css(&#123; top: y + 'px', left: x + 'px' &#125;); &#125; //鼠标松开时，移除所有事件响应的代码 function mouseup() &#123; $document.off('mousemove', mousemove); $document.off('mouseup', mouseup); &#125; &#125; &#125; &#125; ]); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 自定义指令中的控制器 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;在自定义指令中封装控制器&lt;/h2&gt; &lt;p class="well"&gt; 通过在定义指令时，添加controller属性，就可将一个控制器封装到指令内部 &lt;/p&gt; &lt;my-directive&gt;&lt;/my-directive&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.directive('myDirective', function () &#123; return &#123; restrict: 'E', replace: true, template: "&lt;div&gt;&lt;h3 class='text-warning'&gt;&#123;&#123;info&#125;&#125;&lt;/h3&gt;" + "&lt;button class='btn btn-primary' ng-click='say()'&gt;" + "单击时，调用内部控制器中的方法&lt;/button&gt;&lt;/div&gt;", controller: function ($scope) &#123; $scope.info = "这是封装在指令内部控制器中的属性"; $scope.say = function () &#123; alert("Hello,World."); &#125;; &#125; &#125;; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;指令与控制器间的通讯&lt;/h2&gt; &lt;p&gt;指令链接函数有一个Scope参数，可以用于访问外部Controller关联的Scope对象&lt;/p&gt; &lt;div ng-controller="MyController"&gt; &lt;div class="row"&gt; &lt;p class="well col-xs-6" my-directive="showTime()"&gt; 鼠标移入，显示当前时间 &lt;/p&gt; &lt;p class="well col-xs-6" my-directive="calculate(1,2)"&gt; 鼠标移入，显示1+2的计算结果 &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.controller('MyController', function ($scope) &#123; $scope.showTime = function () &#123; return new Date().toLocaleTimeString(); &#125; $scope.calculate = function (x,y) &#123; return x + y; &#125; &#125;); app.directive('myDirective', function () &#123; return function (scope, element, attrs) &#123; element.bind('mouseenter', function () &#123; //这里的scope，引用的是外部controller中的scope element.text(scope.$eval(attrs.myDirective)); &#125;); &#125; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="../Content/bootstrap.css" rel="stylesheet" /&gt; &lt;link href="../Content/bootstrap-theme.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="myModule"&gt; &lt;h2&gt;事件在两条指令控制器之间的传播&lt;/h2&gt; &lt;p class="well"&gt; 示例中的圆和矩形，都是由SVG实现的。 点击圆，会让矩形变大，再点击，则还原。 &lt;/p&gt; &lt;div my-circle&gt;&lt;/div&gt; &lt;my-rectangle&gt;&lt;/my-rectangle&gt; &lt;script src="../Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; 'use strict'; var app = angular.module('myModule', []); app.directive('myCircle', function () &#123; return &#123; templateUrl: 'my_circle.html', replace: true, link: function (scope, element, attrs) &#123; element.on('click', function () &#123; scope.$apply(function () &#123; scope.afterClick(); &#125;); &#125;) &#125;, controller: ['$scope', '$rootScope', function ($scope, $rootScope) &#123; $scope.afterClick = function () &#123; $rootScope.$broadcast('clicked'); &#125; &#125;] &#125;; &#125;); app.directive('myRectangle', function () &#123; return &#123; templateUrl: 'my_rectangle.html', restrict: 'E', replace: true, controller: ['$scope', function ($scope) &#123; $scope.$on('clicked', function () &#123; $scope.clicked = !($scope.clicked); &#125;) &#125;] &#125; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123&lt;svg height="100" width="100"&gt; &lt;circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red"/&gt;&lt;/svg&gt; 12345&lt;svg height="&#123;&#123;clicked ? 220 : 120&#125;&#125;" width="&#123;&#123;clicked ? 420 : 320&#125;&#125;"&gt; &lt;rect x="10" y="10" width="&#123;&#123;clicked ? 400 : 300&#125;&#125;" height="&#123;&#123;clicked ? 200 : 100&#125;&#125;" stroke="red" fill="#ccc" /&gt;&lt;/svg&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;指令与指令之间的通讯&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;指令与指令之间的通讯&lt;/h2&gt; &lt;p class="well"&gt; 通过指定require属性，可以让一条指令“依赖”于另一条指令，它们共享相同的scope，并且能调用被依赖方的控制器中定义的方法&lt;/p&gt; &lt;div ng-controller="MyController"&gt; &lt;!-- 父子指令 --&gt; &lt;my-directive my-child-directive&gt; &lt;/my-directive&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.controller('MyController', function ($scope) &#123; &#125;); app.directive('myDirective', function () &#123; return &#123; restrict: 'E', link: function (scope, element, attrs) &#123; element.html('&lt;h4&gt;自定义指令&lt;/h4&gt;'); &#125;, controller: function ($scope) &#123; //以this添加的成员，直接属于controller对象 this.getTime = function () &#123; return new Date().toLocaleTimeString(); &#125; this.message = "Hello!"; //在这里添加的属性，被所有指令所共享 $scope.info = "info in $scope"; &#125; &#125; &#125;); app.directive('myChildDirective', function () &#123; return &#123; restrict: 'A', //指明本指令必须放在myDirective指令内部，或者是其上级是myDirective require: '^myDirective', //link函数还可以第4个参数，这个参数引用父指令中的控制器 link: function (scope, element, attrs, ctl) &#123; element.append('&lt;br/&gt;访问myDirective指令控制器中的方法：现在时间是&lt;strong&gt;' + ctl.getTime() + "&lt;strong&gt;"); element.append('&lt;br/&gt;访问myDirective指令控制器中的属性：' + ctl.message); element.append('&lt;br/&gt;访问$scope中的属性：' + scope.info); &#125; &#125; &#125;) &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Angular指令与编译过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$compile&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt; &lt;style&gt; div&#123; margin:5px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;$compile&lt;/h2&gt; &lt;p class="well"&gt; 使用$compile可以动态地编译包容Angular数据绑定表达式的HTML代码，并将其追加到页面上 &lt;/p&gt; &lt;div ng-controller="MyController"&gt; &lt;!-- 用于附加新元素的容器 --&gt; &lt;div id="appendHere" class="well" ng-show="hasConent"&gt;&lt;/div&gt; &lt;br /&gt; &lt;div class="row"&gt; &lt;span class="col-xs-2 col-xs-offset-2"&gt;数据绑定变量name:&lt;/span&gt; &lt;input class="col-xs-6" type="text" ng-model="name" /&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;span class="col-xs-2 col-xs-offset-2"&gt;HTML标记:&lt;/span&gt; &lt;input class="col-xs-6" type="text" ng-model="markup" /&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;button class="btn btn-primary col-xs-2 col-xs-offset-8" ng-click="appendDivToElement(markup,'appendHere')"&gt; 追加 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); //向链接函数注入$compile，把HTML与$scope关联起来，然后，追加到DOM树中。 app.controller('MyController', ['$scope', '$compile', function ($scope, $compile) &#123; $scope.appendDivToElement = function (markup, targetElemID) &#123; if (!!markup) &#123; $scope.hasConent = true; $compile(markup)($scope) .appendTo(angular.element('#' + targetElemID)); &#125; &#125; &#125;]); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 指令与作用域 Scope之间的三种关联类型 共享的scope 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;shared scope(共享的Scope)&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;shared scope(共享的Scope)&lt;/h2&gt; &lt;p class="well"&gt; 默认情况下，自定义指令与放置它的元素（或包容它的上层元素）共享相同的scope，因此，在自定义指令内部修改scope中的数据，会影响到所有关联此scope的各种对象。&lt;br /&gt; 在本例中，在页面上放置了两个自定义的指令，它们与控制器共享同一个scope。 &lt;/p&gt; &lt;div class="row" ng-controller="MyController"&gt; &lt;div class="col-xs-8"&gt; &lt;h4&gt;当前标题：&#123;&#123;title&#125;&#125;&lt;/h4&gt; 修改标题：&lt;input ng-model="title" /&gt; &lt;h3&gt; people中的对象个数：&#123;&#123;people.length&#125;&#125; &lt;/h3&gt; &lt;/div&gt; &lt;!-- 放置两个自定义指令 --&gt; &lt;div class="col-xs-4"&gt; &lt;my-element /&gt; &lt;/div&gt; &lt;div class="col-xs-12"&gt; &lt;my-element /&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.directive('myElement', function () &#123; return &#123; restrict: 'E', templateUrl: 'PersonTemplate.html' &#125; &#125;); app.controller('MyController', function ($scope) &#123; $scope.title = "MyController title"; $scope.people = [ &#123; id: 1, name: '张三' &#125;, &#123; id: 2, name: '李四' &#125;, &#123; id: 3, name: '王五' &#125; ]; $scope.addPerson = function () &#123; var id = $scope.people.length; var newPerson = &#123; id: id, name: '新Person' + id &#125;; $scope.people.push(newPerson); &#125; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789&lt;div class="well"&gt; 标题:&lt;input ng-model="title" /&gt; &lt;h3&gt; people中的对象个数：&#123;&#123;people.length&#125;&#125; &lt;/h3&gt; &lt;button class="btn btn-primary" ng-click="addPerson()"&gt;Add Person&lt;/button&gt;&lt;/div&gt; 继承的scope 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;inherited scope(继承的Scope)&lt;/h2&gt; &lt;p class="well"&gt; 当给自定义指令指定scope=true，就创建了继承的scope。&lt;br /&gt; 上层Scope中“对象”类型的属性被下层的scope所共享，但诸如字符串等“简单”属性，下层scope会创建其副本。 &lt;/p&gt; &lt;div class="row" ng-controller="MyController"&gt; &lt;div class="col-xs-8"&gt; &lt;h4&gt;当前标题：&#123;&#123;title&#125;&#125;&lt;/h4&gt; 修改标题：&lt;input ng-model="title" /&gt; &lt;h3&gt; people中的对象个数：&#123;&#123;people.length&#125;&#125; &lt;/h3&gt; &lt;/div&gt; &lt;div class="col-xs-4"&gt; &lt;my-element /&gt; &lt;/div&gt; &lt;div class="col-xs-12"&gt; &lt;my-element /&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.directive('myElement', function () &#123; return &#123; restrict: 'E', templateUrl: 'PersonTemplate.html', scope:true &#125; &#125;); app.controller('MyController', function ($scope) &#123; $scope.title = "MyController title"; $scope.people = [ &#123; id: 1, name: '张三' &#125;, &#123; id: 2, name: '李四' &#125;, &#123; id: 3, name: '王五' &#125; ]; $scope.addPerson = function () &#123; var id = $scope.people.length; var newPerson = &#123; id: id, name: '新Person' + id &#125;; $scope.people.push(newPerson); &#125; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;ngRepeat生成的scope&lt;/h2&gt; &lt;div class="row"&gt; &lt;p class="well col-xs-8 col-xs-offset-2"&gt;ngRepeat在创建HTML元素时，会为生成的每一批元素，构建一个scope，这些Scope构成继承关系&lt;/p&gt; &lt;/div&gt; &lt;div ng-controller="MyController"&gt; &lt;div class="row"&gt; &lt;ul class="list-group list-unstyled col-xs-8 col-xs-offset-2"&gt; &lt;li class="list-group-item" ng-repeat="person in people"&gt; &#123;&#123;person.id&#125;&#125;:&#123;&#123;person.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.controller('MyController', function ($scope) &#123; $scope.people = [ &#123; id: 1, name: '张三' &#125;, &#123; id: 2, name: '李四' &#125;, &#123; id: 3, name: '王五' &#125; ]; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;使用隔离作用域&lt;/title&gt; &lt;link href="../Content/bootstrap.css" rel="stylesheet" /&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;使用隔离作用域&lt;/h2&gt; &lt;p class="well"&gt;设置自定义指令的scope属性引用一个匿名对象，就创建了隔离作用域，放在页面上的多条指令，彼此互不影响&lt;/p&gt; &lt;div ng-controller="MyController"&gt; &lt;div my-directive my-url="http://www.baidu.com" my-link-text="访问百度"&gt; &lt;/div&gt; &lt;br /&gt; &lt;my-directive my-url="http://www.jinxuliang.com" my-link-text="访问金老师的教学网站"&gt; &lt;/my-directive&gt; &lt;/div&gt; &lt;script src="../Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="../Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); //使用隔离作用域从HTML属性中提取值 app.directive('myDirective', function () &#123; return &#123; restrict: 'EA', replace: true, //隔离作用域，每个指令都有一个，互不影响 scope: &#123; myUrl: '@', //从my-url属性中提取值 myLinkText: '@' //从my-link-text属性中提取值 &#125;, //使用隔离作用域中的属性，生成HTML代码 template: '&lt;a href="&#123;&#123;myUrl&#125;&#125;"&gt;' + '&#123;&#123;myLinkText&#125;&#125;&lt;/a&gt;' &#125;; &#125;); app.controller('MyController', function ($scope) &#123; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;隔离作用域"@"的作用&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt; &lt;style&gt; h4 &#123; color:brown;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;隔离作用域中“@”的作用&lt;/h2&gt; &lt;p class="well" ng-non-bindable&gt; 当给自定义指令指定scope=&#123;&#125;，就创建了隔离的scope。其中定义的属性，可以引用到外部scope中的数据&lt;br /&gt; 在隔离作用域中使用“@”定义属性，则页面上使用自定义指令的地方，其属性表达式中需要使用&#123;&#123;&#125;&#125;。&lt;br /&gt; 自定义指令中的代码对属性值的修改，不会影响到外部scope中的相应属性。&lt;br /&gt; 所以，“@”实际上是在隔离scope和外部scope之间建立了一种&lt;strong class="text-danger"&gt;“单向”&lt;/strong&gt;的绑定关系。 &lt;/p&gt; &lt;div class="row" ng-controller="MyController"&gt; &lt;div class="col-xs-8"&gt; &lt;h4&gt;当前标题：&#123;&#123;title&#125;&#125;&lt;/h4&gt; 修改标题：&lt;input ng-model="title" /&gt; &lt;h3&gt; people中的对象个数：&#123;&#123;people.length&#125;&#125; &lt;/h3&gt; &lt;/div&gt; &lt;div class="col-xs-4"&gt; &lt;h4&gt;因为在HTML代码中设定了title,datasrc和invoke属性，所以此自定义指令能正常地工作&lt;/h4&gt; &lt;!-- 自定义指令title用到的是"@",则表达式中需要使用&#123;&#123;&#125;&#125; --&gt; &lt;my-element title='&#123;&#123;title&#125;&#125;' datasrc="people" invoke="addPerson()" /&gt; &lt;/div&gt; &lt;div class="col-xs-12"&gt; &lt;h4&gt;因为没有指定任何的属性，所以此自定义指定什么也不显示&lt;/h4&gt; &lt;my-element /&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.directive('myElement', function () &#123; return &#123; restrict: 'E', templateUrl: 'PersonTemplate.html', scope: &#123; title: '@', //单向绑定，其修改不会影响到外部scope的同名属性 people: '=datasrc', //引用外部scope数据源，是共享的 addPerson: '&amp;invoke' //调用外部scope中的方法 &#125; &#125; &#125;); app.controller('MyController', function ($scope) &#123; $scope.title = "MyController title"; $scope.people = [ &#123; id: 1, name: '张三' &#125;, &#123; id: 2, name: '李四' &#125;, &#123; id: 3, name: '王五' &#125; ]; $scope.addPerson = function () &#123; var id = $scope.people.length; var newPerson = &#123; id: id, name: '新Person' + id &#125;; $scope.people.push(newPerson); &#125; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;隔离作用域中“=”的作用&lt;/title&gt; &lt;link href="/Content/bootstrap.css" rel="stylesheet" /&gt; &lt;style&gt; h4 &#123; color:brown;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body class="container text-center" ng-app="app"&gt; &lt;h2&gt;隔离作用域中“=”的作用&lt;/h2&gt; &lt;p class="well" ng-non-bindable&gt; 在隔离作用域中使用“=”定义属性，则页面上使用自定义指令的地方，其属性表达式中不要使用&#123;&#123;&#125;&#125;。&lt;br /&gt; 自定义指令中的代码对属性值的修改，&lt;strong class="text-danger"&gt;“会”&lt;/strong&gt;影响到外部scope中的相应属性。&lt;br /&gt; 所以，“=”实际上是在隔离scope和外部scope之间建立了一种&lt;strong class="text-danger"&gt;“双向”&lt;/strong&gt;的绑定关系。 &lt;/p&gt; &lt;div class="row" ng-controller="MyController"&gt; &lt;div class="col-xs-8"&gt; &lt;h4&gt;当前标题：&#123;&#123;title&#125;&#125;&lt;/h4&gt; 修改标题：&lt;input ng-model="title" /&gt; &lt;h3&gt; people中的对象个数：&#123;&#123;people.length&#125;&#125; &lt;/h3&gt; &lt;/div&gt; &lt;div class="col-xs-4"&gt; &lt;!-- 如果自定义指令title用到的是"=",则使用此句 --&gt; &lt;my-element title='title' datasrc="people" invoke="addPerson()" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="/Scripts/jquery-2.1.4.js"&gt;&lt;/script&gt; &lt;script src="/Scripts/angular.js"&gt;&lt;/script&gt; &lt;script&gt; (function () &#123; var app = angular.module('app', []); app.directive('myElement', function () &#123; return &#123; restrict: 'E', templateUrl: 'PersonTemplate.html', scope: &#123; title:'=', //双向绑定，其修改会影响到外部scope people: '=datasrc', //引用外部scope数据源，是共享的 addPerson:'&amp;invoke' //调用外部scope中的方法 &#125; &#125; &#125;); app.controller('MyController', function ($scope) &#123; $scope.title = "MyController title"; $scope.people = [ &#123; id: 1, name: '张三' &#125;, &#123; id: 2, name: '李四' &#125;, &#123; id: 3, name: '王五' &#125; ]; $scope.addPerson = function () &#123; var id = $scope.people.length; var newPerson = &#123; id: id, name: '新Person' + id &#125;; $scope.people.push(newPerson); &#125; &#125;); &#125;()); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端框架</category>
        <category>AngularJS</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PLINQ初识]]></title>
    <url>%2F2019%2F05%2F07%2FPLINQ%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[并行linq计算 概述 并行查询是如何查询 如何在开发中是使用PLINQ PINQ基础编程技巧 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556namespace WhoIsFaster&#123; class Program &#123; static int[] arr = Enumerable.Range(1000000000, 100000).ToArray(); static void Main(string[] args) &#123; Measure("串行算法", () =&gt; &#123; bool[] results = new bool[arr.Length]; for (int i = 0; i &lt; arr.Length; i++) results[i] = IsPrime(arr[i]); &#125;); Measure("LINQ to Objects 查询", () =&gt; &#123; bool[] results = (from num in arr select IsPrime(num)).ToArray(); &#125;); Measure("PLINQ 查询", () =&gt; &#123; bool[] results = (from num in arr.AsParallel() select IsPrime(num)).ToArray(); &#125;); Console.ReadKey(); &#125; /// &lt;summary&gt; /// 某数是否是质数 /// &lt;/summary&gt; /// &lt;param name="x"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; static bool IsPrime(long x) &#123; if (x &lt;= 2) return x == 2; if (x % 2 == 0) return false; long sqrtx = (long)Math.Ceiling(Math.Sqrt(x)); for (long i = 3; i &lt;= sqrtx; i += 2) &#123; if (x % i == 0) return false; &#125; return true; &#125; static void Measure(string methodName, Action method) &#123; Console.WriteLine("---------------------"); Stopwatch timer = new Stopwatch(); timer.Start(); method(); timer.Stop(); Console.WriteLine("&#123;0&#125;执行了&#123;1&#125;毫秒", methodName, timer.ElapsedMilliseconds); Console.WriteLine("---------------------\n"); &#125; &#125;&#125; 查询的并行串行混合执行模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133namespace AsParallelAndAsSequential&#123; class Program &#123; static List&lt;Student&gt; students = null; /// &lt;summary&gt; /// 创建示例学生数据 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; static List&lt;Student&gt; GetStudents() &#123; List&lt;Student&gt; students = new List&lt;Student&gt;(); Random ran = new Random(); for (int i = 0; i &lt; 100; i++) &#123; students.Add(new Student &#123; Name = "学生" + i.ToString(), Score = ran.Next(1, 100) &#125;); &#125; return students; &#125; static void Main(string[] args) &#123; students = GetStudents(); // LINQVersion(); //PLINQVersion(); PLINQAsSequential(); Console.ReadKey(true); &#125; /// &lt;summary&gt; /// 普通的LINQ查询，顺序执行 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private static void LINQVersion() &#123; Console.WriteLine("串行执行的LINQ版本\n"); int counter = 0;//计数器 var query = from student in students where student.Score &gt; 60 //分数大于60 orderby student.Score descending //按成绩降序排序 select new //返回学生信息 &#123; TempID = ++counter, //名次 student.Name, student.Score &#125;; //输出处理结果 foreach (var item in query) &#123; Console.WriteLine("&#123;0&#125;: 姓名=\"&#123;1&#125;\" 成绩=&#123;2&#125;", item.TempID, item.Name, item.Score); &#125; &#125; /// &lt;summary&gt; /// 全并行执行的PLINQ版本 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private static void PLINQVersion() &#123; Console.WriteLine("全并行执行的PLINQ版本\n"); int counter = 0;//计数器 var query = from student in students.AsParallel() where student.Score &gt; 60 //分数大于60 orderby student.Score descending //按成绩降序排序 select new //返回学生信息 &#123; TempID = ++counter, //名次 student.Name, student.Score &#125;; //输出处理结果 foreach (var item in query) &#123; Console.WriteLine("&#123;0&#125;: 姓名=\"&#123;1&#125;\" 成绩=&#123;2&#125;", item.TempID, item.Name, item.Score); &#125; &#125; /// &lt;summary&gt; /// PLINQ修正版：先并行查询取出数据之后，再顺序执行 /// &lt;/summary&gt; private static void PLINQAsSequential() &#123; int counter = 0; //修正版，直接使用扩展方法而非PLINQ查询语句 var query = students.AsParallel() //使用并行查询 .Where(student =&gt; student.Score &gt; 60) //分数大于60 .OrderByDescending(stu =&gt; stu.Score) //按成绩降序排序 .AsSequential() //强制转换为串行执行 .Select(studentInfo =&gt; new &#123; TempID = ++counter, //名次 studentInfo.Name, studentInfo.Score &#125;); //输出处理结果 foreach (var item in query) &#123; Console.WriteLine("&#123;0&#125;: 姓名=\"&#123;1&#125;\" 成绩=&#123;2&#125;", item.TempID, item.Name, item.Score); &#125; &#125; &#125; /// &lt;summary&gt; /// 学生信息 /// &lt;/summary&gt; class Student &#123; /// &lt;summary&gt; /// 姓名 /// &lt;/summary&gt; public string Name; /// &lt;summary&gt; /// 考试成绩 /// &lt;/summary&gt; public int Score; &#125;&#125; ASOrdered() 和AsSequential()一样么？ 并行统计 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859namespace UseAggregateFunc&#123; class Program &#123; static void Main(string[] args) &#123; //生成测试数据 int[] source = new int[10]; Random rand = new Random(); for (int x = 0; x &lt; source.Length; x++) &#123; source[x] = rand.Next(1, 10); &#125; //输出原始数据： Console.WriteLine("要计算方差的原始数据为(共&#123;0&#125;个）：", source.Length); foreach (int num in source) &#123; Console.Write("&#123;0&#125; ",num); &#125; Console.WriteLine(); //计算平均值 double mean = source.AsParallel().Average(); Console.WriteLine("\n总体数据平均值=&#123;0&#125;", mean); Console.WriteLine("============================="); //并行执行的聚合函数 double VariantOfPopulation = source.AsParallel().Aggregate( 0.0, //聚合变量初始值,此值将会被传给每个数据分区 //针对每个分区的每个数据项调用此函数，第一个参数就是本分区聚合变量， //最初的值由Aggregate()方法的第一个参数确定 //第2个参数代表本分区中的每个数据对象 //返回值代表本分区处理结果 (aggValue, number) =&gt; &#123; double result = aggValue + Math.Pow((number - mean), 2); Console.WriteLine("线程&#123;0&#125;调用updateAccumulatorFunc:累加值=&#123;1&#125;,处理数据：&#123;2&#125;,返回值=&#123;3&#125;", Thread.CurrentThread.ManagedThreadId, aggValue, number, result); return result; &#125;, //针对分区处理结果调用此函数，第一个参数的初始值是第一个分区的处理结果， //第二个参数代表下一个分区的处理结果， //返回值成为此方法第二次调用的第一个参数值 //有n个分区，此方法将会被执行n-1次 (aggValue, thisDataPartition) =&gt; &#123; double result = aggValue + thisDataPartition; Console.WriteLine("\n线程&#123;0&#125;调用combineAccumulatorsFunc:分区累加值=&#123;1&#125;,本分区结果=&#123;2&#125;,返回值=&#123;3&#125;", Thread.CurrentThread.ManagedThreadId, aggValue, thisDataPartition, result); return result; &#125;, //最后的加工，得到最终结果 (result) =&gt; result / source.Length ); Console.WriteLine("\n============================="); Console.WriteLine("数据的方差为：&#123;0&#125;", VariantOfPopulation); Console.ReadKey(); &#125; &#125;&#125; 中途取消PLINQ操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354namespace PLINQCancel&#123; class Program &#123; static void Main(string[] args) &#123; int[] source = Enumerable.Range(1, 10000000).ToArray(); CancellationTokenSource cts = new CancellationTokenSource(); //在另一个线程中取消操作 Task.Factory.StartNew(() =&gt; &#123; CancelPLINQ(cts); &#125;); //在主线程中启动并行查询 int[] results = null; try &#123; results = (from num in source.AsParallel() .WithCancellation(cts.Token) where num % 3 == 0 orderby num descending select num).ToArray(); &#125; catch (OperationCanceledException e) &#123; //如果操作被取消 Console.WriteLine(e.Message); &#125; catch (AggregateException ae) &#123; //如果执行过程中出现未捕获的异常 if (ae.InnerExceptions != null) &#123; foreach (Exception e in ae.InnerExceptions) Console.WriteLine(e.Message); &#125; &#125; Console.WriteLine(); Console.ReadKey(); &#125; /// &lt;summary&gt; /// 随机休眠一个很短的时间，然后马上发出取消PLINQ查询操作的命令 /// &lt;/summary&gt; /// &lt;param name="cs"&gt;&lt;/param&gt; static void CancelPLINQ(CancellationTokenSource cts) &#123; Random rand = new Random(); Thread.Sleep(rand.Next(150, 350)); cts.Cancel(); &#125; &#125;&#125; 自适应策略]]></content>
      <categories>
        <category>.NET Framework</category>
        <category>多线程、Socket、异步编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>LINQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步编程指南]]></title>
    <url>%2F2019%2F05%2F05%2F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[Async await 异步编程 方法的异步调用 理解await 异步方法与线程 1234567891011121314151617181920212223242526272829303132333435363738394041424344namespace AsyncAndThread&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine("进入Main()方法，执行线程ID:&#123;0&#125;,来自线程池?&#123;1&#125;,是背景线程?&#123;2&#125;", Thread.CurrentThread.ManagedThreadId, Thread.CurrentThread.IsThreadPoolThread, Thread.CurrentThread.IsBackground); TestDoWorkAsync(); Console.WriteLine("\n返回Main()方法，等待用户敲任意键退出。执行线程ID:&#123;0&#125;,来自线程池?&#123;1&#125;,是背景线程?&#123;2&#125;", Thread.CurrentThread.ManagedThreadId, Thread.CurrentThread.IsThreadPoolThread, Thread.CurrentThread.IsBackground); Console.ReadKey(); &#125; private async static Task TestDoWorkAsync() &#123; Console.WriteLine("\n进入TestDoWorkAsync()方法，await语句之前的代码执行线程ID:&#123;0&#125;，来自线程池?&#123;1&#125;,是背景线程?&#123;2&#125;", Thread.CurrentThread.ManagedThreadId, Thread.CurrentThread.IsThreadPoolThread, Thread.CurrentThread.IsBackground); await DoWork(); Console.WriteLine("\n退出TestDoWorkAsync()方法，await语句之后的代码执行线程ID:&#123;0&#125;，来自线程池?&#123;1&#125;,是背景线程?&#123;2&#125;", Thread.CurrentThread.ManagedThreadId, Thread.CurrentThread.IsThreadPoolThread, Thread.CurrentThread.IsBackground); &#125; static Task DoWork() &#123; return Task.Run( () =&gt; &#123; Console.WriteLine("\n使用TPL运行DoWork方法，负责执行的线程ID:&#123;0&#125;，来自线程池？&#123;1&#125;,是背景线程？&#123;2&#125;", Thread.CurrentThread.ManagedThreadId, Thread.CurrentThread.IsThreadPoolThread, Thread.CurrentThread.IsBackground); &#125;); &#125; &#125;&#125; 异步方法与UI线程 异步方法编写指南 编写支持await的方法 await表达式的返回值 异步lambda表达式 任务的取消 进度的提示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144namespace ShowProgressAndCancel&#123; public partial class frmMain : Form &#123; /// &lt;summary&gt; /// 用于显示工作进度的组件 /// &lt;/summary&gt; Progress&lt;int&gt; progressReport = null; /// &lt;summary&gt; /// 用于设定要查找数的范围上限 /// &lt;/summary&gt; private int limit = 0; /// &lt;summary&gt; /// 用于提前取消操作 /// &lt;/summary&gt; CancellationTokenSource cts = null; public frmMain() &#123; InitializeComponent(); //以下两个初始化Progress组件的方式，可以任选一种 InitProgressUseEvent(); //InitProgressWithDelegate(); limit = new Random().Next(Int32.MaxValue); &#125; #region "初始化Progresss组件" /// &lt;summary&gt; /// 在构建Progress组件时直接指定ProgressChanged事件的回调方法 /// &lt;/summary&gt; private void InitProgressWithDelegate() &#123; //显示进度的代码会自动推送到UI线程中执行 progressReport = new Progress&lt;int&gt;((status) =&gt; &#123; //在此可以直接地编写代码访问UI控件 lblInfo.Text = "己完成：" + status + "%"; &#125;); &#125; /// &lt;summary&gt; /// 基于事件响应的方式报告进度 /// &lt;/summary&gt; private void InitProgressUseEvent() &#123; progressReport = new Progress&lt;int&gt;(); progressReport.ProgressChanged += progressReport_ProgressChanged; &#125; void progressReport_ProgressChanged(object sender, int e) &#123; //在此可以直接地编写代码访问UI控件 lblInfo.Text = "己完成：" + e + "%"; &#125; #endregion /// &lt;summary&gt; /// 计算指定范围内的偶数数量 /// &lt;/summary&gt; /// &lt;param name="limit"&gt;要计算的区间上限&lt;/param&gt; /// &lt;param name="onProgressChanged"&gt;用于报告进度的组件&lt;/param&gt; /// &lt;param name="cancelToken"&gt;用于检测外界是否请求取消的取消令牌&lt;/param&gt; public async void ShowEvenNumbers(int limit, IProgress&lt;int&gt; onProgressChanged, CancellationToken cancelToken) &#123; Func&lt;int&gt; calculateTask = () =&gt; &#123; int lastProgressValue = 0; int currentProgressValue = 0; int count = 0; for (int i = 1; i &lt; limit; i++) &#123; if (i % 2 == 0) &#123; count++; currentProgressValue = (int)(((double)i / limit) * 100); if (lastProgressValue != currentProgressValue) &#123; //报造进度 onProgressChanged.Report(currentProgressValue); lastProgressValue = currentProgressValue; &#125; &#125; //检测外界是否发出了取消请求，如果发出了此请求， //抛出OperationCanceledException cancelToken.ThrowIfCancellationRequested(); &#125; return count; &#125;; //允许被取消的计算任务 Task&lt;int&gt; evenNumbersTask = Task.Run(calculateTask, cancelToken); try &#123; //异步等待任务完成 int evenNumberCount = await evenNumbersTask; //可以直接访问UI控件，这是异步调用带给我们的方便 lblInfo.Text = string.Format("计算结果：从&#123;0&#125;到&#123;1&#125;中共有偶数&#123;2&#125;个。", 1, limit, evenNumberCount); &#125; catch (OperationCanceledException) &#123; lblInfo.Text = "计算任务己被取消。"; &#125; //允许重新启动一个新任务 btnCancel.Enabled = false; btnStart.Enabled = true; &#125; private void btnStart_Click(object sender, EventArgs e) &#123; Start(); &#125; private void btnCancel_Click(object sender, EventArgs e) &#123; Cancel(); &#125; /// &lt;summary&gt; /// 启动任务 /// &lt;/summary&gt; private void Start() &#123; cts = new CancellationTokenSource(); ShowEvenNumbers(limit, progressReport, cts.Token); btnCancel.Enabled = true; lblInfo.Text = "计算任务己经启动并在后台运行，等其工作完成，结果会自动显示"; &#125; /// &lt;summary&gt; /// 取消任务 /// &lt;/summary&gt; private void Cancel() &#123; if (cts != null) &#123; cts.Cancel(); &#125; &#125; &#125;&#125; 异常处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273namespace CatchException&#123; class Program &#123; static void Main(string[] args) &#123; TestExceptionThrowViaTaskResult(); //TestExceptionThrowViaAwait(); Console.ReadKey(); &#125; private static async void TestExceptionThrowViaAwait() &#123; Console.WriteLine("使用await等待异步方法执行结束"); Task&lt;string&gt; task = null; try &#123; //当传入空串时，myAsyncMethod将抛出ArgumentNullException task = myAsyncMethod(""); string result = await task; Console.WriteLine(result); &#125; catch (Exception ex) &#123; Console.WriteLine("\n捕获到的异常，类型:&#123;0&#125;，信息：&#123;1&#125;", ex.GetType(), ex.Message); Console.WriteLine("\nTask.Status:&#123;0&#125;, \nTask.Exception:&#123;1&#125;", task.Status, task.Exception.GetType()); &#125; &#125; private static void TestExceptionThrowViaTaskResult() &#123; Console.WriteLine("使用Task&lt;T&gt;.Result等待异步方法执行结束"); Task&lt;String&gt; task = null; try &#123; //当传入空串时，myAsyncMethod将抛出ArgumentNullException task = myAsyncMethod(""); &#125; catch (Exception ex) &#123; //这里的异常捕获代码是不会被执行的，myAsyncMethod抛出的异常， //将会延迟到访问Task.Result时 Console.WriteLine("立即捕获的异常:&#123;0&#125;", ex.Message); &#125; try &#123; //因为访问了Task.Result,所以在这里才抛出ArgumentNullException异常 Console.WriteLine(task.Result); &#125; catch (Exception ex) &#123; Console.WriteLine("\n捕获到的异常，类型:&#123;0&#125;，信息：&#123;1&#125;", ex.GetType(), ex.Message); Console.WriteLine("\nTask.Status:&#123;0&#125;, \nTask.Exception:&#123;1&#125;", task.Status, task.Exception.GetType()); &#125; &#125; static async Task&lt;string&gt; myAsyncMethod(string info) &#123; if (string.IsNullOrEmpty(info)) &#123; throw new ArgumentNullException(); &#125; return await Task.Run&lt;string&gt;(() =&gt; info.ToUpper()); &#125; &#125;&#125; 异常后task的状态 遵循通用的异步编程规范 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128namespace AsyncVoidDemo&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); ResetLabel(); &#125; private int left = 0; private int right = 0; private int result = 0; private Random ran = new Random(); private void btnRun_Click(object sender, EventArgs e) &#123; Console.WriteLine("UI Thread:&#123;0&#125;", Thread.CurrentThread.ManagedThreadId); ResetLabel(); if (rdoAsyncVoid.Checked) &#123; TestAsyncVoid(); &#125; else &#123; TestAsyncTask(); &#125; &#125; private void ResetLabel() &#123; lblResult.Text = "？"; lblLeft.Text = "？"; lblRight.Text = "？"; //立即刷新 lblResult.Refresh(); lblLeft.Refresh(); lblResult.Refresh(); &#125; #region "测试async void的异步方法" //生成第一个数 private async void GeneratorLeftOperand() &#123; await Task.Delay(new Random().Next(1, 1000)); left = new Random().Next(1, 1000); &#125; //生成第二个数 private async void GeneratorRightOperand() &#123; await Task.Delay(new Random().Next(1, 1000)); right = new Random().Next(1, 1000); &#125; //完成计算功能 private async void Calculate() &#123; await Task.Delay(new Random().Next(1, 1000)); result = left + right; &#125; //当异步方法返回async void时，由于它在独立的线程中执行，所以不但结果不对 //就连显示都不一定正常 private void TestAsyncVoid() &#123; //(1)生成第一个数 GeneratorLeftOperand(); lblLeft.Text = left.ToString(); //(2)生成第二个数 GeneratorRightOperand(); lblRight.Text = right.ToString(); //(3)完成计算功能 Calculate(); lblResult.Text = result.ToString(); &#125; #endregion #region "使用async Task" //生成第一个数 private async Task GeneratorLeftOperandTask() &#123; await Task.Run(async () =&gt; &#123; await Task.Delay(ran.Next(1, 1000)); left = ran.Next(1, 1000); &#125;); lblLeft.Text = left.ToString(); &#125; //生成第二个数 private async Task GeneratorRightOperandTask() &#123; await Task.Run(async () =&gt; &#123; await Task.Delay(ran.Next(1, 1000)); right = ran.Next(1, 1000); &#125;); lblRight.Text = right.ToString(); &#125; //完成计算 private async Task CalculateTask() &#123; //并行执行两个异步方法，生成两个数 await Task.WhenAll(GeneratorLeftOperandTask(), GeneratorRightOperandTask()); //执行计算 result = left + right; &#125; //对于不需要返回值的异步方法，让其返回async Task //在调用它的地方使用await，就能保证工作正常 private async void TestAsyncTask() &#123; await CalculateTask(); lblResult.Text = result.ToString(); &#125; #endregion &#125;&#125; 理解线程与Async的关系 123456789101112131415161718192021222324252627282930313233343536373839404142namespace ThreadOverheadDemo&#123; class Program &#123; static void Main(string[] args) &#123; ThreadOverhead(); Console.ReadKey(); &#125; private static void ThreadOverhead() &#123; const int OneMB = 1024 * 1024; using (ManualResetEvent mre = new ManualResetEvent(false)) &#123; int threadNum = 0; long MemorySize = 0; try &#123; ParameterizedThreadStart ts = (mreWake) =&gt; (mreWake as ManualResetEvent).WaitOne(); while (true) &#123; Thread t = new Thread(ts); t.Start(mre); MemorySize=Process.GetCurrentProcess().VirtualMemorySize64; Console.WriteLine("线程编号&#123;0&#125;:占用本进程的虚拟内存&#123;1&#125;字节,&#123;2&#125;MB",++threadNum, MemorySize,MemorySize/OneMB ); &#125; &#125; catch (OutOfMemoryException) &#123; Console.WriteLine("\n内存不足。己创建线程：&#123;0&#125;个", threadNum); mre.Set(); &#125; &#125; &#125; &#125;&#125; 在合适的场景使用异步方法]]></content>
      <categories>
        <category>.NET Framework</category>
        <category>多线程、Socket、异步编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Async await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并行技术基础]]></title>
    <url>%2F2019%2F04%2F30%2F%E5%B9%B6%E8%A1%8C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[并行开发技术 甜蜜的语法糖 自动实现的属性 隐式类型的变量 匿名类型和对象 对象与集合初始化 动态类型 神奇的Lambda 基于任务的并行计算框架初步认识并行计算技术基础 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798namespace SequentialvsParalled&#123; class Program &#123; //要处理的数据项数 const int DataSize = 1000000; //每个数据项进行的数据操作次数 const int OperationCounterPerDataItem = 100; static void Main(string[] args) &#123; int[] data1 = new int[DataSize]; Console.WriteLine("\n敲任意键执行串行算法...\n"); Console.ReadKey(true); Console.WriteLine("开始执行“纯”的顺序算法"); Stopwatch sw = Stopwatch.StartNew(); IncreaseNumberInSquence(data1,0,data1.Length); Console.WriteLine("顺序算法执行结束，使用了&#123;0&#125;毫秒",sw.ElapsedMilliseconds); Console.WriteLine("\n敲任意键执行并行算法一...\n"); Console.ReadKey(true); Console.WriteLine("开始执行并行算法一"); sw = Stopwatch.StartNew(); IncreaseNumberInParallel(data1); Console.WriteLine("并行算法一执行结束，使用了&#123;0&#125;毫秒", sw.ElapsedMilliseconds); Console.WriteLine("\n敲任意键执行并行算法二...\n"); Console.ReadKey(true); Console.WriteLine("开始执行并行算法二"); sw = Stopwatch.StartNew(); IncreaseNumberInParallel2(data1); Console.WriteLine("并行算法二执行结束，使用了&#123;0&#125;毫秒", sw.ElapsedMilliseconds); Console.WriteLine("\n敲任意键执行并行算法三...\n"); Console.ReadKey(true); Console.WriteLine("开始执行并行算法三"); sw = Stopwatch.StartNew(); IncreaseNumberInParallel3(data1); Console.WriteLine("并行算法三执行结束，使用了&#123;0&#125;毫秒", sw.ElapsedMilliseconds); Console.ReadKey(true); &#125; //依次给一个数组中指定部分的元素(共counter个)执行OperationCounterPerDataItem次操作 static void IncreaseNumberInSquence(int[] arr,int startIndex,int counter) &#123; for (int i = 0; i &lt;counter; i++) for (int j = 0; j &lt; OperationCounterPerDataItem; j++) arr[startIndex+i]++; &#125; //依据CPU核心数将任务划分为多个子任务，然后并行执行 static void IncreaseNumberInParallel(int[] arr) &#123; Console.WriteLine("手工创建并行任务，因为本机CPU为&#123;0&#125;核，所以分为&#123;0&#125;个子任务交给TPL并行执行",Environment.ProcessorCount); //计算每个子任务要处理的数据项数，这里假设能正好整除 int counter = DataSize / Environment.ProcessorCount; Parallel.For(0, Environment.ProcessorCount, i =&gt; &#123; int startIndex = i * counter; IncreaseNumberInSquence(arr, startIndex, counter); &#125; ); &#125; static void IncreaseNumberInParallel2(int[] arr) &#123; Console.WriteLine("针对原始数组执行并行循环，使用任务并行库内部默认算法", arr.Length); Parallel.For(0, arr.Length, i =&gt; &#123; //直接在这里使用串行循环，则速度很快 for (int j = 0; j &lt; OperationCounterPerDataItem; j++) arr[i]++; &#125; ); &#125; //任务划分过细，反而减慢运行速度 static void IncreaseNumberInParallel3(int[] arr) &#123; //为每个数据项创建一个任务 Console.WriteLine("共创建&#123;0&#125;个子任务并行执行",arr.Length); Parallel.For(0, arr.Length, i =&gt; &#123; //为每个数据项的每个操作建立一个并行任务， //则并行算法与前述所有算法相比，慢得象蜗牛！ Parallel.For(0, OperationCounterPerDataItem, j =&gt; arr[i]++); &#125; ); &#125; &#125;&#125; .NET并行计算组件 Parallel开发并行计算程序 12345678910111213141516171819202122232425262728293031323334353637383940namespace IntroduceParallel&#123; class Program &#123; static void Main(string[] args) &#123; TestParallelInvoke(); //TestParallelLoop(); Console.ReadKey(); &#125; #region "并行执行" static void DoWork1() &#123; Console.WriteLine("工作一，由线程&#123;0&#125;负责执行……", Thread.CurrentThread.ManagedThreadId); &#125; static void DoWork2() &#123; Console.WriteLine("工作二，由线程&#123;0&#125;负责执行……", Thread.CurrentThread.ManagedThreadId); &#125; static void DoWork3() &#123; Console.WriteLine("工作三，由线程&#123;0&#125;负责执行……", Thread.CurrentThread.ManagedThreadId); &#125; static void TestParallelInvoke() &#123; Console.WriteLine("主线程&#123;0&#125;启动并行操作……", Thread.CurrentThread.ManagedThreadId); Parallel.Invoke( () =&gt; DoWork1(), () =&gt; DoWork2(), () =&gt; DoWork3() ); Console.WriteLine("并行操作结束，敲任意键退出主线程&#123;0&#125;……", Thread.CurrentThread.ManagedThreadId); &#125; #endregion &#125;&#125; 123456789101112131415161718192021222324252627282930#region "并行处理"static void VisitDataItem(int i)&#123; Console.WriteLine("访问第&#123;0&#125;个数据项,由线程&#123;1&#125;负责执行", i, Thread.CurrentThread.ManagedThreadId);&#125;static void ProcessDataItem(int DataItem)&#123; Console.WriteLine("处理数据项&#123;0&#125;,由线程&#123;1&#125;负责执行", DataItem, Thread.CurrentThread.ManagedThreadId);&#125;private static void TestParallelLoop()&#123; var intList = Enumerable.Range(1, 8); Console.WriteLine("原始数据"); foreach (var item in intList) &#123; Console.WriteLine(item); &#125; Console.WriteLine("\n主线程&#123;0&#125;启动并行操作……\n", Thread.CurrentThread.ManagedThreadId); Console.WriteLine("For并行执行后的数据:"); Parallel.For(0, intList.Count(), VisitDataItem); Console.WriteLine("\nForEach并行执行后的数据:"); Parallel.ForEach(intList,ProcessDataItem); Console.WriteLine("\n并行操作结束，敲任意键退出主线程&#123;0&#125;……\n", Thread.CurrentThread.ManagedThreadId);&#125;#endregion 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363namespace CalculateVarianceOfPopulation&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; /// &lt;summary&gt; /// 数据总个数（注意要能被ThreadCount整除) /// &lt;/summary&gt; private const int DataSize = 90000000; /// &lt;summary&gt; /// 测试数据 /// &lt;/summary&gt; private double[] Data = new double[DataSize]; #region "生成测试数据" private void btnGenerateData_Click(object sender, EventArgs e) &#123; ShowInfo("正在生成测试数据，请稍候..."); Thread th = new Thread(GeneratePopulation); th.IsBackground = true; th.Start(); &#125; /// &lt;summary&gt; /// 生成测试数据 /// &lt;/summary&gt; private void GeneratePopulation() &#123; Random ran = new Random(); for (int i = 0; i &lt; DataSize; i++) Data[i] = ran.NextDouble() * 100; string info = string.Format("\n已生成&#123;0&#125;个测试数据\n", DataSize); ShowInfo(info); EnableDisableControl(); &#125; #endregion #region "串行处理" /// &lt;summary&gt; /// 计算数据平均值(串行算法) /// &lt;/summary&gt; /// &lt;param name="data"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private double CalcuateMeanInSequence(double[] data) &#123; double sum = 0; for (int i = 0; i &lt; data.Length; i++) sum += data[i]; return sum / data.Length; &#125; /// &lt;summary&gt; /// 计算方差(串行算法） /// &lt;/summary&gt; /// &lt;param name="mean"&gt;要统计数据的平均值&lt;/param&gt; private double CalculateVarianceInSequence(double mean) &#123; double sum = 0; double SubtractionValue = 0; for (int i = 0; i &lt; Data.Length; i++) &#123; //保存数据项与平均值的差 SubtractionValue = Data[i] - mean; //求平方和 sum += SubtractionValue * SubtractionValue; &#125; return sum / Data.Length; &#125; private void btnUseSequence_Click(object sender, EventArgs e) &#123; Thread th = new Thread(DoWorkInSequence); th.IsBackground = true; th.Start(); &#125; /// &lt;summary&gt; /// 串行完成整个工作 /// &lt;/summary&gt; private void DoWorkInSequence() &#123; string str = ""; Stopwatch sw = new Stopwatch(); sw.Start(); ShowInfo("\n=======串行算法========\n"); ShowInfo("正在计算数据的平均值...\n"); double mean = CalcuateMeanInSequence(Data); str = string.Format("测试数据的平均值为：&#123;0&#125;\n", mean); ShowInfo(str); str = "\n开始计算方差...\n"; ShowInfo(str); double variance = CalculateVarianceInSequence(mean); str = string.Format("测试数据的方差为:&#123;0&#125;\n", variance); ShowInfo(str); str = string.Format("\n串行算法用时:&#123;0&#125;毫秒\n", sw.ElapsedMilliseconds); ShowInfo(str); &#125; #endregion #region "并行处理（使用线程）" /// &lt;summary&gt; /// 每个数据与平均值的差值的平方和 /// &lt;/summary&gt; private double SquareSumUsedByThread = 0; /// &lt;summary&gt; /// 用于等待工作线程运行结束 /// &lt;/summary&gt; private CountdownEvent counterForThread = new CountdownEvent(Environment.ProcessorCount); /// &lt;summary&gt; /// 用于互斥访问线程共享变量SquareSum /// &lt;/summary&gt; private object SquareSumLockObject = new object(); /// &lt;summary&gt; /// 线程安全的显示信息函数 /// &lt;/summary&gt; /// &lt;param name="Info"&gt;&lt;/param&gt; private void ShowInfo(string Info) &#123; if (InvokeRequired) &#123; Action&lt;string&gt; del = (str) =&gt; &#123; rtfInfo.AppendText(str); &#125;; this.BeginInvoke(del, Info); &#125; else rtfInfo.AppendText(Info); &#125; /// &lt;summary&gt; /// 激活用于统计数据的控件，灰掉“生成数据”的控件 /// &lt;/summary&gt; private void EnableDisableControl() &#123; Action del = () =&gt; &#123; groupBox1.Enabled = true; btnGenerateData.Enabled = false; &#125;; this.Invoke(del); &#125; /// &lt;summary&gt; /// 使用多线程并行计算每个数据与平均值的差值的平方和 /// &lt;/summary&gt; /// &lt;param name="ThreadArguObject"&gt;&lt;/param&gt; private void CalculateSquareSumInParallelWithThread(object ThreadArguObject) &#123; ThreadArgu argu = ThreadArguObject as ThreadArgu; double sum = 0; double SubtractionValue = 0; for (int i = 0; i &lt; argu.Count; i++) &#123; //保存数据项与平均值的差 SubtractionValue = Data[argu.StartIndex + i] - argu.Mean; //求平方和 sum += SubtractionValue * SubtractionValue; &#125; lock (SquareSumLockObject) &#123; SquareSumUsedByThread += sum; &#125;; //通知别的线程自己已经完成工作 counterForThread.Signal(); string str = string.Format("\n工作线程&#123;0&#125;已完成工作\n", Thread.CurrentThread.ManagedThreadId); ShowInfo(str); &#125; /// &lt;summary&gt; /// 使用线程并行计算方差 /// &lt;/summary&gt; private void DoWorkInParalleUseThread() &#123; string str = ""; Stopwatch sw = new Stopwatch(); sw.Start(); counterForThread.Reset(); SquareSumUsedByThread = 0; ShowInfo("\n=======使用线程的并行算法========\n"); ShowInfo("正在计算数据的平均值...\n"); double mean = CalcuateMeanInSequence(Data); str = string.Format("测试数据的平均值为：&#123;0&#125;\n", mean); ShowInfo(str); //获取CPU核心数，作为并行线程数 int ThreadCount = Environment.ProcessorCount; str = string.Format("\n现在启动&#123;0&#125;个工作线程开始计算每个数据与平均值的差值的平方和...\n", ThreadCount); //计算每个线程需要处理的数据项数 int workload = DataSize / ThreadCount; //启动ThreadCount个工作线程并行执行工作 for (int i = 0; i &lt; ThreadCount; i++) &#123; ThreadArgu argu = new ThreadArgu(); argu.Count = workload; argu.Mean = mean; argu.StartIndex = workload * i; Thread th = new Thread(CalculateSquareSumInParallelWithThread); th.IsBackground = true; th.Start(argu); &#125; //主控线程等待工作线程完成工作 counterForThread.Wait(); str = "\n所有工作线程都已经完成工作，现在可以计算方差...\n"; ShowInfo(str); double variance = SquareSumUsedByThread / Data.Length; str = string.Format("测试数据的方差为:&#123;0&#125;\n", variance); ShowInfo(str); str = string.Format("\n使用线程的并行算法用时:&#123;0&#125;毫秒\n", sw.ElapsedMilliseconds); ShowInfo(str); &#125; private void btnUseThread_Click(object sender, EventArgs e) &#123; Thread th = new Thread(DoWorkInParalleUseThread); th.IsBackground = true; th.Start(); &#125; #endregion #region "并行处理（使用TPL）" /// &lt;summary&gt; /// 针对特定索引范围内的元素，根据处理器个数分区，然后并行对每个分区并行执行一个数据处理函数 /// &lt;/summary&gt; /// &lt;param name="fromInclusive"&gt;&lt;/param&gt; /// &lt;param name="toExclusive"&gt;&lt;/param&gt; /// &lt;param name="body"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static ParallelLoopResult ForRange(int fromInclusive, int toExclusive, Action&lt;int, int&gt; body) &#123; // 依据本机所包容的处理器个数来决定并行处理的任务数 int numberOfPartitions = System.Environment.ProcessorCount; // 获取要计算的数据范围 int range = toExclusive - fromInclusive; //计算出每个并行任务要计算的数据个数 int stride = range / numberOfPartitions; if (range == 0) numberOfPartitions = 0; //并行执行计算任务 return Parallel.For(0, numberOfPartitions, i =&gt; &#123; int start = i * stride; int end = (i == numberOfPartitions - 1) ? toExclusive : start + stride; body(start, end); &#125;); &#125; /// &lt;summary&gt; /// 使用TPL并行计算方差 /// &lt;/summary&gt; private void DoWorkInParallelUseTPL() &#123; string str = ""; Stopwatch sw = new Stopwatch(); sw.Start(); ShowInfo("\n=======并行算法（使用TPL）========\n"); SquareSumUsedByThread = 0; str = "\n计算平均值\n"; ShowInfo(str); double mean = CalcuateMeanInSequence(Data); str = string.Format("测试数据的平均值为：&#123;0&#125;\n", mean); ShowInfo(str); ForRange(0, Data.Length, (start, end) =&gt; &#123; double sum = 0; double temp = 0; for (int i = start; i &lt; end; i++) &#123; temp = Data[i] - mean; sum += temp * temp; &#125; //保存结果 lock (SquareSumLockObject) &#123; SquareSumUsedByThread += sum; &#125;; &#125;); str = string.Format("\n测试数据的方差为:&#123;0&#125;\n", SquareSumUsedByThread / DataSize); ShowInfo(str); str = string.Format("\n并行算法用时:&#123;0&#125;毫秒\n", sw.ElapsedMilliseconds); ShowInfo(str); &#125; private void btnUseTPL_Click(object sender, EventArgs e) &#123; Thread th = new Thread(DoWorkInParallelUseTPL); th.IsBackground = true; th.Start(); &#125; #endregion &#125; /// &lt;summary&gt; /// 向工作线程传入的参数 /// &lt;/summary&gt; public class ThreadArgu &#123; /// &lt;summary&gt; /// 数组中元素的开始索引 /// &lt;/summary&gt; public int StartIndex &#123; get; set; &#125; /// &lt;summary&gt; /// 要计算的元素个数 /// &lt;/summary&gt; public int Count &#123; get; set; &#125; /// &lt;summary&gt; /// 数据的平均值 /// &lt;/summary&gt; public double Mean &#123; get; set; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119namespace MyImageProcessor&#123; /// &lt;summary&gt; /// Interaction logic for Window1.xaml /// &lt;/summary&gt; public partial class winMain : Window &#123; BitmapSource bmpSource = null; int stride = 0; byte[] ImagePixelData = null; //用于保存图像的像素数据，将用于图像处理 byte[] ImagePixelDataBackup = null; //图像的像素数据备份，用于还原 WinForm.OpenFileDialog openFileDialog1 = null; public winMain() &#123; InitializeComponent(); openFileDialog1 = new WinForm.OpenFileDialog(); openFileDialog1.Filter = "图像文件|*.jpg;*.gif;*.png;*.jpeg|所有文件|*.*"; &#125; /// &lt;summary&gt; /// 装入图像的像素数据到字节数组中。 /// &lt;/summary&gt; /// &lt;param name="ImagePath"&gt;&lt;/param&gt; private void LoadImage(string ImagePath) &#123; bmpSource = new BitmapImage(new Uri(ImagePath)); stride = bmpSource.PixelWidth * bmpSource.Format.BitsPerPixel / 8; stride += 4 - stride % 4; int ImagePixelDataSize = stride * bmpSource.PixelHeight * bmpSource.Format.BitsPerPixel / 8; ; ImagePixelData = new byte[ImagePixelDataSize]; bmpSource.CopyPixels(ImagePixelData, stride, 0); //备份数据 ImagePixelDataBackup = new byte[ImagePixelDataSize]; bmpSource.CopyPixels(ImagePixelDataBackup, stride, 0); &#125; /// &lt;summary&gt; /// 处理图像 /// &lt;/summary&gt; private void ProcessImageData() &#123; if (ImagePixelData == null) return; long UsedTime = 0; if (chkSingleThread.IsChecked == true) &#123; Stopwatch sw = new Stopwatch(); sw.Start(); //启动计时 for(int i=0;i&lt;ImagePixelData.Length;i++) &#123; byte value = ImagePixelData[i]; ImagePixelData[i] = (byte)(Math.Sin(~value) * 255); &#125; sw.Stop();//停止计时 //获取算法执行时间 UsedTime = sw.ElapsedMilliseconds; &#125; else &#123; Stopwatch sw = new Stopwatch(); sw.Start(); //启动计时 Parallel.For(0, ImagePixelData.Length, (i) =&gt; &#123; byte value = ImagePixelData[i]; ImagePixelData[i] = (byte)(Math.Sin(~value)*255); &#125;); sw.Stop();//停止计时 //获取算法执行时间 UsedTime = sw.ElapsedMilliseconds; &#125; ShowImageFromPixelData(ImagePixelData,image1); lblTime.Text = UsedTime.ToString(); &#125; /// &lt;summary&gt; /// 将字节数组中保存的图像像素数据显示在Image控件中 /// &lt;/summary&gt; /// &lt;param name="imagePixelData"&gt;图像像素数据数组&lt;/param&gt; /// &lt;param name="imgControl"&gt;用于显示图像Image控件&lt;/param&gt; private void ShowImageFromPixelData(byte[] imagePixelData, Image imgControl) &#123; BitmapSource newImageSource = BitmapSource.Create(bmpSource.PixelWidth, bmpSource.PixelHeight, bmpSource.DpiX, bmpSource.DpiY, bmpSource.Format, bmpSource.Palette, imagePixelData, stride); imgControl.Source = newImageSource; &#125; private void btnLoadPicture_Click(object sender, RoutedEventArgs e) &#123; if (openFileDialog1.ShowDialog() == WinForm.DialogResult.OK) &#123; LoadImage(openFileDialog1.FileName); image1.Source = bmpSource; &#125; &#125; private void btnRestoreImage_Click(object sender, RoutedEventArgs e) &#123; Array.Copy(ImagePixelDataBackup, ImagePixelData, ImagePixelDataBackup.Length); ShowImageFromPixelData(ImagePixelData, image1); &#125; private void btnProcessImage_Click(object sender, RoutedEventArgs e) &#123; ProcessImageData(); &#125; &#125;&#125; Task简单使用Task的创建与运行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051namespace IntroduceTask&#123; class Program &#123; static void Main(string[] args) &#123; //UseTask(); UseTaskDely(); Console.WriteLine("演示结束，敲任意键退出..."); Console.ReadKey(true); &#125; //用于封装需要并行执行的代码 static void DoSomeVeryImportantWork(int id, int sleepTime) &#123; Console.WriteLine("任务&#123;0&#125;正在执行……", id); Thread.Sleep(sleepTime); Console.WriteLine("任务&#123;0&#125;执行结束。", id); &#125; static void UseTask() &#123; Console.WriteLine("创建三个Task对象并启动其运行……"); //任务方式一 var t1 = new Task(() =&gt; DoSomeVeryImportantWork(1, 1500)); t1.Start(); //任务方式二 var t2 = Task.Factory.StartNew(() =&gt; DoSomeVeryImportantWork(2, 3000)); var t3 = Task.Run(() =&gt; DoSomeVeryImportantWork(3, 2000)); Task.WaitAll(t1, t2, t3); Console.WriteLine("各任务的状态为：&#123;0&#125;，&#123;1&#125;，&#123;2&#125;",t1.Status,t2.Status,t3.Status); &#125; static void UseTaskDely() &#123; Console.WriteLine("使用Task.Delay()方法拖慢程序运行速度，仅供演示！"); Task.Run(() =&gt; &#123; for (int i = 1; i &lt;= 10; i++) &#123; Console.WriteLine("&#123;0&#125;",i); //在真正的程序中，多用await Task.Delay(500); Task.Delay(500).Wait(); &#125; &#125;).Wait(); &#125; &#125;&#125; 取回Task的运算结果 1234567891011121314151617181920212223242526272829303132333435363738394041namespace GetResultFromTaskWithoutThreadSync&#123; class Program &#123; static void Main(string[] args) &#123; //需要并行执行的数据处理函数 Func&lt;object, long&gt; ProcessData = (end) =&gt; &#123; long sum = 0; for (int i = 1; i &lt;= (int)end; i++) &#123; sum += i; //如果取消以下这句注释，会看到其异常被传播到后继任务中。 throw new DivideByZeroException(); &#125; return sum; &#125;; //用于取回处理结果的函数 Action&lt;Task&lt;long&gt;&gt; GetResult = (finishedTask) =&gt; &#123; //依据任务状态，决定后继处理工作 if (finishedTask.IsFaulted) Console.WriteLine("任务在执行时发生异常：&#123;0&#125;", finishedTask.Exception); else Console.Write("程序运行结果为&#123;0&#125;", finishedTask.Result); &#125;; //创建并行处理数据的任务对象 Task&lt;long&gt; tskProcess = new Task&lt;long&gt;(ProcessData, 1000000); //当数据处理结束时，自动启动下一个工作任务，取回上一任务的处理结果 Task tskGetResult = tskProcess.ContinueWith(GetResult); //开始并行处理数据…… tskProcess.Start(); Console.ReadKey(); &#125; &#125;&#125; Task任务关系创建首尾相继的任务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#region "使用ContinueWith" static void UseContinueWith() &#123; Task.Run(() =&gt; DoStep1()).ContinueWith((prevTask) =&gt; DoStep2()); &#125; static void DoStep1() &#123; Console.WriteLine("第一步"); &#125; static void DoStep2() &#123; Console.WriteLine("第二步"); &#125; static void UseConditionalContinueWith() &#123; Task&lt;int&gt; task = Task.Run(() =&gt; &#123; int value = new Random().Next(1, 100); //要测试出错情况，取消以下注释，Ctrl+F5运行示例程序 //throw new Exception("无效的数值"); return value; &#125;); //正常运行结束，执行这句代码 task.ContinueWith(prev =&gt; &#123; Console.WriteLine("前个任务传来的值为：&#123;0&#125;", prev.Result); &#125;, TaskContinuationOptions.OnlyOnRanToCompletion); //出错了，执行以下这些代码 task.ContinueWith(prev =&gt; &#123; Console.WriteLine("\n任务在执行时出现未捕获异常，其信息为：\n&#123;0&#125;", prev.Exception); &#125;, TaskContinuationOptions.OnlyOnFaulted); try &#123; task.Wait(); Console.WriteLine("工作结束"); &#125; catch (Exception ex) &#123; Console.WriteLine("\n使用try...catch捕获Wait()方法抛出的异常：\n&#123;0&#125;", ex); &#125; &#125; #endregion 创建父子类型的任务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#region "一父多子类型的任务"//第一种方式，父任务中创建子任务，然后等待其完成static void UseParentAndChildren()&#123; Task tskParent = new Task(() =&gt; &#123; Console.WriteLine("父任务开始……"); //父任务完成的工作…… Console.WriteLine("父任务启动了两个子任务"); //创建后继子任务并自动启动 Task child1 = Task.Run(() =&gt; &#123; Console.WriteLine("子任务一在行动……"); Task.Delay(1000).Wait(); Console.WriteLine("子任务一结束"); &#125;); Task child2 = Task.Run(() =&gt; &#123; Console.WriteLine("子任务二在行动……"); Task.Delay(500).Wait(); Console.WriteLine("子任务二结束"); &#125;); //如果没有WaitAll（）,那么，父任务将在子任务之前结束 //可以试着注释掉以下这句，看看效果 Task.WaitAll(child1, child2); &#125;); //启动父任务 tskParent.Start(); //等待整个任务树的完成 tskParent.Wait(); Console.WriteLine("父任务完成了自己的工作，功成身退。\n");&#125;/// &lt;summary&gt;/// 方式二：不使用Task.Run()创建子任务，而是使用/// Task.Factory.StartNew()方法创建子任务，并/// 传给它一个TaskCreationOptions.AttachedToParent参数/// 从而无需在父任务中WaitAll()/// &lt;/summary&gt;static void UseParentAndChildren2()&#123; Task tskParent = Task.Factory.StartNew(() =&gt; &#123; Console.WriteLine("父任务开始……"); //父任务完成的工作…… Console.WriteLine("父任务启动了两个子任务"); //创建后继子任务并自动启动 var child1 = Task.Factory.StartNew(() =&gt; &#123; Console.WriteLine("子任务一在行动……"); Task.Delay(1000).Wait(); Console.WriteLine("子任务一结束"); &#125;, TaskCreationOptions.AttachedToParent); var child2 = Task.Factory.StartNew(() =&gt; &#123; Console.WriteLine("子任务二在行动……"); Task.Delay(500).Wait(); Console.WriteLine("子任务二结束"); &#125;, TaskCreationOptions.AttachedToParent); &#125;); //等待整个任务树的完成 tskParent.Wait(); Console.WriteLine("父任务完成了自己的工作，功成身退。\n");&#125;#endregion 任务之间的相互等待 123456789101112131415161718#region"使用WaitAll" static void UseWaitAll() &#123; Console.WriteLine("启动三个并行任务……\n"); var t1 = Task.Run(() =&gt; DoSomeVeryImportantWork(1, 3000)); var t2 = Task.Run(() =&gt; DoSomeVeryImportantWork(2, 1000)); var t3 = Task.Run(() =&gt; DoSomeVeryImportantWork(3, 300)); Task.WaitAll(new Task[] &#123; t1, t2, t3 &#125;); Console.WriteLine("\n所有工作都执行完了。"); &#125; static void DoSomeVeryImportantWork(int id, int sleepTime) &#123; Console.WriteLine("任务&#123;0&#125;正在执行……", id); Thread.Sleep(sleepTime); Console.WriteLine("任务&#123;0&#125;执行结束。", id); &#125; #endregion 12345678910111213141516171819202122232425262728#region "使用ContinueWhenAll"static void UseContinueWhenAll()&#123; //创建“前期”任务数组 Task[] tasks = new Task[]&#123; Task.Run(() =&gt; &#123; Thread.Sleep(1000); //模拟任务的延迟 Console.WriteLine("前期任务1"); &#125;), Task.Run(()=&gt; &#123; Console.WriteLine("前期任务2"); &#125;) &#125;; //所有前期任务完成之后，启动下一个任务 //to do:可以把ContinueWhenAll换成ContinueWhenAny进行试验，看看结果有何不同？ Task.Factory.ContinueWhenAll(tasks, prevTasks =&gt; &#123; Console.WriteLine("前期共有任务&#123;0&#125;个，这是收尾任务！", prevTasks.Count()); &#125;); //Task.Factory.ContinueWhenAny(tasks, prevTask =&gt; //&#123; // Console.WriteLine("前期任务的状态是&#123;0&#125;，这是收尾任务！", prevTask.Status); //&#125;);&#125;#endregion 任务同步示例：从Web下载多个PPT 异常和任务取消处理并行计算中的异常 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748namespace HandleTaskException&#123; class Program &#123; static void Main(string[] args) &#123; //定义3个任务，每个任务都抛出一个异常 Task task1 = new Task(() =&gt; &#123; throw new Exception(); &#125;); Task task2= new Task(() =&gt; &#123; throw new IndexOutOfRangeException(); &#125;); Task task3 = new Task(() =&gt; &#123; throw new DivideByZeroException(); &#125;); //创建一个“父”任务，此任务包容着前面创建的3个子任务 Task taskController = new Task(() =&gt; &#123; task1.Start(); task2.Start(); task3.Start(); Task.WaitAll(task1, task2, task3); &#125; ); try &#123; taskController.Start(); taskController.Wait(); &#125; catch (AggregateException ae) &#123; //“抹平”整个异常树，如果注释掉此句，则必须递归地遍历整个异常树，才能知道到底发生了哪些异常 ae=ae.Flatten(); Console.WriteLine("并行任务一共引发了&#123;0&#125;个异常",ae.InnerExceptions.Count); foreach (Exception ex in ae.InnerExceptions) &#123; Console.WriteLine("&#123;0&#125;:&#123;1&#125;",ex.GetType(),ex.Message); &#125; &#125; Console.ReadKey(); &#125; &#125;&#125; 线程统一取消模型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394namespace UseCancelationToken&#123; public class ThreadFuncObject &#123; //通过构造函数从外界传入取消令牌 private CancellationToken _token; public ThreadFuncObject(CancellationToken token) &#123; _token = token; _token.Register(() =&gt; &#123; Console.WriteLine("操作己被取消,这是操作取消时被回调的方法"); &#125;); &#125; public void DoWork() //将以多线程方式执行的函数 &#123; for (int i = 1; i &lt;= 10; i++) &#123; if (!_token.IsCancellationRequested) &#123; Thread.Sleep(500); Console.WriteLine("正在工作：&#123;0&#125;", i); &#125; &#125; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; CancellationTokenSource cts = new CancellationTokenSource(); ThreadFuncObject threadObj = new ThreadFuncObject(cts.Token); Thread thread = new Thread(threadObj.DoWork); thread.Start(); Console.WriteLine("敲任意键取消并行计算任务……"); Console.ReadKey(true); cts.Cancel(); //为方便观察，主线程在此阻塞等待工作线程执行结束 thread.Join(); Console.WriteLine("敲任意键退出"); Console.ReadKey(); &#125; static void DoStep1WithCancelllationToken(CancellationToken token) &#123; int sleepTime = new Random().Next(1, 5000); Console.WriteLine("第一步预计执行时间：&#123;0&#125;毫秒", sleepTime); Thread.Sleep(sleepTime); if (token.IsCancellationRequested) &#123; Console.WriteLine("步骤一被取消"); token.ThrowIfCancellationRequested(); &#125; Console.WriteLine( "第一步执行完毕"); &#125; static void DoStep2WithCancelllationToken(CancellationToken token) &#123; int sleepTime = new Random().Next(1, 5000); Console.WriteLine("第二步预计执行时间：&#123;0&#125;毫秒", sleepTime); Thread.Sleep(sleepTime); if (token.IsCancellationRequested) &#123; Console.WriteLine("步骤二被取消"); token.ThrowIfCancellationRequested(); &#125; Console.WriteLine("第二步执行完毕"); &#125; static void UseCancellationToken() &#123; try &#123; CancellationTokenSource cts = new CancellationTokenSource(); Task.Factory.StartNew(() =&gt; DoStep1WithCancelllationToken(cts.Token)).ContinueWith((prevTask) =&gt; DoStep2WithCancelllationToken(cts.Token)); Console.WriteLine("马上敲任意键取消执行"); Console.ReadKey(true); cts.Cancel(); &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556namespace UnifiedModelForCancellation&#123; /// &lt;summary&gt; /// Interaction logic for Window1.xaml /// &lt;/summary&gt; public partial class Window1 : Window &#123; public Window1() &#123; InitializeComponent(); InitDemo(); &#125; /// &lt;summary&gt; /// 初始化演示的相关参数 /// &lt;/summary&gt; private void InitDemo() &#123; threadObjs = new ObservableCollection&lt;ThreadObject&gt;(); lstThreads.ItemsSource = threadObjs; tokenSource = new CancellationTokenSource(); btnNewThread.IsEnabled = true; btnCancelThread.IsEnabled = false; &#125; ObservableCollection&lt;ThreadObject&gt; threadObjs = null; CancellationTokenSource tokenSource = null; private void btnNewThread_Click(object sender, RoutedEventArgs e) &#123; ThreadObject obj=new ThreadObject(tokenSource.Token); threadObjs.Add(obj); Thread th = new Thread(obj.DoWork); th.IsBackground = true; th.Start(); btnCancelThread.IsEnabled = true; &#125; private void btnCancelThread_Click(object sender, RoutedEventArgs e) &#123; tokenSource.Cancel(); btnCancelThread.IsEnabled = false; btnNewThread.IsEnabled = false; &#125; private void btnRestart_Click(object sender, RoutedEventArgs e) &#123; InitDemo(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546namespace UnifiedModelForCancellation&#123; public class ThreadObject : INotifyPropertyChanged &#123; private int _value; public int Value &#123; get &#123; return _value; &#125; set &#123; _value = value; OnPropertyChanged("Value"); &#125; &#125; private CancellationToken _token ; public ThreadObject(CancellationToken token) &#123; _token = token; &#125; public void DoWork() &#123; while (_token.IsCancellationRequested!=true) &#123; if (Value + 5 &gt; 100) Value = 0; else Value += 5; Thread.Sleep(200); &#125; &#125; protected void OnPropertyChanged(string name) &#123; PropertyChangedEventHandler handler = PropertyChanged; if (handler != null) &#123; handler(this, new PropertyChangedEventArgs(name)); &#125; &#125; public event PropertyChangedEventHandler PropertyChanged; &#125;&#125; Task的取消 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960namespace TaskCancel&#123; class Program &#123; static void Main(string[] args) &#123; var cts = new CancellationTokenSource(); //需要执行的任务函数 Action taskFunction = ()=&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; cts.Token.ThrowIfCancellationRequested(); Console.WriteLine(i); Thread.Sleep(200); &#125; &#125;; Console.WriteLine("敲任意键发出取消任务请求..."); //请进行以下对比试验： //(1) 让Task对象关联一个令牌对象，然后运行程序 //Task tsk = new Task(taskFunction, cts.Token); //(2) 让Task对象不关联任何一个令牌对象，然后运行程序 Task tsk = new Task(taskFunction); tsk.Start(); Console.ReadKey(true); //发出异步取消任务请求 cts.Cancel(); Console.WriteLine("主线程已发出取消请求！"); //同步等待工作任务停止 try &#123; tsk.Wait(); &#125; catch (AggregateException ae) &#123; ae.Flatten(); //展平整个异常树 foreach (Exception e in ae.InnerExceptions) &#123; if (e is TaskCanceledException) Console.WriteLine("报告领导,您发给我的取消请求已经收到，任务已经取消！"); else &#123; if (e is OperationCanceledException) Console.WriteLine("报告领导,您发出的给其他人的取消命令已经收到，任务已经取消！"); &#125; Console.WriteLine("\n捕获到的异常：\n&#123;0&#125;：&#123;1&#125;", e.GetType(), e.Message); &#125; &#125; Console.WriteLine("\nTask对象的当前状态：&#123;0&#125;", tsk.Status.ToString()); Console.ReadKey(); &#125; &#125;&#125; 任务并行库原理初探]]></content>
      <categories>
        <category>.NET Framework</category>
        <category>多线程、Socket、异步编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>并行技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[管理员方式开机自启动+数据绑定产线小demo]]></title>
    <url>%2F2019%2F04%2F09%2F%E7%AE%A1%E7%90%86%E5%91%98%E6%96%B9%E5%BC%8F%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E4%BA%A7%E7%BA%BF%E5%B0%8Fdemo%2F</url>
    <content type="text"><![CDATA[windows 开机自启动任务，数据绑定技术练手 需求 记录于2019.4.8 号 为了规范产线操作人员行为，防止操作人员忘记比对台位就开始生产模块测试，或者比对了，但是没记录在表，后期瞎填。需要软件进行提醒，然后在测试过程中，如果检测到没有填写，就弹出界面，不允许关闭，除非核对通过。 分析一、数据准备 1.软件初始化时，确保运行需要的配置文件存在 二、类的设计 1.设计一个数据类 用于界面数据绑定 涉及到的基本知识点1.Binding对象的使用 数据到界面的单向更新 2.INotifyPropertyChanged接口的实现 事件的使用 3.windows权限的获取 设置(操作注册表) 4.基本IO操作 5.nameof() 新语法的使用 很赞 防止写错 6.管理员权限获取可参考博客 具体实现软件界面设计 注册表最终图 权限图标 实体类的设计12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//为了数据对象属性变更 不用人为的更新界面 需要实现INotifyPropertyChanged 接口namespace ModuleComparison&#123; public class RecordData : INotifyPropertyChanged &#123; //配置的需要检测的文件个数 private int _filecount = 0; public int Filecount &#123; get &#123; return _filecount; &#125; set &#123; _filecount = value; OnPropertyChanged("Filecount"); &#125; &#125; //配置的路径存在的个数 private int _existsCount = 0; public int ExistsCount &#123; get &#123; return _existsCount; &#125; set &#123; _existsCount = value; OnPropertyChanged("ExistsCount"); &#125; &#125; //配置的路径文件进行了更改的个数 private int _editCount = 0; public int EditCount &#123; get &#123; return _editCount; &#125; set &#123; _editCount = value; OnPropertyChanged("EditCount"); &#125; &#125; public event PropertyChangedEventHandler PropertyChanged; private void OnPropertyChanged(string name) &#123; //多了一次赋值 其实没必要 PropertyChangedEventHandler handler = PropertyChanged; //事件不为空(有挂接方法) if (handler != null) &#123; handler(this, new PropertyChangedEventArgs(name)); &#125; &#125; public bool IsCheckOk() &#123; return _filecount == _editCount; &#125; &#125;&#125; 软件初始化工作1234567891011121314151617181920212223242526272829303132 // 数据对象准备 软件路径准备 private RecordData recordDataObj=new RecordData(); private static string softDir = @"D:\比对表软件配置文件夹"; private static string configName = "比对表路径配置.ini"; private string configFilePath = Path.Combine(softDir, configName);// 如果不存在 首先创建软件配置文件夹和文件 private void SoftwarePathInit() &#123; if (!Directory.Exists(softDir)) &#123; Directory.CreateDirectory(softDir); &#125; if (!File.Exists(configFilePath)) &#123; using (FileStream fs = new FileStream(configFilePath, FileMode.Create)) &#123; StreamWriter sw = new StreamWriter(fs, Encoding.Default); sw.WriteLine("请从下一行开始按照示例规范填写记录表路径信息(此行不要删除，从下一行开始替换)"); sw.WriteLine(@"C:\Software\记录表1.xls"); sw.WriteLine(@"C:\Software\记录表2.xls"); sw.WriteLine(@"C:\Software\记录表3.xls"); sw.Flush(); sw.Close(); &#125; &#125; &#125; 配置文件读取12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//读取配置文件 获取 记录表路径个数 路径存在个数 修改个数 private void ReadConfigFile() &#123; //读取配置文件前先清0 recordDataObj.Filecount = 0; recordDataObj.EditCount = 0; recordDataObj.ExistsCount = 0; using (FileStream fs = new FileStream(configFilePath, FileMode.Open)) &#123; //设置编码 否则乱码 StreamReader sr = new StreamReader(fs, Encoding.Default); //第一行没用 string strtemp = sr.ReadLine(); //不为NUll 一直读 while ((strtemp = sr.ReadLine()) != null) &#123; //这里一定要检测是否为空字符串 否则计数不准 if (strtemp.Trim() != string.Empty) &#123; recordDataObj.Filecount++; if (File.Exists(strtemp.Trim())) &#123; recordDataObj.ExistsCount++; &#125; FileInfo fileInfo = new FileInfo(strtemp.Trim()); //上午 下午计数方式不同 if (DateTime.Now.Hour &lt; 12) &#123; if (fileInfo.LastWriteTime.Date == DateTime.Now.Date) &#123; recordDataObj.EditCount++; &#125; &#125; else &#123; if (fileInfo.LastWriteTime.Hour &gt; 12) &#123; recordDataObj.EditCount++; &#125; &#125; &#125; &#125; &#125; &#125; 界面数据绑定12345678910111213141516171819//设定数据绑定 private void SetUIBinding() &#123; //创建绑定对象 //绑定的控件属性 //数据源 //数据源的属性 Binding bindingConfigCount = new Binding(nameof(this.lbCount.Text), recordDataObj, nameof(recordDataObj.Filecount)); //设置 数据源变更 控件更新模式 bindingConfigCount.ControlUpdateMode = ControlUpdateMode.OnPropertyChanged; //添加到控件绑定属性集合中 this.lbCount.DataBindings.Add(bindingConfigCount); Binding bindingExistCount = new Binding(nameof(this.lbExist.Text), recordDataObj, nameof(recordDataObj.ExistsCount)); bindingExistCount.ControlUpdateMode = ControlUpdateMode.OnPropertyChanged; this.lbExist.DataBindings.Add(bindingExistCount); Binding bindingEditCount = new Binding(nameof(this.lbEditCount.Text), recordDataObj, nameof(recordDataObj.EditCount)); bindingEditCount.ControlUpdateMode = ControlUpdateMode.OnPropertyChanged; this.lbEditCount.DataBindings.Add(bindingEditCount); &#125; 开机启动配置12345678910111213141516171819202122232425262728293031323334353637383940/// 修改程序在注册表中的键值 /// &lt;/summary&gt; /// &lt;param name="isAuto"&gt;true:开机启动,false:不开机自启&lt;/param&gt; public static void AutoStart(bool isAuto) &#123; try &#123; if (isAuto == true) &#123; RegistryKey R_local = Registry.LocalMachine;//RegistryKey R_local = Registry.CurrentUser; RegistryKey R_run = R_local.CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Run", RegistryKeyPermissionCheck.ReadWriteSubTree); R_run.SetValue("stageComparison", Application.ExecutablePath); R_run.Close(); R_local.Close(); &#125; else &#123; RegistryKey R_local = Registry.LocalMachine;//RegistryKey R_local = Registry.CurrentUser; RegistryKey R_run = R_local.CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Run", RegistryKeyPermissionCheck.ReadWriteSubTree); R_run.DeleteValue("stageComparison", false); R_run.Close(); R_local.Close(); &#125; //GlobalVariant.Instance.UserConfig.AutoStart = isAuto; &#125; catch (UnauthorizedAccessException e) &#123; MessageBox.Show("您需要管理员权限才能设置开机启动!" +e.Message, "提示"); &#125; catch (Exception ex) &#123; //MessageBoxDlg dlg = new MessageBoxDlg(); //dlg.InitialData("您需要管理员权限修改", "提示", MessageBoxButtons.OK, MessageBoxDlgIcon.Error); //dlg.ShowDialog(); MessageBox.Show("程序在操作注册表出现异常，联系工程师！" +ex.Message, "提示"); &#125; &#125; 窗体启动执行流程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private void name_Load(object sender, EventArgs e) &#123; //开机启动注册表 AutoStart(true); //设置绑定 SetUIBinding(); //保证配置文件夹和文件存在 SoftwarePathInit(); //读取配置文件 ReadConfigFile(); //刷新界面提醒消息 RefreshUI(); this.timer1.Enabled = true; &#125;private void RefreshUI() &#123; if (recordDataObj.Filecount == 0) &#123; MessageBox.Show("记录表个数为0，请先配置路径！"); return; &#125; if (recordDataObj.Filecount != recordDataObj.ExistsCount) &#123; this.lbinfo.Text = "请填写正确的文件路径!"; this.lbinfo.BackColor = Color.Red; return; &#125; if (!recordDataObj.IsCheckOk()) &#123; this.lbinfo.Text = "请填写比对表！"; this.lbinfo.BackColor = Color.Red; &#125; else &#123; //下午才退出程序 if (DateTime.Now.Hour &gt; 13) &#123; Application.Exit(); &#125; else &#123; //上午先隐藏程序 this.lbinfo.Text = "填写完成！"; this.lbinfo.BackColor = Color.LimeGreen; this.Hide(); &#125; &#125; &#125; 定时器配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//定时器1用于 一直弹出提醒 30s间隔private void timer1_Tick(object sender, EventArgs e)&#123; //如果比对表没有填写 弹出界面 if (!recordDataObj.IsCheckOk()) &#123; this.Visible = true; this.WindowState = FormWindowState.Normal; this.TopMost = true; //this.timer1.Interval = 30000; //30s后会弹出来 ReadConfigFile(); RefreshUI(); &#125; else //都填写了 &#123; if (DateTime.Now.Hour &lt; 12)//上午填写ok &#123; this.Hide(); this.timer1.Enabled = false; //窗体隐藏 定时器1关闭 this.timer2.Interval = 1800000; //半小时 开启定时器2 检测是否到达下午 this.timer2.Enabled = true; &#125; else &#123; this.Close(); &#125; &#125;&#125;//定时器2 用于半小时检测一次 是否到达下午private void timer2_Tick(object sender, EventArgs e)&#123; if (DateTime.Now.Hour &gt;= 13) &#123; this.timer1.Enabled = true; this.timer2.Enabled = false; &#125;&#125; 其余事件响应1234567891011121314151617181920212223242526272829303132333435363738394041//填写完毕判断 private void btnOK_Click(object sender, EventArgs e) &#123; //读取配置文件 ReadConfigFile(); //界面提醒 RefreshUI(); &#125;//窗体关闭前判断 private void name_FormClosing(object sender, FormClosingEventArgs e) &#123; if (!recordDataObj.IsCheckOk()) &#123; MessageBox.Show("请填写记录表，核对成功才能关闭！"); e.Cancel = true; &#125; else &#123; btnOK_Click(null, null); &#125; &#125; //开机自启动 关闭 private void btnStartCancel_Click(object sender, EventArgs e) &#123; AutoStart(false); &#125; //配置比对表路径 private void btnConfigPath_Click(object sender, EventArgs e) &#123; System.Diagnostics.Process.Start(configFilePath); &#125;]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>工作小软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery]]></title>
    <url>%2F2019%2F04%2F03%2Fjquery%2F</url>
    <content type="text"><![CDATA[认识jquery jquery概述 怎么使用jquery 神奇的$ 事件处理 Ajax 命令链 学习要点 访问DOM认识DOM 三种节点 编程访问操作思路 对DOM元素的操作 DOM树的遍历 DOM树的修改 DOM访问元素示例 jQuery访问DOM树 灵活的元素选择 强大的css操控 对DOM树的增删功能强大 API小结 事件与事件响应 事件类型 添加事件相应的四种方式 DOM API中的事件响应挂接函数 常见DOM事件 1234567891011121314151617181920212223242526&lt;body style="text-align:center"&gt; &lt;h2&gt;JavaScript事件模型与DOM&lt;/h2&gt; &lt;img id="image" src="/images/list_3.jpg" alt="风景图片" /&gt; &lt;script type="text/javascript"&gt; function prepareEventHandlers() &#123; var imageElement = document.getElementById("image"); imageElement.onclick = function (event) &#123; alert("你单击了图片元素"); //如果取消以下这句的注释，则document的Click事件不会被触发 //event.stopPropagation(); &#125;; document.body.onclick = function () &#123; alert("body元素响应单击操作"); &#125; document.onclick = function () &#123; alert("document元素响应单击操作"); &#125;; &#125; window.onload = function () &#123; prepareEventHandlers(); &#125;; &lt;/script&gt;&lt;/body&gt; 123456789101112131415161718&lt;body style="text-align:center;"&gt; &lt;h4&gt;响应下拉列表的onchange事件&lt;/h4&gt; &lt;form name="form1" method="post"&gt; &lt;input name="textfield" type="text" value="这是一段文字"&gt; &lt;select name="menu1" onchange="Fcolor( this.value )"&gt; &lt;option value="black"&gt;黑&lt;/option&gt; &lt;option value="green"&gt;绿&lt;/option&gt; &lt;option value="blue"&gt;蓝&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; &lt;script&gt; function Fcolor(v) &#123; form1.textfield.style.color = v; &#125; &lt;/script&gt;&lt;/body&gt; 1234567891011121314151617181920212223&lt;head&gt; &lt;title&gt;自动更换图片&lt;/title&gt; &lt;style&gt; img&#123; width:200px; height:150px; &#125; &lt;/style&gt; &lt;script&gt; function changeImage(img, i) &#123; if (i == 0) img.src = "/images/img02.jpg"; else img.src = "/images/img03.jpg"; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body style="text-align:center"&gt; &lt;h3&gt;鼠标移入移出图片元素，自动更换图片&lt;/h3&gt; &lt;img src="/images/img01.jpg" border="0" onmouseover="changeImage(this,1)" onmouseout="changeImage(this,0)"&gt;&lt;/body&gt; jQuery的事件响应jQuery事件响应机制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;html&gt;&lt;head&gt; &lt;title&gt;事件中的冒泡现象&lt;/title&gt; &lt;link href="../Content/bootstrap.css" rel="stylesheet" /&gt; &lt;link href="../Content/bootstrap-theme.css" rel="stylesheet" /&gt; &lt;style type="text/css"&gt; body &#123; font-size: 13px; &#125; .clsShow &#123; border: #ccc 1px solid; background-color: #eee; margin: 15px auto; padding: 5px; width: 220px; line-height: 1.8em; display: none; &#125; .btn &#123; border: #666 1px solid; padding: 2px; width: 50px; filter: progid:DXImageTransform.Microsoft.Gradient(GradientType=0,StartColorStr=#ffffff, EndColorStr=#ECE9D8); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body class="container text-center"&gt; &lt;h2&gt;响应一组元素的冒泡事件&lt;/h2&gt; &lt;div&gt; &lt;input id="btnShow" type="button" value="点击" class="btn" /&gt; &lt;/div&gt; &lt;div class="clsShow"&gt;&lt;/div&gt; &lt;script src="../Scripts/jquery-2.1.4.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var intI = 0; //记录执行次数 $("body,div,#btnShow").click(function (event) &#123; //点击事件 intI++; //次数累加 $(".clsShow") .show()//显示 .html("您好，欢迎来到jQuery世界!")//设置内容 .append("&lt;div&gt;执行次数 &lt;b&gt;" + intI + "&lt;/b&gt; &lt;/div&gt;"); //追加文本 // event.stopPropagation();//阻止冒泡过程 &#125;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;html&gt;&lt;head&gt; &lt;title&gt;移除事件unbind&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; font-size: 13px; text-align: center; &#125; .btn &#123; border: #666 1px solid; padding: 2px; width: 80px; filter: progid:DXImageTransform.Microsoft.Gradient(GradientType=0,StartColorStr=#ffffff, EndColorStr=#ECE9D8); &#125; div &#123; line-height: 1.8em; width: 300px; margin: 10px auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;事件的动态挂接与移除&lt;/h2&gt; &lt;div&gt; &lt;input id="Button1" type="button" value="按钮一" class="btn" /&gt; &lt;input id="Button2" type="button" value="按钮二" class="btn" /&gt; &lt;input id="Button3" type="button" value="删除事件" class="btn" /&gt; &lt;/div&gt; &lt;div id="divTip" style="padding-top:10px"&gt;&lt;/div&gt; &lt;script src="../Scripts/jquery-2.1.4.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $("input:eq(0)").bind("click", function () &#123; //绑定单击事件 $("#divTip").append("&lt;div&gt;按钮一的单击事件&lt;/div&gt;"); &#125;); function oClick() &#123; //自定义事件 $("#divTip").append("&lt;div&gt;按钮二的单击事件&lt;/div&gt;"); &#125; $("input:eq(1)").bind("click", oClick); $("input:eq(2)").bind("click", function () &#123; //移除全部绑定的事件 //$("input").unbind(); //$("#divTip").html('按钮的事件响应代码被全部移除。'); //利用第二个参数，指定仅移除按钮二的单击事件 $("input").unbind("click", oClick); $("#divTip").html('第二个按钮的事件响应代码被移除。'); &#125;); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;html &gt;&lt;head&gt; &lt;title&gt;切换事件hover&lt;/title&gt; &lt;link href="../Content/bootstrap.css" rel="stylesheet" /&gt; &lt;link href="../Content/bootstrap-theme.css" rel="stylesheet" /&gt; &lt;style type="text/css"&gt; .clsFrame &#123; border: solid 1px #666; width: 320px; margin:0 auto; &#125; .clsFrame .clsTitle &#123; background-color: #eee; padding: 5px; font-weight: bold; &#125; .clsFrame .clsContent &#123; padding: 5px; display: none; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body class="container"&gt; &lt;h3 class="text-center"&gt;响应hover事件，动态显示和隐藏元素&lt;/h3&gt; &lt;div class="clsFrame"&gt; &lt;div class="clsTitle"&gt;jQuery简介&lt;/div&gt; &lt;div class="clsContent"&gt;jQuery是由美国人John Resig于2006年创建的一个开源项目，它的主旨是：以更少的代码，实现更多的功能（Write less，do more）。&lt;/div&gt; &lt;/div&gt; &lt;script src="../Scripts/jquery-2.1.4.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; $(".clsTitle").hover(function () &#123; $(".clsContent").show(); &#125;, function () &#123; $(".clsContent").hide(); &#125;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;html&gt;&lt;head&gt; &lt;title&gt;其他事件trigger&lt;/title&gt; &lt;link href="../Content/bootstrap.css" rel="stylesheet" /&gt; &lt;link href="../Content/bootstrap-theme.css" rel="stylesheet" /&gt; &lt;style type="text/css"&gt; body &#123; font-size: 13px; &#125; .txt &#123; border: #666 1px solid; padding: 3px; &#125; &lt;/style&gt; &lt;/head&gt;&lt;body class="container text-center"&gt; &lt;h2&gt;自定义事件的动态挂接与触发&lt;/h2&gt; &lt;div class="row"&gt; &lt;div class="col-xs-8 col-xs-offset-2"&gt; 姓名：&lt;input id="Text1" type="text" class="txt" value="原始文本" /&gt; &lt;button id="btn"&gt;触发自定义事件btn_click&lt;/button&gt; &lt;div id="divTip" style="padding-top:5px"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="../Scripts/jquery-2.1.4.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function () &#123; var oTxt = $("input"); //获取文本框 oTxt.trigger("select"); //自动选中文本框 //编写文本框自定义事件 oTxt.bind("btn_click", function () &#123; var txt = $(this).val(); //获取自身内容 //显示在页面中 $("#divTip").html("从文本框中提取的文本：&lt;strong&gt;" + txt + "&lt;/strong&gt;"); &#125;) var btn = $('#btn').on('click', function (event) &#123; oTxt.trigger('btn_click'); &#125;); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; AJAX简介 请求过程 jQuery中的AJAX 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;html&gt;&lt;head&gt; &lt;title&gt;.ajax方法示例&lt;/title&gt; &lt;style&gt; #content &#123; padding: 5pt; border: 2px dashed lightgray; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p id="content"&gt;&lt;/p&gt; &lt;ul id="info"&gt;&lt;/ul&gt; &lt;script src="../Scripts/jquery-2.1.4.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $('#info').empty(); getData(); function showInfo(message) &#123; $('#info').append(message); &#125; function getData() &#123; showInfo('&lt;li&gt;向服务器请求数据&lt;/li&gt;'); $.ajax(&#123; // 要提取数据的URL url: "/data/UserInfo.txt", // 发送请求的方式：GET或POST type: "GET", // 返回的数据类型 dataType: "json", // 如果成功，调用这个函数 success: successFn, // 如果失败，调用这个函数 error: errorFn, // 处理结束，调用这个函数 complete: function (xhr, status) &#123; showInfo('&lt;li&gt;请求处理结束&lt;/li&gt;'); &#125; &#125;); &#125; function successFn(result) &#123; showInfo('&lt;li&gt;收到服务器的数据&lt;/li&gt;'); $("#content").empty(); //先清空标记中的内容 var strHTML = ""; //初始化保存内容变量 $.each(result, function (InfoIndex, Info) &#123; //遍历获取的数据 strHTML += "姓名：" + Info["name"] + "&lt;br&gt;"; strHTML += "性别：" + Info["sex"] + "&lt;br&gt;"; strHTML += "邮箱：" + Info["email"] + "&lt;hr&gt;"; &#125;) $("#content").html(strHTML); //显示处理后的数据 showInfo('&lt;li&gt;服务器发回的数据处理结束，页面己更新&lt;/li&gt;'); &#125; function errorFn(xhr, status, strErr) &#123; showInfo("&lt;li&gt;出现错误，服务器返回：" + status + " " + strErr + "&lt;/li&gt;"); &#125; &#125; ); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github仓库和博文收录]]></title>
    <url>%2F2019%2F04%2F02%2Fgithub%E4%BB%93%E5%BA%93%E5%92%8C%E5%8D%9A%E6%96%87%E6%94%B6%E5%BD%95%2F</url>
    <content type="text"><![CDATA[在此记录好的github学习项目 以及不错的博客文章 防丢失 前端 现代 Javascript 教程 github外国大佬的项目 多种语言翻译 .NET EF学习网站 外国的，介绍详细 非常nice的博主-.net技术系列教程总结的很详细 linq学习工具- Linqer工具(sql =&gt; linq) LinqPad(linq =&gt; sql) 数据库 推荐《SQL基础教程(第2版)》 以及 SQL进阶教程]]></content>
  </entry>
  <entry>
    <title><![CDATA[BOM和DOM]]></title>
    <url>%2F2019%2F03%2F30%2FBOM%E5%92%8CDOM%2F</url>
    <content type="text"><![CDATA[认识BOM和DOM 浏览器对象模型（BOM）概述 BOM中所包容的主要对象 顶层对象window 属性 方法 主要功能 Document对象 属性 窗口的打开 对话框 location对象 history对象 浏览器和屏幕信息navigator对象 screen对象 文档对象模型（DOM）概述 DOM中节点的类型 元素节点 文本节点 属性节点 DOM节点的选取 存取元素属性 DOM元素的增删]]></content>
      <categories>
        <category>前端框架</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>BOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript精粹]]></title>
    <url>%2F2019%2F03%2F28%2Fjavascript%E7%B2%BE%E7%B2%B9%2F</url>
    <content type="text"><![CDATA[javaScript进阶知识点 JavaScript导论 JavaScript学习指南 编写JavaScript代码 变量 四种数据类型 包装对象 Undefined和null true and false 初识JavaScript函数函数的定义 全局的命名函数 匿名函数 立即执行的匿名函数 定义方式带来的问题 返回值中的坑 函数是对象 内部函数可以访问外部函数的变量和参数 返回函数的函数 函数的参数 函数对象的length属性 函数对象作为参数 变量作用域 函数作用域 无块作用域 变量提升 嵌套函数可访问的变量 var变量屏蔽问题 变量查找过程 初始JavaScript对象对象的创建与使用 访问对象属性 枚举对象属性 对象属性添加与删除 TypeError 对象工厂函数与构造函数 工厂函数 构造函数 对象的Constructor属性 普通方式调用构造函数 个性十足的JavaScript数组 多态数组 拼接 当做堆栈 shift和unshift slice splice 善变的thisthis 动态设定this引用对象 回调函数执行上下文对象 函数闭包什么是闭包？ 闭包及巧用函数变量 闭包中的this 揭开对象原型的秘密 对象与它的原型 函数也有原型？ 对象原型Vs它的构造函数的原型 基于原型构建对象 同名怎么办？ 对象创建推荐方式 数据封装与代码重用用属性封装信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2 style="text-align:center"&gt;支持改变通知的属性&lt;/h2&gt; &lt;script&gt; //参数name和price都成为了函数闭包的组成部分，可用于保存变化的数据 var Book = function (name, price) &#123; //这里的两个数组，用于保存外界传入的用于回调函数 var priceChanging = []; //保存数据验证函数，未通过验证时，返回false var priceChanged = []; //数据己更改时，通过回调这些函数，更新UI界面 this.name = function (val) &#123; if (val !== undefined) &#123; name = val; &#125; //这里返回的是闭包中的name变量的当前值，不是对象的name函数！ return name; &#125;; this.price = function (val) &#123; if (val !== undefined &amp;&amp; val !== price) &#123; //触发数据检测 for (var i = 0; i &lt; priceChanging.length; i++) &#123; //this引用Book对象 if (!priceChanging[i](this, val)) &#123; //要设置的价格无效，直接返回原始价格 return price; &#125; &#125; //要设置的价格有效，则真正地修改这个值 price = val; //触发“属性修改完毕”事件 for(var i=0;i&lt;priceChanged.length;i++)&#123; priceChanged[i](this); &#125; &#125; //这里返回的是闭包中的price变量的当前值，不是对象的price函数！ return price; &#125;; this.onPriceChanging = function (callback) &#123; priceChanging.push(callback); &#125;; this.onPriceChanged = function (callback) &#123; priceChanged.push(callback); &#125;; &#125;; var book = new Book('JavaScript: The Good Parts', 23.99); console.info('书名：' + book.name()); console.info('价格：' + book.price()); book.onPriceChanging(function (b, price) &#123; if (price &lt; 0) &#123; console.log('书价不能是负数：' + price); return false; &#125; return true; &#125;); book.onPriceChanged(function (b) &#123; console.info('书价己经改为：' + b.price()); &#125;); book.price(-100); book.price(35); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 继承 JavaScript模块化开发技术代码容器 计算器重构之旅]]></content>
      <categories>
        <category>前端框架</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript基础]]></title>
    <url>%2F2019%2F03%2F25%2FJavascript%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JS基础必知必会 JavaScript基础HTML和CSS 京东 网页、网站和应用程序网页：单独的一个页面网站：一些列相关的页面组成到一起应用程序：可以和用户产生交互，并实现某种功能。 演示JavaScript的强大http://impress.github.io/impress.js/http://naotu.baidu.com/https://codecombat.com/https://ide.codemao.cn/ 需要翻墙https://developers.google.com/blockly/blockly迷宫https://blockly-games.appspot.com blockly迷宫不需要翻墙https://blockly.uieee.com/ JavaScript介绍JavaScript是什么HTML CSS JavaScript 编程语言 流程控制 Netscape在最初将其脚本语言命名为LiveScript，后来Netscape在与Sun合作之后将其改名为JavaScript。JavaScript最初受Java启发而开始设计的，目的之一就是“看上去像Java”，因此语法上有类似之处，一些名称和命名规范也借自Java。JavaScript与Java名称上的近似，是当时Netscape为了营销考虑与Sun微系统达成协议的结果。Java和JavaScript的关系就像张雨和张雨生的关系，只是名字很像。 ​ Java 服务器端的编程语言 ​ JavaScript 运行在客户端(浏览器)的编程语言 JavaScript是一种运行在客户端 的脚本语言JavaScript的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 JavaScript最初的目的演示：http://baixiu.uieee.com/admin/login.php最初的目的是为了处理表单的验证操作。 JavaScript现在的意义(应用场景)JavaScript 发展到现在几乎无所不能。 网页特效 服务端开发(Node.js) 命令行工具(Node.js) 桌面程序(Electron) App(Cordova) 控制硬件-物联网(Ruff) 游戏开发(cocos2d-js) JavaScript和HTML、CSS的区别 HTML：提供网页的结构，提供网页中的内容 CSS: 用来美化网页 JavaScript: 可以用来控制网页内容，给网页增加动态的效果 JavaScript的组成 ECMAScript - JavaScript的核心ECMA 欧洲计算机制造联合会 网景：JavaScript 微软：JScript 定义了JavaScript的语法规范 JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关 BOM - 浏览器对象模型一套操作浏览器功能的API 通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等 DOM - 文档对象模型一套操作页面元素的API DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作 JavaScript初体验CSS：行内样式、嵌入样式、外部样式 JavaScript的书写位置 写在行内 1&lt;input type="button" value="按钮" onclick="alert('Hello World')" /&gt; 写在script标签中 12345&lt;head&gt; &lt;script&gt; alert('Hello World!'); &lt;/script&gt;&lt;/head&gt; 写在外部js文件中，在页面引入 1&lt;script src="main.js"&gt;&lt;/script&gt; 注意点 引用外部js文件的script标签中不可以写JavaScript代码 计算机组成软件 应用软件：浏览器(Chrome/IE/Firefox)、QQ、Sublime、Word 系统软件：Windows、Linux、mac OSX 硬件 三大件：CPU、内存、硬盘 – 主板 输入设备：鼠标、键盘、手写板、摄像头等 输出设备：显示器、打印机、投影仪等 变量什么是变量 什么是变量 变量是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据 为什么要使用变量 使用变量可以方便的获取或者修改内存中的数据 如何使用变量 var声明变量 1var age; 变量的赋值 12var age;age = 18; 同时声明多个变量 123var age, name, sex;age = 10;name = 'zs'; 同时声明多个变量并赋值 1var age = 10, name = 'zs'; 变量在内存中的存储1var age = 18; 变量的命名规则和规范 规则 - 必须遵守的，不遵守会报错 由字母、数字、下划线、$符号组成，不能以数字开头 不能是关键字和保留字，例如：for、while。 区分大小写 规范 - 建议遵守的，不遵守不会报错 变量名必须有意义 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。例如：userName、userPassword 下面哪些变量名不合法 123456789a 1 不符合age1818age 不符合name$name_sex&amp;sex 不符合theworld 不符合驼峰 theWorld 案例 交换两个变量的值 不使用临时变量，交换两个数值变量的值 123456789101112131415161718192021&lt;script&gt; // 1 交换两个变量的值 // var n1 = 5; // var n2 = 6; // // 临时变量 // var tmp; // tmp = n1; // n1 = n2; // n2 = tmp; // console.log(n1, n2); // // // 2 交换两个数字的变量的值，不使用第三个变量 var n1 = 5; var n2 = 6; n1 = n1 + n2; // 5 + 6 = 11 n2 = n1 - n2; // 11 - 6 = 5; n1 = n1 - n2; // 11 - 5 = 6; console.log(n1, n2);&lt;/script&gt; 数据类型简单数据类型Number、String、Boolean、Undefined、Null Number类型 数值字面量：数值的固定值的表示法 110 1024 60.5 进制 123456789101112十进制 var num = 9; 进行算数计算时，八进制和十六进制表示的数值最终都将被转换成十进制数值。十六进制 var num = 0xA; 数字序列范围：0~9以及A~F八进制 var num1 = 07; // 对应十进制的7 var num2 = 019; // 对应十进制的19 var num3 = 08; // 对应十进制的8 数字序列范围：0~7 如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析 浮点数 浮点数的精度问题 123456浮点数 var n = 5e-324; // 科学计数法 5乘以10的-324次方 浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数 var result = 0.1 + 0.2; // 结果不是 0.3，而是：0.30000000000000004 console.log(0.07 * 100); 不要判断两个浮点数是否相等 数值范围 1234最小值：Number.MIN_VALUE，这个值为： 5e-324最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308无穷大：Infinity无穷小：-Infinity 数值判断 NaN：not a number NaN 与任何值都不相等，包括他本身 isNaN: is not a number String类型‘abc’ “abc” 字符串字面量 ‘程序猿’，’程序媛’, “黑马程序猿” 思考：如何打印以下字符串。 我是一个”正直”的人 我很喜欢”黑马’程序猿’” 转义符 字符串长度 length属性用来获取字符串的长度 12var str = '黑马程序猿 Hello World';console.log(str.length); 字符串拼接 字符串拼接使用 + 连接 12345console.log(11 + 11);console.log('hello' + ' world');console.log('100' + '100');console.log('11' + 11);console.log('male:' + true); 两边只要有一个是字符串，那么+就是字符串拼接功能 两边如果都是数字，那么就是算术功能。 Boolean类型 Boolean字面量： true和false，区分大小写 计算机内部存储：true为1，false为0 Undefined和Null undefined表示一个声明了没有赋值的变量，变量只声明的时候值默认是undefined null表示一个空，变量的值如果想为null，必须手动设置 复杂数据类型​ Object 获取变量的类型typeof 12var age = 18;console.log(typeof age); // 'number' 字面量在源代码中一个固定值的表示法。 数值字面量：8, 9, 10 字符串字面量：’黑马程序员’, “大前端” 布尔字面量：true，false 注释单行注释用来描述下面一个或多行代码的作用 12// 这是一个变量var name = 'hm'; 多行注释用来注释多条代码 12345/*var age = 18;var name = 'zs';console.log(name, age);*/ 数据类型转换如何使用谷歌浏览器，快速的查看数据类型？ 字符串的颜色是黑色的，数值类型是蓝色的，布尔类型也是蓝色的，undefined和null是灰色的 转换成字符串类型 toString() 12var num = 5;console.log(num.toString()); String() 1String()函数存在的意义：有些值没有toString()，这个时候可以使用String()。比如：undefined和null 拼接字符串方式 num + “”，当 + 两边一个操作符是字符串类型，一个操作符是其它类型的时候，会先把其它类型转换成字符串再进行字符串拼接，返回字符串 转换成数值类型 Number() 1Number()可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回NaN parseInt() 12var num1 = parseInt("12.3abc"); // 返回12，如果第一个字符是数字会解析知道遇到非数字结束var num2 = parseInt("abc123"); // 返回NaN，如果第一个字符不是数字或者符号就返回NaN parseFloat() 1234parseFloat()把字符串转换成浮点数parseFloat()和parseInt非常相似，不同之处在与 parseFloat会解析第一个. 遇到第二个.或者非数字结束 如果解析的内容里只有整数，解析成整数 +，-0等运算 1234var str = '500';console.log(+str); // 取正console.log(-str); // 取负console.log(str - 0); 转换成布尔类型 Boolean() 0 ‘’(空字符串) null undefined NaN 会转换成false 其它都会转换成true 操作符运算符 operator 5 + 6 表达式 组成 操作数和操作符，会有一个结果 算术运算符1+ - * / % 一元运算符一元运算符：只有一个操作数的运算符 5 + 6 两个操作数的运算符 二元运算符 ++ 自身加1 – 自身减1 前置++ 12345var num1 = 5;++ num1; var num2 = 6;console.log(num1 + ++ num2); 后置++ 1234var num1 = 5;num1 ++; var num2 = 6 console.log(num1 + num2 ++); 猜猜看 1234var a = 1; var b = ++a + ++a; console.log(b); var a = 1; var b = a++ + ++a; console.log(b); var a = 1; var b = a++ + a++; console.log(b); var a = 1; var b = ++a + a++; console.log(b); 逻辑运算符(布尔运算符)&amp;&amp; 与 两个操作数同时为true，结果为true，否则都是false || 或 两个操作数有一个为true，结果为true，否则为false ! 非 取反 关系运算符(比较运算符)&lt; &gt; &gt;= &lt;= == != === !== 12345==与===的区别：==只进行值得比较，===类型和值同时相等，则相等var result = '55' == 55; // truevar result = '55' === 55; // false 值相等，类型不相等var result = 55 === 55; // true 赋值运算符= += -= *= /= %=123例如：var num = 0;num += 5; //相当于 num = num + 5; 运算符的优先级优先级从高到底 1. () 优先级最高 2. 一元运算符 ++ -- ! 3. 算数运算符 先* / % 后 + - 4. 关系运算符 &gt; &gt;= &lt; &lt;= 5. 相等运算符 == != === !== 6. 逻辑运算符 先&amp;&amp; 后|| 7. 赋值运算符 12345// 练习1：4 &gt;= 6 || '人' != '阿凡达' &amp;&amp; !(12 * 2 == 144) &amp;&amp; true// 练习2：var num = 10;5 == num / 2 &amp;&amp; (2 + 2 * num).toString() === '22' 表达式和语句表达式 一个表达式可以产生一个值，有可能是运算、函数调用、有可能是字面量。表达式可以放在任何需要值的地方。 语句 语句可以理解为一个行为，循环语句和判断语句就是典型的语句。一个程序有很多个语句组成，一般情况下;分割一个一个的语句 流程控制 程序的三种基本结构 顺序结构 从上到下执行的代码就是顺序结构 程序默认就是由上到下顺序执行的 分支结构根据不同的情况，执行对应代码 循环结构循环结构：重复做一件事情 分支结构if语句语法结构 12345678910111213141516171819if (/* 条件表达式 */) &#123; // 执行语句&#125;if (/* 条件表达式 */)&#123; // 成立执行语句&#125; else &#123; // 否则执行语句&#125;if (/* 条件1 */)&#123; // 成立执行语句&#125; else if (/* 条件2 */)&#123; // 成立执行语句&#125; else if (/* 条件3 */)&#123; // 成立执行语句&#125; else &#123; // 最后默认执行语句&#125; 案例：​ 求两个数的最大数​ 判断一个数是偶数还是奇数​ 分数转换，把百分制转换成ABCDE &lt;60 E 60-70 D 70-80 C 80-90 B 90 - 100 A作业：​ 判断一个年份是闰年还是平年​ 闰年：能被4整除，但不能被100整除的年份 或者 能被400整除的年份​ 判断一个人的年龄是否满18岁(是否成年) 三元运算符表达式1 ? 表达式2 : 表达式3 是对if……else语句的一种简化写法 案例：​ 是否年满18岁​ 从两个数中找最大值 12345678910111213141516171819&lt;script&gt; // 获取两个数中的最大值 // var num1 = 13; // var num2 = 6; // // 表达式1 ? 表达式2 : 表达式3 // // console.log( num1 &gt; num2 ? num1 : num2 ); // var max = num1 &gt; num2 ? num1 : num2; // console.log(max); // // // 判断一个年龄是否成年, 当年龄超过18 返回 成年 否则返回未成年 var age = 19; // console.log( age &gt;= 18 ? '成年' : '未成年' ); var msg = age &gt;= 18 ? '成年' : '未成年'; console.log(msg); &lt;/script&gt; switch语句语法格式:123456789101112131415161718switch (expression) &#123; case 常量1: 语句; break; case 常量2: 语句; break; case 常量3: 语句; break; … case 常量n: 语句; break; default: 语句; break;&#125; break可以省略，如果省略，代码会继续执行下一个case switch 语句在比较值时使用的是全等操作符, 因此不会发生类型转换（例如，字符串&apos;10&apos; 不等于数值 10） 案例：​ 显示星期几​ 素质教育（把分数变成ABCDE）千万不要写100个case哟 布尔类型的隐式转换流程控制语句会把后面的值隐式转换成布尔类型 转换为true 非空字符串 非0数字 true 任何对象 转换成false 空字符串 0 false null undefined 12// 结果是什么？var a = !!'123'; 案例12345var message;// 会自动把message转换成falseif (message) &#123; // todo...&#125; 循环结构 在javascript中，循环语句有三种，while、do..while、for循环。 while语句基本语法： 12345// 当循环条件为true时，执行循环体，// 当循环条件为false时，结束循环。while (循环条件) &#123; //循环体&#125; 代码示例： 123456789101112// 计算1-100之间所有数的和// 初始化变量var i = 1;var sum = 0;// 判断条件while (i &lt;= 100) &#123; // 循环体 sum += i; // 自增 i++;&#125;console.log(sum); 案例：​ 打印100以内 7的倍数​ 打印100以内所有偶数​ 打印100以内所有偶数的和作业：​ 打印100以内的奇数​ 打印100以内的奇数的和 do…while语句 do..while循环和while循环非常像，二者经常可以相互替代，但是do..while的特点是不管条件成不成立，都会执行一次。 基础语法： 123do &#123; // 循环体;&#125; while (循环条件); 代码示例： 1234567// 初始化变量var i = 1;var sum = 0;do &#123; sum += i;//循环体 i++;//自增&#125; while (i &lt;= 100);//循环条件 案例： 12求100以内所有3的倍数的和使用do-while循环：输出询问“我爱你，嫁给我吧？”，选择“你喜欢我吗？(y/n):&quot;，如果输入为y则打印”我们形影不离“，若输入为n,则继续询问 for语句 while和do…while一般用来解决无法确认次数的循环。for循环一般在循环次数确定的时候比较方便 for循环语法： 1234// for循环的表达式之间用的是;号分隔的，千万不要写成,for (初始化表达式1; 判断表达式2; 自增表达式3) &#123; // 循环体4&#125; 执行顺序：1243 —- 243 —–243(直到循环条件变成false) 初始化表达式 判断表达式 自增表达式 循环体 案例： 123456789101112131415161718192021222324252627282930313233343536打印1-100之间所有数求1-100之间所有数的和求1-100之间所有数的平均值求1-100之间所有偶数的和同时求1-100之间所有偶数和奇数的和打印正方形// 使用拼字符串的方法的原因// console.log 输出重复内容的问题// console.log 默认输出内容介绍后有换行var start = '';for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; start += '* '; &#125; start += '\n';&#125;console.log(start);打印直角三角形var start = '';for (var i = 0; i &lt; 10; i++) &#123; for (var j = i; j &lt; 10; j++) &#123; start += '* '; &#125; start += '\n';&#125;console.log(start);打印9*9乘法表var str = '';for (var i = 1; i &lt;= 9; i++) &#123; for (var j = i; j &lt;=9; j++) &#123; str += i + ' * ' + j + ' = ' + i * j + '\t'; &#125; str += '\n';&#125;console.log(str); 作业： 1234567求1-100之间所有数的乘积求1-100之间所有奇数的和计算1-100之间能3整除的数的和计算1-100之间不能被7整除的数的和// 讲解思路。如果不会写程序，可以先把数学公式准备好本金10000元存入银行，年利率是千分之三，每过1年，将本金和利息相加作为新的本金。计算5年后，获得的本金是多少？有个人想知道，一年之内一对兔子能繁殖多少对？于是就筑了一道围墙把一对兔子关在里面。已知一对兔子每个月可以生一对小兔子，而一对兔子从出生后第3个月起每月生一对小兔子。假如一年内没有发生死亡现象，那么，一对兔子一年内（12个月）能繁殖成多少对？（兔子的规律为数列，1，1，2，3，5，8，13，21） continue和break break:立即跳出整个循环，即循环结束，开始执行循环后面的内容（直接跳到大括号） continue:立即跳出当前循环，继续下一次循环（跳到i++的地方） 案例： 12求整数1～100的累加值，但要求碰到个位为3的数则停止累加求整数1～100的累加值，但要求跳过所有个位为3的数 作业： 求1-100之间不能被7整除的整数的和（用continue）求200-300之间所有的奇数的和（用continue）求200-300之间第一个能被7整数的数（break） 调试 过去调试JavaScript的方式 alert() console.log() 断点调试 断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。 调试步骤 1浏览器中按F12--&gt;sources--&gt;找到需要调试的文件--&gt;在程序的某一行设置断点 调试中的相关操作 123Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。F10: 程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。F8：跳到下一个断点处，如果后面没有断点了，则程序执行结束。 tips: 监视变量，不要监视表达式，因为监视了表达式，那么这个表达式也会执行。 代码调试的能力非常重要，只有学会了代码调试，才能学会自己解决bug的能力。初学者不要觉得调试代码麻烦就不去调试，知识点花点功夫肯定学的会，但是代码调试这个东西，自己不去练，永远都学不会。 今天学的代码调试非常的简单，只要求同学们记住代码调试的这几个按钮的作用即可，后面还会学到很多的代码调试技巧。 数组为什么要学习数组 之前学习的数据类型，只能存储一个值(比如：Number/String。我们想存储班级中所有学生的姓名，此时该如何存储？ 数组的概念 所谓数组，就是将多个元素（通常是同一类型）按一定顺序排列放到一个集合中，那么这个集合我们就称之为数组。 数组的定义 数组是一个有序的列表，可以在数组中存放任意的数据，并且数组的长度可以动态的调整。 通过数组字面量创建数组 1234567891011// 创建一个空数组var arr1 = []; // 创建一个包含3个数值的数组，多个数组项以逗号隔开var arr2 = [1, 3, 4]; // 创建一个包含2个字符串的数组var arr3 = ['a', 'c']; // 可以通过数组的length属性获取数组的长度console.log(arr3.length);// 可以设置length属性改变数组中元素的个数arr3.length = 0; 获取数组元素数组的取值 123456// 格式：数组名[下标] 下标又称索引// 功能：获取数组对应下标的那个值，如果下标不存在，则返回undefined。var arr = ['red',, 'green', 'blue'];arr[0]; // redarr[2]; // bluearr[3]; // 这个数组的最大下标为2,因此返回undefined 遍历数组 遍历：遍及所有，对数组的每一个元素都访问一次就叫遍历。 数组遍历的基本语法： 123for(var i = 0; i &lt; arr.length; i++) &#123; // 数组遍历的固定结构&#125; 数组中新增元素数组的赋值 1234567// 格式：数组名[下标/索引] = 值;// 如果下标有对应的值，会把原来的值覆盖，如果下标不存在，会给数组新增一个元素。var arr = ["red", "green", "blue"];// 把red替换成了yellowarr[0] = "yellow";// 给数组新增加了一个pink的值arr[3] = "pink"; 案例123456求一组数中的所有数的和和平均值求一组数中的最大值和最小值，以及所在位置将字符串数组用|或其他符号分割要求将数组中的0项去掉，将不为0的值存入一个新的数组，生成新的数组翻转数组冒泡排序，从小到大 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;script&gt; // 翻转数组 1，2,3,4 -》 4,3,2,1 var numbers = [4, 5, 7, 9]; // 生成一个新的数组 数组中存储 9 7 5 4 var newArray = []; for (var i = numbers.length - 1; i &gt;= 0; i--) &#123; newArray[newArray.length] = numbers[i]; &#125; console.log(newArray); // 冒泡排序 -- 从小到大的排序 var numbers = [1, 2, 3, 4, 5]; var count = 0; // 记录循环的次数 // 外层循环：控制趟数，每一趟找到一个最大值 for (var i = 0; i &lt; numbers.length - 1; i++) &#123; count++; // 内层循环：控制比较的次数，并且判断两个数的大小，把大的数往后移动，小的数往前移动 for (var j = 0; j &lt; numbers.length - 1 - i; j++) &#123; count++; // 两两比较 从小到大排序 if (numbers[j] &gt; numbers[j + 1]) &#123; // 交换位置 var tmp = numbers[j]; numbers[j] = numbers[j + 1]; numbers[j + 1] = tmp; &#125; &#125; &#125; console.log(numbers); console.log(count); // // // 优化刚刚的代码 var numbers = [1, 2, 3, 4, 5]; var count = 0; // 记录循环的次数 // 外层循环：控制趟数，每一趟找到一个最大值 for (var i = 0; i &lt; numbers.length - 1; i++) &#123; // 假设数据排好顺序了 var isSort = true; count++; // 内层循环：控制比较的次数，并且判断两个数的大小，把大的数往后移动，小的数往前移动 for (var j = 0; j &lt; numbers.length - 1 - i; j++) &#123; count++; // 两两比较 从小到大排序 if (numbers[j] &gt; numbers[j + 1]) &#123; // 没有排好 isSort = false; // 交换位置 var tmp = numbers[j]; numbers[j] = numbers[j + 1]; numbers[j + 1] = tmp; &#125; &#125; // 某一趟结束，判断一下排序是否结束 // 如何判断排序是否排好，根据是否发生了数据交换，如果发生了数据交换说明没有排好 if (isSort) &#123; // 如果排好顺序 break; &#125; &#125; console.log(numbers); console.log(count); &lt;/script&gt; 函数为什么要有函数 如果要在多个地方求1-100之间所有数的和，应该怎么做？ 什么是函数 把一段相对独立的具有特定功能的代码块封装起来，形成一个独立实体，就是函数，起个名字（函数名），在后续开发中可以反复调用 函数的作用就是封装一段代码，将来可以重复使用 函数的定义 函数声明 123function 函数名() &#123; // 函数体&#125; 函数表达式 123var fn = function () &#123; // 函数体&#125; 特点： 函数声明的时候，函数体并不会执行，只要当函数被调用的时候才会执行。函数一般都用来干一件事情，函数名称一般使用动词 函数的调用 调用函数的语法： 1函数名(); 特点： 函数体只有在调用的时候才会执行，调用需要()进行调用。可以调用多次(重复使用) 代码示例： 1234567891011121314151617// 声明函数function sayHi() &#123; console.log("吃了没？");&#125;// 调用函数sayHi();// 求1-100之间所有数的和function getSum() &#123; var sum = 0; for (var i = 0; i &lt; 100; i++) &#123; sum += i; &#125; console.log(sum);&#125;// 调用getSum(); 函数的参数 为什么要有参数 12345678910function getSum() &#123; var sum = 0; for (var i = 1; i &lt;= 100; i++) &#123; sum += i; &#125; console.log();&#125;// 虽然上面代码可以重复调用，但是只能计算1-100之间的值// 如果想要计算n-m之间所有数的和，应该怎么办呢？ 语法： 12345678910// 函数内部是一个封闭的环境，可以通过参数的方式，把外部的值传递给函数内部// 带参数的函数声明function 函数名(形参1, 形参2, 形参3...) &#123; // 函数体&#125;// 带参数的函数调用函数名(实参1, 实参2, 实参3); 形参1 = 实参1形参2 = 实参2 形参和实参 形式参数：在声明一个函数的时候，为了函数的功能更加灵活，有些值是固定不了的，对于这些固定不了的值。我们可以给函数设置参数。这个参数没有具体的值，仅仅起到一个占位置的作用，我们通常称之为形式参数，也叫形参。 实际参数：如果函数在声明时，设置了形参，那么在函数调用的时候就需要传入对应的参数，我们把传入的参数叫做实际参数，也叫实参。 123456var x = 5, y = 6;fn(x,y); function fn(a, b) &#123; console.log(a + b);&#125;// x,y实参，有具体的值。函数执行的时候会把x,y复制一份给函数内部的a和b，函数内部的值是复制的新值，无法修改外部的x,y 案例 求1-n之间所有数的和 求n-m之间所有数的和 圆的面积 求2个数中的最大值 求3个数中的最大值 判断一个数是否是素数(又叫质数，只能被1和自身整数的数) 函数的返回值 当函数执行完的时候，并不是所有时候都要把结果打印。我们期望函数给我一些反馈（比如计算的结果返回进行后续的运算），这个时候可以让函数返回一些东西。也就是返回值。函数通过return返回一个返回值 返回值语法： 12345678//声明一个带返回值的函数function 函数名(形参1, 形参2, 形参3...) &#123; //函数体 return 返回值;&#125;//可以通过变量来接收这个返回值var 变量 = 函数名(实参1, 实参2, 实参3...); 函数的调用结果就是返回值，因此我们可以直接对函数调用结果进行操作。 案例 求一组数中的最大值 求一组数中的最小值 求阶乘 求1!+2!+3!+….+n! 返回值详解： 如果函数没有显示的使用 return语句 ，那么函数有默认的返回值：undefined 如果函数使用 return语句，那么跟再return后面的值，就成了函数的返回值 如果函数使用 return语句，但是return后面没有任何值，那么函数的返回值也是：undefined 函数使用return语句后，这个函数会在执行完 return 语句之后停止并立即退出，也就是说return后面的所有其他代码都不会再执行。 推荐的做法是要么让函数始终都返回一个值，要么永远都不要返回值。 arguments的使用 JavaScript中，arguments对象是比较特别的一个对象，实际上是当前函数的一个内置属性。也就是说所有函数都内置了一个arguments对象，arguments对象中存储了传递的所有的实参。arguments是一个伪数组，因此及可以进行遍历 案例12求任意个数的最大值求任意个数的和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;script&gt; // var a = 10; // var b = 20; // var c = 30; // console.log(a, b, c); // function test(a, b, c) &#123; // // 我们可以通过arguments 获取函数调用的时候的实参 // // arguments非常想数组，但不是数组 // console.log(arguments); // console.log(1); // &#125; // test(4, 5, 6); // // // 求任意个数的最大值 // getMax(数组) // function getMax() &#123; // var max = arguments[0]; // for (var i = 1; i &lt; arguments.length; i++) &#123; // if (max &lt; arguments[i]) &#123; // max = arguments[i]; // &#125; // &#125; // return max; // &#125; // var max = getMax(5, 10, 1, 5, 100); // console.log(max); // 求任意个数的和 function getSum() &#123; var sum = 0; for (var i = 0; i &lt; arguments.length; i++) &#123; sum += arguments[i]; &#125; return sum; &#125; var sum = getSum(5, 1, 3, 4); console.log(sum);&lt;/script&gt; 案例12345求斐波那契数列Fibonacci中的第n个数是多少？ 1 1 2 3 5 8 13 21...翻转数组，返回一个新数组对数组排序，从小到大输入一个年份，判断是否是闰年[闰年：能被4整数并且不能被100整数，或者能被400整数]输入某年某月某日，判断这一天是这一年的第几天？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;script&gt; // 求斐波那契数列Fibonacci中的第n个数是多少？ 1 1 2 3 5 8 13 21... // function getFib(n) &#123; // // 函数体 // var n1 = 1; // var n2 = 1; // var n3; // for (var i = 3; i &lt;= n; i++) &#123; // n3 = n1 + n2; // n1 = n2; // n2 = n3; // &#125; // return n3; // &#125; // var r = getFib(6); // console.log(r); // 翻转数组，返回一个新数组 [5, 4, 3, 2, 1] -&gt; [1, 2, 3, 4, 5] // function reverse(array) &#123; // var newArray = []; // for (var i = array.length - 1; i &gt;= 0; i--) &#123; // newArray[newArray.length] = array[i]; // &#125; // return newArray; // &#125; // // var arr = [5, 3, 2, 1]; // // console.log(reverse(arr)); // var arr = ['abc', 'xyz', '123']; // console.log(reverse(arr)); // 对数组排序，从小到大 -- 冒泡排序 // function sort(array) &#123; // // 外层循环 控制趟数 // for (var i = 0; i &lt; array.length - 1; i++) &#123; // // 假设排好序了 // var isSort = true; // // 内层循环 控制比较的次数 // for (var j = 0; j &lt; array.length - 1 - i; j++) &#123; // if (array[j] &gt; array[j + 1]) &#123; // isSort = false; // // 交换位置 // var tmp = array[j]; // array[j] = array[j + 1]; // array[j + 1] = tmp; // &#125; // &#125; // // 判断是否排好了 // if (isSort) &#123; // break; // &#125; // &#125; // return array; // &#125; // var array = [34, 12, 88, 20, 30]; // console.log(sort(array)); // &#125; // 输入一个年份，判断是否是闰年[闰年：能被4整数并且不能被100整数，或者能被400整数] // function isRun(year) &#123; // var result = false; // if ((year % 4 === 0 &amp;&amp; year % 100 !== 0) || (year % 400 === 0)) &#123; // result = true; // &#125; // return result; // &#125; // console.log(isRun(2016)); // 输入某年某月某日，判断这一天是这一年的第几天？ // 1998 5 18 // 5月份 18 // 4月份 30 // 3月份 31 // 2月份 闰年的时候29天 平年的时候28天 // 1月份 31 // // 判断年份是否是闰年 function isRun(year) &#123; var result = false; if ((year % 4 === 0 &amp;&amp; year % 100 !== 0) || (year % 400 === 0)) &#123; result = true; &#125; return result; &#125; // 获取年月日 是当前年的多少天 function getDays(year, month, day) &#123; // 计算总共有多少天 var days = day; // 当前月份的天数 for (var i = 1; i &lt; month; i++) &#123; switch (i) &#123; case 1: case 3: case 5: case 7: case 8: case 10: case 12: days += 31; break; case 4: case 6: case 9: case 11: days += 30; break; case 2: // 判断是平年28还是闰年29 if (isRun(year)) &#123; days += 29; &#125; else &#123; days += 28; &#125; break; &#125; &#125; return days; &#125; console.log(getDays(1998, 5, 2));&lt;/script&gt; 函数其它匿名函数 匿名函数：没有名字的函数 匿名函数如何使用： 将匿名函数赋值给一个变量，这样就可以通过变量进行调用 匿名函数自调用 自调用函数 匿名函数不能通过直接调用来执行，因此可以通过匿名函数的自调用的方式来执行123(function () &#123; alert(123);&#125;)(); 函数是一种数据类型12function fn() &#123;&#125;console.log(typeof fn); 函数作为参数 因为函数也是一种类型，可以把函数作为两一个函数的参数，在另一个函数中调用 函数做为返回值 因为函数是一种类型，所以可以把函数可以作为返回值从函数内部返回。 1234567function fn(b) &#123; var a = 10; return function () &#123; alert(a+b); &#125;&#125;fn(15)(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script&gt; // //1 函数声明 - 命名函数 // function fn() &#123; // &#125; // //2 函数表达式 -- 后半部分 匿名函数 // var fn = function () &#123; // &#125; // // 3 自调用函数 -- 当函数书写完成之后立即调用 // (function () &#123; // console.log('我是自调用函数'); // &#125;)() // // // 4 函数也是一种数据类型 function 也是一种数据类型 var n = 5; var str = '123'; var fn = function () &#123; console.log('我是传过来的函数'); &#125; // console.log(typeof fn); // 4.1 因为函数是一种数据类型，所以函数可以作为另一个函数的参数 // function test(fun) &#123; // // 当我们调用函数的时候。如果没有传递参数，此时形参的值是什么？ // // 此时fun的值是undefined // // console.log(fun); // fun(); // &#125; // test(fn); // // 4.2 因为函数是一种数据类型，所以函数可以作为另一个函数的返回值 function test(a) &#123; var b = 5; return function () &#123; console.log(a + b); &#125; &#125; var fn = test(2); // 此函数返回的结果是一个函数 fn();&lt;/script&gt; 代码规范1.命名规范 变量、函数 的命名 必须要有意义 变量 的名称一般用名词 函数 的名称一般用动词 2.变量规范 操作符的前后要有空格 var name = &apos;zs&apos;; 5 + 6 3.注释规范 // 这里是注释 4.空格规范 if (true) { } for (var i = 0; i &lt;= 100; i++) { } 5.换行规范 var arr = [1, 2, 3, 4]; if (a &gt; b) { } for (var i = 0; i &lt; 10; i++) { } function fn() { } 作用域作用域：变量可以起作用的范围 全局变量和局部变量 全局变量 在任何地方都可以访问到的变量就是全局变量，对应全局作用域 局部变量 只在固定的代码片段内可访问到的变量，最常见的例如函数内部。对应局部作用域(函数作用域) 12不使用var声明的变量是全局变量，不推荐使用。变量退出作用域之后会销毁，全局变量关闭网页或浏览器才会销毁 块级作用域任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。在es5之前没有块级作用域的的概念,只有函数作用域，现阶段可以认为JavaScript没有块级作用域 作用域链只有函数可以制造作用域结构， 那么只要是代码，就至少有一个作用域, 即全局作用域。凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。 将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。 1234567891011// 案例1：function f1() &#123; function f2() &#123; &#125;&#125;var num = 456;function f3() &#123; function f4() &#123; &#125;&#125; 12345678910// 案例2function f1() &#123; var num = 123; function f2() &#123; console.log(num); &#125; f2();&#125;var num = 456;f1(); 预解析 JavaScript代码的执行是由浏览器中的JavaScript解析器来执行的。JavaScript解析器执行JavaScript代码的时候，分为两个过程：预解析过程和代码执行过程 预解析过程： 把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值。 把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用。 先提升var，在提升function。 123456789101112131415161718192021222324// 预解析// 1 变量提升，把变量的声明提升到当前作用域的最上面，不包括变量的赋值// 2 函数提升，把函数的声明提升到当前作用域的最上面，不包括函数的调用// // console.log(num);// var num = 5;// // 预解析// var num;// console.log(num);// num = 5;// // // f1();// function f1() &#123;// console.log('hello');// &#125;// // 预解析// function f1() &#123;// console.log('hello');// &#125;// f1(); JavaScript的执行过程 12345678910111213141516171819202122232425262728293031323334353637// 案例1var a = 25;function abc() &#123; alert(a); var a = 10;&#125;abc(); // // 预解析 // var a; // function abc() &#123; // // 局部作用域 预解析 // var a; // alert(a); // a = 10; // &#125; // a = 25; // abc();// 案例2console.log(a);function a() &#123; console.log('aaaaa');&#125;var a = 1;console.log(a); // 预解析 // 在预解析的过程中如果函数和变量的名字相同，此时函数优先 // var a; // function a() &#123; // console.log('aaaaa'); // &#125; // console.log(a); // a = 1; // console.log(a); 变量提升 变量提升 定义变量的时候，变量的声明会被提升到作用域的最上面，变量的赋值不会提升。 函数提升 JavaScript解析器首先会把当前作用域的函数声明提前到整个作用域的最前面 1234567891011121314151617181920212223242526272829303132333435363738394041// 1、-----------------------------------var num = 10;fun();function fun() &#123; console.log(num); var num = 20;&#125;//2、-----------------------------------var a = 18;f1();function f1() &#123; var b = 9; console.log(a); console.log(b); var a = '123';&#125; // // 预解析 // var a; // function f1() &#123; // var b; // var a; // b = 9; // console.log(a); // console.log(b); // a = '123'; // &#125; // a = 18; // f1();// 3、-----------------------------------f1();console.log(c);console.log(b);console.log(a);function f1() &#123; var a = b = c = 9; console.log(a); console.log(b); console.log(c);&#125; 对象为什么要有对象1234567function printPerson(name, age, sex....) &#123;&#125;// 函数的参数如果特别多的话，可以使用对象简化function printPerson(person) &#123; console.log(person.name); ……&#125; 什么是对象12345现实生活中：万物皆对象，对象是一个具体的事物，一个具体的事物就会有行为和特征。举例： 一部车，一个手机车是一类事物，门口停的那辆车才是对象 特征：红色、四个轮子 行为：驾驶、刹车 JavaScript中的对象123456JavaScript中的对象其实就是生活中对象的一个抽象JavaScript的对象是无序属性的集合。 其属性可以包含基本值、对象或函数。对象就是一组没有顺序的值。我们可以把JavaScript中的对象想象成键值对，其中值可以是数据和函数。对象的行为和特征 特征---属性 行为---方法 事物的特征在对象中用属性来表示。 事物的行为在对象中用方法来表示。 对象字面量 字面量：11 ‘abc’ true [] {}等 12345678var o = &#123; name: 'zs', age: 18, sex: true, sayHi: function () &#123; console.log(this.name); &#125;&#125;; 思考： 1如何把学生对象、老师对象、英雄对象改写成字面量的方式 对象创建方式 对象字面量 12345678var o = &#123; name: 'zs', age: 18, sex: true, sayHi: function () &#123; console.log(this.name); &#125;&#125;; new Object()创建对象 1234567var person = new Object();person.name = 'lisi';person.age = 35;person.job = 'actor';person.sayHi = function() &#123; console.log('Hello,everyBody');&#125; 工厂函数创建对象 1234567891011function createPerson(name, age, job) &#123; var person = new Object(); person.name = name; person.age = age; person.job = job; person.sayHi = function()&#123; console.log('Hello,everyBody'); &#125; return person;&#125;var p1 = createPerson('张三', 22, 'actor'); 自定义构造函数 123456789function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayHi = function()&#123; console.log('Hello,everyBody'); &#125;&#125;var p1 = new Person('张三', 22, 'actor'); 属性和方法如果一个变量属于一个对象所有，那么该变量就可以称之为该对象的一个属性，属性一般是名词，用来描述事物的特征 如果一个函数属于一个对象所有，那么该函数就可以称之为该对象的一个方法，方法是动词，描述事物的行为和功能 new关键字 构造函数 ，是一种特殊的函数。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 构造函数用于创建一类对象，首字母要大写。 构造函数要和new一起使用才有意义。 new在执行时会做四件事情 1234new会在内存中创建一个新的空对象new 会让this指向这个新的对象执行构造函数 目的：给这个新对象加属性和方法new会返回这个新对象 this详解JavaScript中的this指向问题，有时候会让人难以捉摸，随着学习的深入，我们可以逐渐了解 现在我们需要掌握函数内部的this几个特点 1. 函数在定义的时候this是不确定的，只有在调用的时候才可以确定 2. 一般函数直接执行，内部this指向全局window 3. 函数作为一个对象的方法，被该对象所调用，那么this指向的是该对象 4. 构造函数中的this其实是一个隐式对象，类似一个初始化的模型，所有方法和属性都挂载到了这个隐式对象身上，后续通过new关键字来调用，从而实现实例化 对象的使用遍历对象的属性 通过for..in语法可以遍历一个对象 1234567var obj = &#123;&#125;;for (var i = 0; i &lt; 10; i++) &#123; obj[i] = i * 2;&#125;for(var key in obj) &#123; console.log(key + "==" + obj[key]);&#125; 删除对象的属性1234567function fun() &#123; this.name = 'mm';&#125;var obj = new fun(); console.log(obj.name); // mm delete obj.name;console.log(obj.name); // undefined 简单类型和复杂类型的区别 基本类型又叫做值类型，复杂类型又叫做引用类型 值类型：简单数据类型，基本数据类型，在存储时，变量中存储的是值本身，因此叫做值类型。 引用类型：复杂数据类型，在存储是，变量中存储的仅仅是地址（引用），因此叫做引用数据类型。 堆和栈 123堆栈空间分配区别： 1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。 2、堆（操作系统）： 存储复杂类型(对象)，一般由程序员分配释放， 若程序员不释放，由垃圾回收机制回收。 注意：JavaScript中没有堆和栈的概念，此处我们用堆和栈来讲解，目的方便理解和方便以后的学习。 基本类型在内存中的存储 复杂类型在内存中的存储 基本类型作为函数的参数 复杂类型作为函数的参数 123456789101112131415// 下面代码输出的结果?function Person(name,age,salary) &#123; this.name = name; this.age = age; this.salary = salary;&#125;function f1(person) &#123; person.name = "ls"; person = new Person("aa",18,10);&#125;var p = new Person("zs",18,1000);console.log(p.name);f1(p);console.log(p.name); 思考： 123456789101112131415//1. var num1 = 10;var num2 = num1;num1 = 20;console.log(num1);console.log(num2);//2. var num = 50;function f1(num) &#123; num = 60; console.log(num);&#125;f1(num);console.log(num); 内置对象JavaScript中的对象分为3种：内置对象、自定义对象、浏览器对象 JavaScript 提供多个内置对象：Math/Array/Date…. 对象只是带有属性和方法的特殊数据类型。 学习一个内置对象的使用，只要学会其常用的成员的使用（通过查文档学习） 可以通过MDN/W3C来查询 内置对象的方法很多，我们只需要知道内置对象提供的常用方法，使用的时候查询文档。 MDNMozilla 开发者网络（MDN）提供有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。 MDN 通过查询MDN学习Math对象的random()方法的使用 如何学习一个方法？ 方法的功能 参数的意义和类型 返回值意义和类型 demo进行测试 Math对象Math对象不是构造函数，它具有数学常数和函数的属性和方法，都是以静态成员的方式提供 跟数学相关的运算来找Math中的成员（求绝对值，取整） Math 演示：Math.PI、Math.random()、Math.floor()/Math.ceil()、Math.round()、Math.abs() 、Math.max() 123456789Math.PI // 圆周率Math.random() // 生成随机数Math.floor()/Math.ceil() // 向下取整/向上取整Math.round() // 取整，四舍五入Math.abs() // 绝对值Math.max()/Math.min() // 求最大和最小值Math.sin()/Math.cos() // 正弦/余弦Math.power()/Math.sqrt() // 求指数次幂/求平方根 案例 求10-20之间的随机数 随机生成颜色RGB 模拟实现max()/min() Date对象创建 Date 实例用来处理日期和时间。Date 对象基于1970年1月1日（世界标准时间）起的毫秒数。 12345678// 获取当前时间，UTC世界时间，距1970年1月1日（世界标准时间）起的毫秒数var now = new Date();console.log(now.valueOf()); // 获取距1970年1月1日（世界标准时间）起的毫秒数Date构造函数的参数1. 毫秒数 1498099000356 new Date(1498099000356)2. 日期格式字符串 '2015-5-1' new Date('2015-5-1')3. 年、月、日…… new Date(2015, 4, 1) // 月份从0开始 获取日期的毫秒形式 123456789var now = new Date();// valueOf用于获取对象的原始值console.log(date.valueOf()) // HTML5中提供的方法，有兼容性问题var now = Date.now(); // 不支持HTML5的浏览器，可以用下面这种方式var now = + new Date(); // 调用 Date对象的valueOf() 日期格式化方法 1234567toString() // 转换成字符串valueOf() // 获取毫秒值// 下面格式化日期的方法，在不同浏览器可能表现不一致，一般不用toDateString()toTimeString()toLocaleDateString()toLocaleTimeString() 获取日期指定部分 123456789getTime() // 返回毫秒数和valueOf()结果一样getMilliseconds() getSeconds() // 返回0-59getMinutes() // 返回0-59getHours() // 返回0-23getDay() // 返回星期几 0周日 6周6getDate() // 返回当前月的第几天getMonth() // 返回月份，***从0开始***getFullYear() //返回4位的年份 如 2016 案例 写一个函数，格式化日期对象，返回yyyy-MM-dd HH:mm:ss的形式 123456789101112131415161718function formatDate(d) &#123; //如果date不是日期对象，返回 if (!date instanceof Date) &#123; return; &#125; var year = d.getFullYear(), month = d.getMonth() + 1, date = d.getDate(), hour = d.getHours(), minute = d.getMinutes(), second = d.getSeconds(); month = month &lt; 10 ? '0' + month : month; date = date &lt; 10 ? '0' + date : date; hour = hour &lt; 10 ? '0' + hour : hour; minute = minute &lt; 10 ? '0' + minute:minute; second = second &lt; 10 ? '0' + second:second; return year + '-' + month + '-' + date + ' ' + hour + ':' + minute + ':' + second;&#125; 计算时间差，返回相差的天/时/分/秒 123456789101112131415function getInterval(start, end) &#123; var day, hour, minute, second, interval; interval = end - start; interval /= 1000; day = Math.round(interval / 60 / 60 / 24); hour = Math.round(interval / 60 / 60 % 24); minute = Math.round(interval / 60 % 60); second = Math.round(interval % 60); return &#123; day: day, hour: hour, minute: minute, second: second &#125;&#125; Array对象 创建数组对象的两种方式 字面量方式 new Array() 1234567891011121314// 1. 使用构造函数创建数组对象// 创建了一个空数组var arr = new Array();// 创建了一个数组，里面存放了3个字符串var arr = new Array('zs', 'ls', 'ww');// 创建了一个数组，里面存放了4个数字var arr = new Array(1, 2, 3, 4);// 2. 使用字面量创建数组对象var arr = [1, 2, 3];// 获取数组中元素的个数console.log(arr.length); 检测一个对象是否是数组 instanceof Array.isArray() HTML5中提供的方法，有兼容性问题 函数的参数，如果要求是一个数组的话，可以用这种方式来进行判断 toString()/valueOf() toString() 把数组转换成字符串，逗号分隔每一项 valueOf() 返回数组对象本身 数组常用方法 演示：push()、shift()、unshift()、reverse()、sort()、splice()、indexOf() 123456789101112131415161718192021// 1 栈操作(先进后出)push()pop() //取出数组中的最后一项，修改length属性// 2 队列操作(先进先出)push()shift() //取出数组中的第一个元素，修改length属性unshift() //在数组最前面插入项，返回数组的长度// 3 排序方法reverse() //翻转数组sort(); //即使是数组sort也是根据字符，从小到大排序// 带参数的sort是如何实现的？// 4 操作方法concat() //把参数拼接到当前数组slice() //从当前数组中截取一个新的数组，不影响原来的数组，参数start从0开始,end从1开始splice() //删除或替换当前数组的某些项目，参数start, deleteCount, options(要替换的项目)// 5 位置方法indexOf()、lastIndexOf() //如果没找到返回-1// 6 迭代方法 不会修改原数组(可选) html5every()、filter()、forEach()、map()、some()// 7 方法将数组的所有元素连接到一个字符串中。join() 清空数组 123456// 方式1 推荐 arr = [];// 方式2 arr.length = 0;// 方式3arr.splice(0, arr.length); 案例 将一个字符串数组输出为|分割的形式，比如“刘备|张飞|关羽”。使用两种方式实现 12345678910111213141516function myJoin(array, seperator) &#123; seperator = seperator || ','; array = array || []; if (array.length == 0)&#123; return ''; &#125; var str = array[0]; for (var i = 1; i &lt; array.length; i++) &#123; str += seperator + array[i]; &#125; return str;&#125;var array = [6, 3, 5, 6, 7, 8, 0];console.log(myJoin(array, '-'));console.log(array.join('-')) 将一个字符串数组的元素的顺序进行反转。[“a”, “b”, “c”, “d”] -&gt; [ “d”,”c”,”b”,”a”]。使用两种种方式实现。提示：第i个和第length-i-1个进行交换 12345678910111213141516function myReverse(arr) &#123; if (!arr || arr.length == 0) &#123; return []; &#125; for (var i = 0; i &lt; arr.length / 2; i++) &#123; var tmp = arr[i]; arr[i] = arr[this.length - i - 1]; arr[arr.length - i - 1] = tmp; &#125; return arr;&#125;var array = ['a', 'b', 'c'];console.log(myReverse(array));console.log(array.reverse()); 工资的数组[1500, 1200, 2000, 2100, 1800],把工资超过2000的删除 123456789101112131415161718// 方式1var array = [1500,1200,2000,2100,1800];var tmpArray = [];for (var i = 0; i &lt; array.length; i++) &#123; if(array[i] &lt; 2000) &#123; tmpArray.push(array[i]); &#125;&#125;console.log(tmpArray);// 方式2var array = [1500, 1200, 2000, 2100, 1800];array = array.filter(function (item, index) &#123; if (item &lt; 2000) &#123; return true; &#125; return false;&#125;);console.log(array); [“c”, “a”, “z”, “a”, “x”, “a”]找到数组中每一个a出现的位置 1234567var array = ['c', 'a', 'z', 'a', 'x', 'a'];do &#123; var index = array.indexOf('a',index + 1); if (index != -1)&#123; console.log(index); &#125;&#125; while (index &gt; 0); 编写一个方法去掉一个数组的重复元素 12345678910111213141516171819202122232425var array = ['c', 'a', 'z', 'a', 'x', 'a'];function clear() &#123; var o = &#123;&#125;; for (var i = 0; i &lt; array.length; i++) &#123; var item = array[i]; if (o[item]) &#123; o[item]++; &#125;else&#123; o[item] = 1; &#125; &#125; var tmpArray = []; for(var key in o) &#123; if (o[key] == 1) &#123; tmpArray.push(key); &#125;else&#123; if(tmpArray.indexOf(key) == -1)&#123; tmpArray.push(key); &#125; &#125; &#125; return tmpArray;&#125;console.log(clear(array)); 基本包装类型为了方便操作简单数据类型，JavaScript还提供了三个特殊的简单类型类型：String/Number/Boolean 123456789// 下面代码的问题？// s1是基本类型，基本类型是没有方法的var s1 = 'zhangsan';var s2 = s1.substring(5);// 当调用s1.substring(5)的时候，先把s1包装成String类型的临时对象，再调用substring方法，最后销毁临时对象, 相当于：var s1 = new String('zhangsan');var s2 = s1.substring(5);s1 = null; 1234567// 创建基本包装类型的对象var num = 18; //数值，基本类型var num = Number('18'); //类型转换var num = new Number(18); //基本包装类型，对象// Number和Boolean基本包装类型基本不用，使用的话可能会引起歧义。例如：var b1 = new Boolean(false);var b2 = b1 &amp;&amp; true; // 结果是什么 String对象 字符串的不可变 12345var str = 'abc';str = 'hello';// 当重新给str赋值的时候，常量'abc'不会被修改，依然在内存中// 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变// 由于字符串的不可变，在大量拼接字符串的时候会有效率问题 创建字符串对象 1234var str = new String('Hello World');// 获取字符串中字符的个数console.log(str.length); 字符串对象的常用方法 字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串 123456789101112131415161718192021// 1 字符方法charAt() //获取指定位置处字符charCodeAt() //获取指定位置处字符的ASCII码str[0] //HTML5，IE8+支持 和charAt()等效// 2 字符串操作方法concat() //拼接字符串，等效于+，+更常用slice() //从start位置开始，截取到end位置，end取不到substring() //从start位置开始，截取到end位置， end取不到substr() //从start位置开始，截取length个字符// 3 位置方法indexOf() //返回指定内容在元字符串中的位置lastIndexOf() //从后往前找，只找第一个匹配的// 4 去除空白 trim() //只能去除字符串前后的空白// 5 大小写转换方法to(Locale)UpperCase() //转换大写to(Locale)LowerCase() //转换小写// 6 其它search() replace()split() 案例 截取字符串”我爱中华人民共和国”，中的”中华” 123var s = "我爱中华人民共和国";s = s.substr(2,2);console.log(s); “abcoefoxyozzopp”查找字符串中所有o出现的位置 123456789var s = 'abcoefoxyozzopp';var array = [];do &#123; var index = s.indexOf('o', index + 1); if (index != -1) &#123; array.push(index); &#125;&#125; while (index &gt; -1);console.log(array); 把字符串中所有的o替换成! 12345678910var s = 'abcoefoxyozzopp';var index = -1;do &#123; index = s.indexOf('o', index + 1); if (index !== -1) &#123; // 替换 s = s.replace('o', '!'); &#125;&#125; while(index !== -1);console.log(s); 把字符串中的所有空白去掉’ abc xyz a 123 ‘ 123var s = ' abc xyz a 123 '; var arr = s.split(' ');console.log(arr.join('')); 判断一个字符串中出现次数最多的字符，统计这个次数 1234567891011121314151617181920212223var s = 'abcoefoxyozzopp';var o = &#123;&#125;;for (var i = 0; i &lt; s.length; i++) &#123; var item = s.charAt(i); if (o[item]) &#123; o[item] ++; &#125;else&#123; o[item] = 1; &#125;&#125;var max = 0;var char ;for(var key in o) &#123; if (max &lt; o[key]) &#123; max = o[key]; char = key; &#125;&#125;console.log(max);console.log(char); 获取url中?后面的内容，并转化成对象的形式。例如：http://www.itheima.com/login?name=zs&amp;age=18&amp;a=1&amp;b=2 1234567891011121314151617181920212223242526var url = 'http://www.itheima.com/login?name=zs&amp;age=18&amp;a=1&amp;b=2';// 获取url后面的参数function getParams(url) &#123; // 获取? 后面第一个字符的索引 var index = url.indexOf('?') + 1; // url中?后面的字符串 name=zs&amp;age=18&amp;a=1&amp;b=2 var params = url.substr(index); // 使用&amp; 切割字符串 ，返回一个数组 var arr = params.split('&amp;'); var o = &#123;&#125;; // 数组中每一项的样子 key = value for (var i = 0; i &lt; arr.length; i++) &#123; var tmpArr = arr[i].split('='); var key = tmpArr[0]; var value = tmpArr[1]; o[key] = value; &#125; return o;&#125;var obj = getParams(url);console.log(obj);console.log(obj.name);console.log(obj.age); 作业12345678给定一个字符串如：“abaasdffggghhjjkkgfddsssss3444343”问题如下： 1、 字符串的长度 2、 取出指定位置的字符，如：0,3,5,9等3、 查找指定字符是否在以上字符串中存在，如：i，c ，b等 4、 替换指定的字符，如：g替换为22,ss替换为b等操作方法 5、 截取指定开始位置到结束位置的字符串，如：取得1-5的字符串6、 找出以上字符串中出现次数最多的字符和出现的次数 7、 遍历字符串，并将遍历出的字符两头添加符号“@”输出至当前的文档页面。]]></content>
      <categories>
        <category>前端框架</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB之Csharp]]></title>
    <url>%2F2019%2F03%2F20%2FMongoDB%E4%B9%8BCsharp%2F</url>
    <content type="text"><![CDATA[MongoDB之增删改查 使用C#访问MongoDBMongoDB C#驱动概述 MongoDB 四个核心组件 MongoDB.Bson简介BSON保存真实的数据 BsonDocument 123456789101112static void WhatIsBson() &#123; var doc = BsonDocument.Parse(" &#123;\"name\":\"JinXuLiang\",\"age\":45 &#125;"); Console.WriteLine($"Json文档：&#123;doc.ToJson()&#125;"); //转换为二进制形式 var bson = doc.ToBson(); Console.WriteLine($"\n转换为Bson之后：\n&#123;BitConverter.ToString(bson)&#125;"); //从Bson数据中反序列化对象 var deserializedDoc = BsonSerializer.Deserialize&lt;BsonDocument&gt;(bson); Console.WriteLine($"\n从Bson数据中反序列化，得到BsonDocument对象：\n&#123;deserializedDoc&#125;"); &#125; Bson对象模型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172static void TestBsonDocument()&#123; //BsonDocument支持以多重嵌套的方式创建文档 var document = new BsonDocument &#123; &#123; "name", "MongoDB" &#125;, &#123; "type", "Database" &#125;, &#123; "count", 1 &#125;, &#123; "info", new BsonDocument &#123; &#123; "x", 203 &#125;, &#123; "y", 102 &#125; &#125;&#125; &#125;; Console.WriteLine("\nToString()方法输出Json字符串"); //输出：&#123; "name" : "MongoDB", "type" : "Database", "count" : 1, "info" : &#123; "x" : 203, "y" : 102 &#125; &#125; Console.WriteLine(document.ToString()); //文档可以看成是key/value的有序集合，因此，可以通过索引或名字进行访问它的值（BsonValue类型） Console.WriteLine("\n访问文档中指定名字的属性的值"); var firstElementValue = document[0]; //通过索引访问，对应：&#123;"name" : "MongoDB"&#125; var countElementValue = document["count"]; //通过名字访问，对应：&#123;"count" : 1&#125; //最后一个元素，引用一个子文档：&#123; "info" : &#123; "x" : 203, "y" : 102 &#125; &#125; var infoElementValue = document[document.ElementCount - 1]; //BsonValue有一堆的As...方法实现类型转换 Console.WriteLine($"&#123;firstElementValue&#125;,&#123;countElementValue.AsInt32 + 100&#125;"); //输出：MongoDB， 101 Console.WriteLine($"&#123;firstElementValue.IsString&#125;"); //true Console.WriteLine($"&#123;infoElementValue.ToJson()&#125;的类型:&#123;infoElementValue.BsonType&#125;"); //Document Console.WriteLine("\n查询某指定名字的元素是否存在于文档中"); Console.WriteLine(document.Contains("info")); //true Console.WriteLine("\n转换为Dictionary"); //自己及所包容的所有子文档，均被转换为dictionary var dict = document.ToDictionary(); //显示Dictionary中的内容 foreach (var key in dict.Keys) &#123; Console.WriteLine($"&#123;key&#125;:&#123;dict[key]&#125;"); &#125; Console.WriteLine(); Console.WriteLine("\n解析Json字符串为BsonDocument对象，并修改它"); var newDoc = BsonDocument.Parse("&#123; a: 1, b: 2, c: 3 &#125;"); newDoc.Add("d", 4); Console.WriteLine(newDoc.ToString()); //&#123; "a" : 1, "b" : 2, "c" : 3, "d" : 4 &#125; newDoc.Set("a", "Hello"); //修改“a”元素 newDoc.RemoveAt(2);//移除第3个元素 Console.WriteLine(newDoc);//&#123; "a" : "Hello", "b" : 2, "d" : 4 &#125; Console.WriteLine("\n文档克隆"); var cloneDoc = newDoc.Clone(); Console.WriteLine(cloneDoc);//&#123; "a" : "Hello", "b" : 2, "d" : 4 &#125; Console.WriteLine("\n文档合并"); var doc1 = BsonDocument.Parse("&#123;x:1&#125;"); var doc2 = BsonDocument.Parse("&#123;y:2&#125;"); var mergedDoc = doc1.Merge(doc2); Console.WriteLine(mergedDoc);//&#123; "x" : 1, "y" : 2 &#125; Console.WriteLine("\n文档判等"); string json = "&#123; \"x\" : 1, \"y\" : 2 &#125;"; var doc3 = BsonDocument.Parse(json); Console.WriteLine(mergedDoc.CompareTo(doc3)); //0 Console.WriteLine(mergedDoc == doc3);//true Console.WriteLine(mergedDoc.Equals(doc3));//true&#125; 读写Bson/Json文档 1234567891011121314151617static void ReadJson()&#123; var jsonString = "&#123; a: 1 &#125;"; using (var reader = new JsonReader(jsonString)) &#123; //读入“开始标记” reader.ReadStartDocument(); //读取元素名字 string fieldName = reader.ReadName(); Console.WriteLine(fieldName); //读取元素值 int value = reader.ReadInt32(); Console.WriteLine(value); //读入“结束标记” reader.ReadEndDocument(); &#125;&#125; 12345678910111213141516171819202122232425static void TestPOCOJsonBson()&#123; //创建一个组合的对象 var client = new Client() &#123; Age = 40, FirstName = "bob" &#125;; client.Addresses.Add("one"); client.Addresses.Add("two"); client.Contact.Email = "bitfan@sina.com"; client.Contact.Phone = "12345678"; //Mongodb提供了将POCO对象直接转换为Json字符串的功能 var json = client.ToJson(); Console.WriteLine(json); Console.WriteLine("\n---------------------"); //可将POCO对象直接转换为Bson，得到一个字节数组 var bson = client.ToBson(); Console.WriteLine(bson); Console.WriteLine("\n---------------------"); //可将POCO对象直接转换为ToBsonDocument，可以直接操作它 var bsonDoc = client.ToBsonDocument(); Console.WriteLine(bsonDoc);&#125; 1234567891011public class Client&#123; public string FirstName &#123; get; set; &#125; public int Age &#123; get; set; &#125; public List&lt;string&gt; Addresses = new List&lt;string&gt;(); public Contact Contact = new Contact();&#125; 12345public class Contact&#123; public string Email &#123; get; set; &#125; public string Phone &#123; get; set; &#125;&#125; 分工合作 类型映射 多态如何处理 使用代码操纵MongoDB12345678910111213141516171819202122232425262728293031323334353637383940414243#region "使用代码操纵MongoDB" /// &lt;summary&gt; /// 创建数据库与集合示例 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt;private static async Task CreateDatabaseAndCollection()&#123; var client = new MongoClient(); Random ran = new Random(); int value = ran.Next(1, 100); var database = client.GetDatabase($"MyDB&#123;value&#125;"); await database.CreateCollectionAsync($"MyCollection&#123;value&#125;"); Console.WriteLine($"数据库MyDB&#123;value&#125;，集合MyCollection&#123;value&#125;创建完毕");&#125;/// &lt;summary&gt;/// 列出当前Server上的所有数据库/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;private static async Task ListDatabase()&#123; var client = new MongoClient(); using (var cursor = await client.ListDatabasesAsync()) &#123; await cursor.ForEachAsync(d =&gt; Console.WriteLine(d.ToString())); &#125;&#125;/// &lt;summary&gt;/// 列出数据库中的所有集合/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;private static async Task ListCollections(string databaseName)&#123; var client = new MongoClient(); var db = client.GetDatabase(databaseName); Console.WriteLine($"数据库&#123;databaseName&#125;中包容集合："); using (var cursor = await db.ListCollectionsAsync()) &#123; await cursor.ForEachAsync(d =&gt; Console.WriteLine(d.ToString())); &#125;&#125;#endregion 三个重要接口 MongoClient MongoDatabase C#编程实现CRUD获取或创建MongoCollection 插入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#region "插入 /// &lt;summary&gt; /// 插入BsonDocument对象到集合中 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; static async Task InsertData()&#123; var _client = new MongoClient(); var _database = _client.GetDatabase("test"); var collection = _database.GetCollection&lt;BsonDocument&gt;("myCollection"); BsonDocument doc = BsonDocument.Parse("&#123;a:1,b:2&#125;"); //插入单条记录 //Note:InsertManyAsync()可以插入多条记录 await collection.InsertOneAsync(doc); Console.WriteLine("插入结束"); //显示处理结果 await ListCollections("test"); await ShowAllDocumentOfCollection("test", "myCollection");&#125;/// &lt;summary&gt;/// 插入MyClass对象到myCollection集合中/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;static async Task InsertPOCO()&#123; var _client = new MongoClient(); var _database = _client.GetDatabase("test"); //指明文档中保存的对象类型为MyClass var collection = _database.GetCollection&lt;MyClass&gt;("myCollection"); int ranValue = new Random().Next(1, 10000); //注意MyClassId字段在定义时加不加[BsonId],有重要的影响 //如果不加，则MongoDB会自己添加一个ObjectId作为对象标识， //如果加了，则要求值必须唯一，否则，在插入时会抛出异常报告“Key重复” MyClass obj = new MyClass() &#123; MyClassId = ranValue, Info = $"自定义的对象&#123;ranValue&#125;" &#125;; await collection.InsertOneAsync(obj); Console.WriteLine("POCO对象插入结束"); await ShowAllDocumentOfCollection("test", "myCollection");&#125;#endregion 12345678[BsonDiscriminator("myclass")] public class MyClass &#123; [BsonId] public int MyClassId &#123; get; set; &#125; public string Info &#123; get; set; &#125; &#125; 1234567891011121314/// &lt;summary&gt;/// 列出数据库中的所有集合/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;private static async Task ListCollections(string databaseName)&#123; var client = new MongoClient(); var db = client.GetDatabase(databaseName); Console.WriteLine($"数据库&#123;databaseName&#125;中包容集合："); using (var cursor = await db.ListCollectionsAsync()) &#123; await cursor.ForEachAsync(d =&gt; Console.WriteLine(d.ToString())); &#125;&#125; 1234567891011121314151617/// 测试辅助方法，显示指定数据库中指定集合的所有文档/// &lt;/summary&gt;/// &lt;param name="databseName"&gt;&lt;/param&gt;/// &lt;param name="collectionName"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;static async Task ShowAllDocumentOfCollection(string databseName, string collectionName)&#123; var client = new MongoClient(); var database = client.GetDatabase(databseName); var collection = database.GetCollection&lt;BsonDocument&gt;(collectionName); var docs = await collection.Find(new BsonDocument()).ToListAsync(); Console.WriteLine($"集合&#123;collection.CollectionNamespace.CollectionName&#125;中有数据："); foreach (var doc in docs) &#123; Console.WriteLine(doc); &#125;&#125; 删除 123456789101112131415161718192021222324252627282930313233343536#region "删除" //删除BsonDocument //使用DeleteOne/DeleteOneAsync删除单个文档 //使用DeleteMany/DeleteManyAsync删除多个文档 static async Task DeleteUseBsonDocument()&#123; var _client = new MongoClient(); var _database = _client.GetDatabase("test"); var collection = _database.GetCollection&lt;BsonDocument&gt;("myCollection"); //使用MongoDB内置的Builder以强类型方式定义搜索条件，其泛型参数表明文档中保存的数据是BsonDocument还是POCO类型 //也可以使用BsonDocument.Parse()方法使用Json字符串定义搜索条件 //Note: //使用Builder方式，比较麻烦，但Visual Studio能给出智能提示，不易出错。 //使用Parse方式，比较简洁，但要求对MongoDB的JavaScript脚本命令比较熟悉， //易出错且难调试，因为必须要等到运行时才能发现错误。 var filter = Builders&lt;BsonDocument&gt;.Filter.Eq("a", 1); //执行删除命令 var result = await collection.DeleteManyAsync(filter); Console.WriteLine($"删除记录数：&#123;result.DeletedCount&#125;");&#125;//删除MyClassstatic async Task DeleteUseLambda()&#123; var _client = new MongoClient(); var _database = _client.GetDatabase("test"); var collection = _database.GetCollection&lt;MyClass&gt;("myCollection"); //MongoDB C#驱动支持使用Lambda表达式定义的搜索条件(推荐使用） var result = await collection.DeleteManyAsync(obj =&gt; obj.MyClassId == 100); Console.WriteLine($"删除记录数：&#123;result.DeletedCount&#125;");&#125;#endregion 查找1234567891011121314151617181920212223242526272829303132333435363738394041/// &lt;summary&gt;/// 插入测试数据/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;static async Task InsertExmapleMyClassDataToCollection()&#123; var _client = new MongoClient(); var _database = _client.GetDatabase("test"); var collection = _database.GetCollection&lt;MyClass&gt;("myCollection"); await DeleteAllDocsOfCollection("test", "myCollection"); Console.WriteLine("向test数据库中的myCollection集合添加数据："); var objects = new List&lt;MyClass&gt;(); for (int i = 1; i &lt;= 100; i++) &#123; objects.Add(new MyClass() &#123; MyClassId = i, Info = "对象" + i &#125;); &#125; await collection.InsertManyAsync(objects); Console.WriteLine($"共插入&#123;objects.Count&#125;条数据到集合中");&#125;/// &lt;summary&gt;/// 清空指定数据库中指定集合的数据/// &lt;/summary&gt;/// &lt;param name="databaseName"&gt;&lt;/param&gt;/// &lt;param name="collectionName"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;static async Task DeleteAllDocsOfCollection(string databaseName, string collectionName)&#123; var client = new MongoClient(); var database = client.GetDatabase(databaseName); var collection = database.GetCollection&lt;BsonDocument&gt;(collectionName); var result = await collection.DeleteManyAsync(new BsonDocument()); Console.WriteLine($"数据库&#123;databaseName&#125;的&#123;collectionName&#125;已被清空,共删除&#123;result.DeletedCount&#125;个文档");&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#region "查询" //---------------实现查找功能--------------------------- //Find()方法返回一个IFindFluent对象，可以调用ToListAsync方法将其传换为一个内存集合，适合于比较小的数据集。 //FindAsync()方法返回一个IAsyncCursor对象，可以使用它遍历整个数据集，适用于比较大的数据集，可以减少内存占用。 //Note: //MongoDB无法实现跨集合的查询。所有查询都是在单个集合内进行的， //如果需要进行跨集合的查询，必须执行两次查询，然后再由应用程序负责进一步地处理。 //------------------------------------------------------------------------------ /// &lt;summary&gt; /// 一次性提取所有数据，放在内存中 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; static async Task FindDataInMemory()&#123; var _client = new MongoClient(); var _database = _client.GetDatabase("test"); var collection = _database.GetCollection&lt;MyClass&gt;("myCollection"); //定义搜索条件 var filter = new BsonDocument(); //仅提取前10条记录 var objects = (await collection.Find(filter).ToListAsync()).Take(10); foreach (var obj in objects) &#123; Console.WriteLine($"&#123;obj.MyClassId&#125;:&#123;obj.Info&#125;"); &#125;&#125;//使用Cursor一边提取数据，一边处理它static async Task FindDataUseCursor()&#123; var _client = new MongoClient(); var _database = _client.GetDatabase("test"); var collection = _database.GetCollection&lt;MyClass&gt;("myCollection"); //定义搜索条件 var filter = new BsonDocument(); var count = 0; using (var cursor = await collection.FindAsync(filter)) &#123; //仅输出前10条记录 while (await cursor.MoveNextAsync()) &#123; var batch = cursor.Current; foreach (var obj in batch) &#123; Console.WriteLine($"&#123;obj.MyClassId&#125;:&#123;obj.Info&#125;"); count++; if (count &gt;= 10) break; &#125; &#125; &#125;&#125;//查询单条记录//可以使用的方法：//(1)First/FirstAsync, FirstOrDefault/FirstOrDefaultAsync//(2)Single/SingleAsync, SingleOrDefaul/SingleOrDefaultAsyncstatic async Task FindOneByCondition()&#123; var _client = new MongoClient(); var _database = _client.GetDatabase("test"); var collection = _database.GetCollection&lt;MyClass&gt;("myCollection"); var eqFilter = Builders&lt;MyClass&gt;.Filter.Eq("MyClassId", 1); var obj = await collection.Find(eqFilter).FirstOrDefaultAsync(); Console.WriteLine("使用Builder构建搜索条件，查询单条记录。"); if (obj != null) &#123; Console.WriteLine($"&#123;obj.MyClassId&#125;:&#123;obj.Info&#125;"); &#125; else &#123; Console.WriteLine("没找到指定的记录"); &#125;&#125;/// &lt;summary&gt;/// 使用Builder构建搜索条件查询多条记录/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;static async Task FindManyByCondition()&#123; var _client = new MongoClient(); var _database = _client.GetDatabase("test"); var collection = _database.GetCollection&lt;MyClass&gt;("myCollection"); //构建查询条件 var builder = Builders&lt;MyClass&gt;.Filter; var rangeFilter = builder.Gt("MyClassId", 10) &amp; builder.Lte("MyClassId", 20); var objects = await collection.Find(rangeFilter).ToListAsync(); Console.WriteLine("使用Builder构建搜索条件，查询多条记录。"); foreach (var obj in objects) &#123; Console.WriteLine($"&#123;obj.MyClassId&#125;:&#123;obj.Info&#125;"); &#125;&#125;#endregion 1234567891011121314151617181920212223/// &lt;summary&gt;/// 插入用于排序的测试数据/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;static async Task InsertExmaplePersonDataToCollection()&#123; var _client = new MongoClient(); var _database = _client.GetDatabase("test"); var collection = _database.GetCollection&lt;Person&gt;("People"); await DeleteAllDocsOfCollection("test", "People"); Random ran = new Random(); var objects = new List&lt;Person&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; objects.Add(new Person() &#123; Name = "Person" + ran.Next(1, 1000), Birthday = DateTime.Now.AddYears(-(ran.Next(1, 50))) &#125;); &#125; await collection.InsertManyAsync(objects); Console.WriteLine($"共插入&#123;objects.Count&#125;条数据到People集合中");&#125; 1234567891011121314public class Person&#123; public ObjectId _id &#123; get; set; &#125; = ObjectId.GenerateNewId(); public string Name &#123; get; set; &#125; /// &lt;summary&gt; /// 注意一下，MongoDB保存的是标准时间，因此，中国时间要多8小时，使用以下这个标记 /// 可以在序列化和反序列化对象时，自动按照当前时区修正时间 /// &lt;/summary&gt; [BsonDateTimeOptions(Kind = DateTimeKind.Local)] public DateTime Birthday &#123; get; set; &#125; = DateTime.Now.AddYears(-20);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#region "排序" //为BsonDocument排序，适用于文档类型未知的集合 static async Task SortUseBsonDocument()&#123; var _client = new MongoClient(); var _database = _client.GetDatabase("test"); var collection = _database.GetCollection&lt;BsonDocument&gt;("People"); var filter = new BsonDocument(); //按生日降序、姓名升序排列 var sort = Builders&lt;BsonDocument&gt;.Sort .Descending("Birthday").Ascending("Name"); var result = await collection.Find(filter).Sort(sort).ToListAsync(); int count = 0; foreach (var item in result) &#123; count++; if (count &gt; 10) break; Console.WriteLine(item); &#125;&#125;//使用Person类，以强类型方式实现排序static async Task SortUsePersonClass()&#123; var _client = new MongoClient(); var _database = _client.GetDatabase("test"); var collection = _database.GetCollection&lt;Person&gt;("People"); FilterDefinition&lt;Person&gt; filter = "&#123;&#125;"; //按生日降序、姓名升序排列,使用Lambda表达式以强类型方式定义 var sort = Builders&lt;Person&gt;.Sort .Descending(p =&gt; p.Birthday).Ascending(p =&gt; p.Name); var result = await collection.Find(filter).Sort(sort).ToListAsync(); int count = 0; foreach (var item in result) &#123; count++; if (count &gt; 10) break; //注意生日的值 //Birthday属性是否添加 [BsonDateTimeOptions(Kind = DateTimeKind.Local)] //决定了此值是否需要进行时区调整 Console.WriteLine($"&#123;item.Name&#125;:&#123;item.Birthday&#125;"); &#125;&#125;#endregion 更新 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#region "更新" //-----------------------更新-------------------------------------------------- //UpdateOneAsync:更新一个文档（_id不变） //UpdateManyAsync:更新多个文档（_id不变） //ReplaceOneAsync:使用一个新文档替换掉一个老文档（_id不变） //Note: //Update系列方法适合于“局部调整”，要改动的地方通常不算多。 //Repace系列方法适合于“大换血”，要改动的地方通常很多。 //注意替换和被替换的文档必须有一致的“_id”。因此，准备“替换”的文档时，可以省略掉“_id”。 //---------------------------------------------------------------------------- //更新示例 static async Task TestUpdateOne()&#123; var _client = new MongoClient(); var _database = _client.GetDatabase("test"); var collection = _database.GetCollection&lt;BsonDocument&gt;("People"); var filter = new BsonDocument(); var update = Builders&lt;BsonDocument&gt;.Update .Set("Name", $"新名字&#123;DateTime.Now&#125;") //Name属性值设为“新名字” .AddToSet("Resume", "个人简历") //添加一个新属性，其值为“个人简历” .Rename("Birthday", "BornYear") //将BirthDay属性改名为“BornYear” ; var orginal = await collection.Find(filter).FirstAsync(); Console.WriteLine($"更新之前:&#123;orginal&#125;"); //虽然有多条符合筛选条件，但只有一条被更新 var result = await collection.UpdateOneAsync(filter, update); Console.WriteLine($"匹配数&#123;result.MatchedCount&#125;,更新数&#123;result.ModifiedCount&#125;"); var updated = await collection.Find(filter).FirstAsync(); Console.WriteLine($"更新之后:&#123;updated&#125;");&#125;//Replace示例static async Task TestReplaceOneAsync()&#123; var _client = new MongoClient(); var _database = _client.GetDatabase("test"); var collection = _database.GetCollection&lt;BsonDocument&gt;("myCollection"); await collection.InsertOneAsync(BsonDocument.Parse("&#123;testId:10000&#125;")); var filter = new BsonDocument("testId", 10000); //被替换的文档与替换的文档，其“_id”必须一致。 var replacement = new BsonDocument &#123; &#123; "testId", 10000 &#125;, &#123; "x", 2 &#125; &#125;; var result = await collection.ReplaceOneAsync(filter, replacement); var found = await collection.Find(filter).FirstAsync(); Console.WriteLine(found);&#125;//查找并删除//Note://MongoDB C# Driver提供了以下的简捷方法：//FindOneAndDelete\FindOneAndReplace\FindOneAndUpdatestatic async Task TestFindOneAndDeleteAsync()&#123; var _client = new MongoClient(); var _database = _client.GetDatabase("test"); var collection = _database.GetCollection&lt;BsonDocument&gt;("myCollection"); var filter = new BsonDocument("_id", 10000); var found = await collection.Find(filter).FirstOrDefaultAsync(); if (found == null) &#123; await collection.InsertOneAsync( BsonDocument.Parse("&#123;_id:10000,info: 'this is a message'&#125;")); &#125; var result = await collection.FindOneAndDeleteAsync(filter); Console.WriteLine($"&#123;result&#125;已被删除");&#125;#endregion 使用LINQ for MongoDB 12345678910111213141516171819202122232425//---------------------------------------------------------//MongoDB支持C#的LINQ查询，这是一种完成复杂查询的有效方法，可以避免编写复杂的MongoDB查询语句。//只需引入以下命名空间，就可以针对MongoDB编写LINQ查询：//using MongoDB.Driver.Linq;//支持的LINQ标准查询运算符://Any、Count/LongCount、Distinct、ElementAt、First/Last、Max/Min、OfType、OrderBy/OrderByDescending//Select、Single、Skip/Take、ThenBy、Wherestatic void TestGetPersonDocuments()&#123; var _client = new MongoClient(); var _database = _client.GetDatabase("test"); var collection = _database.GetCollection&lt;Person&gt;("People"); //需要调用AsQueryable()方法 var queryable = collection.AsQueryable(); //编写LINQ查询 var query = from p in queryable where p.Birthday &gt; DateTime.Now.AddYears(-20) select p; foreach (var item in query) &#123; Console.WriteLine($"&#123;item.Name&#125;:&#123;item.Birthday&#125;"); &#125;&#125; 学会构建辅助对象 指定字段 指定过滤器 GridFs概述GridFs是什么？ 如何管理文件 GridFS编程模型 GridFSBucket编程模型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/// &lt;summary&gt;/// 测试文件的上传/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;static async Task TestUploadFile()&#123; IMongoClient client = new MongoClient(); var database = client.GetDatabase("test"); //创建GridFSBucket对象，注意它是与MongoDatabase对象挂钩的，意味着每个Database独立管理自己的bucket var bucket = new GridFSBucket(database); //准备从course.txt文件中提取数据 using (Stream source = new FileStream("course.txt", FileMode.Open)) &#123; //将文件内容上传到MongoDB Server，注意第一个参数指定了文件名，它将成为日后操作文件的依据 var id = await bucket.UploadFromStreamAsync("course", source); Console.WriteLine($"上传结束:&#123;id&#125;"); &#125;&#125;/// &lt;summary&gt;/// 下载文件，保存到磁盘上/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;static async Task TestDownFile()&#123; IMongoClient client = new MongoClient(); var database = client.GetDatabase("test"); var bucket = new GridFSBucket(database); //查找符合要求的文件 var filter = Builders&lt;GridFSFileInfo&gt;.Filter.Eq(fileInfo =&gt; fileInfo.Filename, "course"); var result = await (await bucket.FindAsync(filter)).FirstOrDefaultAsync(); if (result != null) &#123; ObjectId downLoadId = result.Id; //下载回来的数据将写入本地磁盘 using (Stream source = new FileStream("course_download.txt", FileMode.Create)) &#123; //开始下载 await bucket.DownloadToStreamAsync(downLoadId, source); &#125; Process.Start("course_download.txt"); Console.WriteLine($"下载结束:&#123;downLoadId&#125;"); &#125; else &#123; Console.WriteLine("未找到可下载的文件"); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445/// &lt;summary&gt;/// 展示MetaData的用法/// MetaData可用于给文件附加一些额外的信息，/// 比如，当GridFS用于向浏览器提供二进制的Web资源时，/// 可以MetaData部分放置此资源的MIME信息/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;static async Task TestUploadByteArrayWithMetaData()&#123; IMongoClient client = new MongoClient(); var database = client.GetDatabase("test"); var bucket = new GridFSBucket(database); //用于上传的二进制数据 byte[] data = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 &#125;; //添加元数据 var options = new GridFSUploadOptions &#123; Metadata = new BsonDocument &#123; &#123;"info","这是用于附加额外信息的元数据" &#125;, &#123;"extra",1000 &#125; &#125; &#125;; //将元数据与真实数据一起打包上传到MongoDB var id = await bucket.UploadFromBytesAsync("binaryArray", data, options); Console.WriteLine($"二进制数组上传完毕:&#123;id&#125;");&#125;/// &lt;summary&gt;/// 下载二进制数据/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;static async Task TestDownloadByteArray()&#123; IMongoClient client = new MongoClient(); var database = client.GetDatabase("test"); var bucket = new GridFSBucket(database); //按名字查找并下载文件，如果名字没找到，异步调用版本将抛出一个AggregateException， //其内部包容GridFSFileNotFoundException var bytes = await bucket.DownloadAsBytesByNameAsync("binaryArray"); Console.WriteLine($"下载结束:&#123;BitConverter.ToString(bytes)&#125;");&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/// &lt;summary&gt;/// 每个buket可以有一个名字，如果不指定，则使用fs.files和fs.chunks集合保存数据/// 如果指定了名字，比如“others”,/// 则使用others.files和others.chunks保存文件/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;static async Task TestUploadFileSaveToOtherBucket()&#123; IMongoClient client = new MongoClient(); var database = client.GetDatabase("test"); //指定用于保存Bucket的集合的名字 GridFSBucketOptions options = new GridFSBucketOptions() &#123; BucketName = "others" &#125;; var bucket = new GridFSBucket(database, options); Stream source = new FileStream("course.txt", FileMode.Open); var id = await bucket.UploadFromStreamAsync("course", source); source.Close(); Console.WriteLine($"上传结束:&#123;id&#125;");&#125;/// &lt;summary&gt;/// “提取可以下载的所有文件清单”方式一：直接访问相应集合/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;static async Task ListAllFiles()&#123; IMongoClient client = new MongoClient(); var database = client.GetDatabase("test"); //提取出fs.files集合中的所有文档 var fileInfo = await database.GetCollection&lt;GridFSFileInfo&gt;("fs.files").FindAsync(new BsonDocument()); //转换为GridFSFileInfo对象的集合 var files = await fileInfo.ToListAsync(); //遍历输出文件的信息 var setting = new JsonWriterSettings() &#123; Indent = true &#125;; foreach (var file in files) &#123; Console.WriteLine($"&#123;file.ToJson(setting)&#125;"); &#125;&#125;/// &lt;summary&gt;/// “通过Bucket获取可以下载文件清单”方式二：使用Bucket/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;static async Task ListAllFilesUseBucket()&#123; IMongoClient client = new MongoClient(); var database = client.GetDatabase("test"); GridFSBucketOptions options = new GridFSBucketOptions() &#123; BucketName = "others" &#125;; var bucket = new GridFSBucket(database, options); var files = await ((await bucket.FindAsync(new BsonDocument())).ToListAsync()); var setting = new JsonWriterSettings() &#123; Indent = true &#125;; foreach (var file in files) &#123; Console.WriteLine($"&#123;file.ToJson(setting)&#125;"); &#125;&#125;static async Task DeleteAllFiles()&#123; IMongoClient client = new MongoClient(); var database = client.GetDatabase("test"); var bucketDefault = new GridFSBucket(database); GridFSBucketOptions options = new GridFSBucketOptions() &#123; BucketName = "others" &#125;; var bucketOthers = new GridFSBucket(database, options); await bucketDefault.DropAsync(); await bucketOthers.DropAsync(); Console.WriteLine("所有文件都己经删除");&#125; GridFs实例]]></content>
      <categories>
        <category>.NET Framework</category>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB初识]]></title>
    <url>%2F2019%2F03%2F18%2FMongoDB%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[认识MongoDB MongoDB概述什么是MongoDB NoSQL数据库的几个特征 MongoDB特点 如何组织数据 如何保存数据 何时选择使用MongoDB 结论 MongoDB的安装与配置搭建学习环境 配置MongoDBMongoClient与Server MongoDB Shell 创建数据库 Collection操作 CRUD 文档的标识 插入数据 更新数据 数据的删除 查询数据 排序]]></content>
      <categories>
        <category>.NET Framework</category>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分层架构设计实践]]></title>
    <url>%2F2019%2F03%2F17%2F%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[干货 数据存取层主要职责 数据存储层的数据转换工作 解决数据不匹配问题的方法 Repository设计模式DDD分层架构中的仓储模式 Repository与聚合对象 DDD如何使用聚合对象 如何编写一个Repository 实际开发如何使用 常用技术手段 使用EntityFramework 是否应该返回IQueryable 定义一个“父接口”的诱惑 存在的问题 改善设计 设计指南 分布式环境如何跟踪实体状态 Unit Of Work设计模式典型场景 事务支持 构建跨多个Repository的事务 实现 解决并发冲突后来者居上 乐观策略 悲观策略 表示层与应用服务层 关于表示层 Web应用中国两种页面生成方式 基本编程模式 应用服务层 实际开发可以因地制宜 向外界提供服务 领域层 领域层的设计与开发要点 领域模型的好处 领域层的两大构成要素 领域模型的构建方法 领域对象 领域服务 DDD建议 不要使用“贫血”模型 领域对象的创建工厂 领域层中的限界上下文]]></content>
      <categories>
        <category>Object Oriented</category>
        <category>领域驱动</category>
      </categories>
      <tags>
        <tag>软件设计</tag>
        <tag>领域驱动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[领域模型的构建]]></title>
    <url>%2F2019%2F03%2F16%2F%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[新思想武装大脑 实体、值对象值对象职责 职责实现方式 为什么将数据封装为值类型 编程实现 判等规则 开发建议 实体DDD实体对象的特点 如何为实体建模 标识的确定方法 实体标识的生成策略 实体判等原则 值类型和实体类型的判等 实体的状态 实体vs值对象 聚合对象聚合对象概述 聚合对象之间的相互访问 何时“聚合对象” Aggregate可以简化对象之间的交互 “聚合跟”的职责 聚合设计指南 什么是Repository EF与“贫血模型” 处理“贫血模型” 聚合对象中属性的验证 领域服务和应用服务领域服务领域逻辑 领域逻辑的实现 领域服务与领域层 应用服务什么是应用服务 ApplicationService典型用法 领域事件 典型开发场景 直观做法 “领域事件驱动”解决方案 领域事件的典型开发模式 处理“重复事件” 跨越限界上下文的事件]]></content>
      <categories>
        <category>Object Oriented</category>
        <category>领域驱动</category>
      </categories>
      <tags>
        <tag>软件设计</tag>
        <tag>领域驱动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分层架构软件系统设计]]></title>
    <url>%2F2019%2F03%2F15%2F%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[正确的做事 SmartUI型的Web应用 分层软件系统架构概述 分层架构相关设计模式Transaction Script TableModule ActiveRecord DDD设计模式 DDD中分层架构]]></content>
      <categories>
        <category>Object Oriented</category>
        <category>领域驱动</category>
      </categories>
      <tags>
        <tag>软件设计</tag>
        <tag>领域驱动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[领域驱动之程序猿视角]]></title>
    <url>%2F2019%2F03%2F14%2F%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E4%B9%8B%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%A7%86%E8%A7%92%2F</url>
    <content type="text"><![CDATA[认识这个世界不容易 DDD概述建模的重要性 以数据为中心的开发流程 数据/技术驱动还是业务驱动 DDD的总体想法 DDD是什么 DDD怎样开发软件？ DDD的两个阶段 DDD基本流程 DDD眼中的软件系统 DDD适合的领域 为什么关注DDD 开发中应用DDD的问题 DDD的核心要素 通用语言 通用语言的产生 什么是通用语言 如何建立通用语言 领域模型 什么叫“领域” 领域建模准备工作 领域模型的三种主要元素 领域模型的核心 使用“模块”进行管理 限界上下文 上下文映射展示信息 限界上下文之间的协作关系 典型的限界上下文之间关系 “反腐层” BoundedContext的技术实现 BoundedContext与分成架构 领域模型的重构软件开发中重构 为什么要重构领域模型 组合 抽象 DDD领域模型重构的经验法则 模型重构的价值]]></content>
      <categories>
        <category>Object Oriented</category>
        <category>领域驱动</category>
      </categories>
      <tags>
        <tag>软件设计</tag>
        <tag>领域驱动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象分析与设计方法]]></title>
    <url>%2F2019%2F03%2F13%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[软件系统开发流程 OOA、OOD和OOPOOA OOD OOP OOAD的建模语言 小结 面向对象软件开发过程详解软件方法学 开发模型 方法的优越性 建立系统需求分析模型需求分析建模要素什么叫需求分析 “需求分析”与“系统分析” 区分问题域与系统责任 系统边界 参与者 Actor可以相互继承 用例 用例的标准图符 三种典型用例之间关系 参与者和用例之间的关系 需求分析建模的具体步骤基本步骤 确定系统边界 确定参与者 定义用例 确定参与者与用例间关系 绘制用例图 对象与类的抽取 发现对象和类的抽取对象和类 系统分析的关键 如何发现对象 定义属性和操作概念 具体方法 注意 需求分析建模指导抽象与封装“抽象”原则 应用“分类” “封装”原则 “粒度控制”原则 “消息”为对象之间协作建模 对象的行为 建模场景“一般”与“特殊” 建模场景：整体与部分 一个问题多个解决方案 建模场景：对象之间的关联 从分析到设计OOD基础 OOD和OOA之间的关系 OOD的出发点 具体设计指导 类的重构 UML类图与包图表达静态结构 OOD实施指南]]></content>
      <categories>
        <category>Object Oriented</category>
        <category>面向对象软件设计</category>
      </categories>
      <tags>
        <tag>软件设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几种常见设计模式概述]]></title>
    <url>%2F2019%2F03%2F12%2F%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[软件设计模式 设计模式引论 什么是设计模式 Builder模式 123456789101112131415161718//计算机类namespace ComputerStore&#123; public class Computer &#123; //CPU频率单位：GHz public decimal CpuFrequency &#123; get; set; &#125; public int AmountOfCores &#123; get; set; &#125; public string DriveType &#123; get; set; &#125; //内存单位：M public int AmountOfRam &#123; get; set; &#125; public override string ToString() &#123; return string.Format("CPU频率：&#123;0&#125;GHz,&#123;1&#125;核,硬盘类型：&#123;2&#125;,内存：&#123;3&#125;M", CpuFrequency, AmountOfCores, DriveType, AmountOfRam); &#125; &#125;&#125; 1234567891011121314151617//抽象基类 构造计算机类namespace ComputerStore&#123; public abstract class ComputerBuilder &#123; protected readonly Computer _computer = new Computer(); public abstract void SetCores(); public abstract void SetCpuFrequency(); public abstract void SetRam(); public abstract void SetDriveType(); public virtual Computer GetComputer() &#123; return _computer; &#125; &#125;&#125; 1234567891011121314151617181920212223242526//Expensive ComputerBuildernamespace ComputerStore&#123; public class ExpensiveComputerBuilder : ComputerBuilder &#123; public override void SetCores() &#123; _computer.AmountOfCores = 4; &#125; public override void SetCpuFrequency() &#123; _computer.CpuFrequency = 3.6m; &#125; public override void SetRam() &#123; _computer.AmountOfRam = 8192; &#125; public override void SetDriveType() &#123; _computer.DriveType = "ssd"; &#125; &#125;&#125; 1234567891011121314151617181920212223242526//CheapComputerBuildernamespace ComputerStore&#123; class CheapComputerBuilder : ComputerBuilder &#123; public override void SetCores() &#123; _computer.AmountOfCores = 2; &#125; public override void SetCpuFrequency() &#123; _computer.CpuFrequency = 2.0m; &#125; public override void SetRam() &#123; _computer.AmountOfRam = 512; &#125; public override void SetDriveType() &#123; _computer.DriveType = "hdd"; &#125; &#125;&#125; 1234567891011121314151617//mainnamespace ComputerStore&#123; class Program &#123; static void Main(string[] args) &#123; var store = new MyComputerStore(); Console.WriteLine("出售低配置的电脑"); Console.WriteLine(store.Build(new CheapComputerBuilder())); Console.WriteLine("出售高配置的电脑"); Console.WriteLine(store.Build(new ExpensiveComputerBuilder())); Console.ReadKey(); &#125; &#125;&#125; 123456789101112131415namespace ComputerStore&#123; public class MyComputerStore &#123; public Computer Build(ComputerBuilder builder) &#123; builder.SetCores(); builder.SetCpuFrequency(); builder.SetRam(); builder.SetDriveType(); return builder.GetComputer(); &#125; &#125;&#125; Factory模式(断开两个类之间的依赖关系) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199namespace IntAndDouble&#123; class Program &#123; static void Main(string[] args) &#123; //TestVersion1(); //TestVersion2(); //TestVersion3(); TestVersion4(new version4.IntDataFactory()); TestVersion4(new version4.DoubleDataFactory()); Console.ReadKey(); &#125; /// &lt;summary&gt; /// 版本一：直接实例化IntDataClass和DoubleDataClass /// 代码直接依赖于这两个具体类型：IntDataClass和DoubleDataClass /// &lt;/summary&gt; static void TestVersion1() &#123; Console.WriteLine("\nversion1:"); version1.IntDataClass intObj = new version1.IntDataClass(); intObj.DisplayValue(); version1.DoubleDataClass doubleObj = new version1.DoubleDataClass(); doubleObj.DisplayValue(); &#125; namespace version1 &#123; class IntDataClass &#123; private int Value = 100; public void DisplayValue() &#123; Console.WriteLine("Value=&#123;0&#125;", Value); &#125; &#125; class DoubleDataClass &#123; public double Value = 100.001; public void DisplayValue() &#123; Console.WriteLine("Value=&#123;0&#125;", Value); &#125; &#125; &#125; /// &lt;summary&gt; /// 版本2 代码直接依赖于抽象接口IDataClass， /// 间接依赖于IntDataClass和DoubleDataClass，因为代码仍然负责实例化这两个类型的对象 /// &lt;/summary&gt; static void TestVersion2() &#123; Console.WriteLine("\nversion2:"); version2.IDataClass obj = new version2.IntDataClass(); obj.DisplayValue(); obj = new version2.DoubleDataClass(); obj.DisplayValue(); &#125; //增加接口进行抽象 namespace version2 &#123; interface IDataClass &#123; void DisplayValue(); &#125; class IntDataClass : IDataClass &#123; private int Value = 100; public void DisplayValue() &#123; Console.WriteLine("Value=&#123;0&#125;", Value); &#125; &#125; class DoubleDataClass : IDataClass &#123; private double Value = 100.001; public void DisplayValue() &#123; Console.WriteLine("Value=&#123;0&#125;", Value); &#125; &#125; &#125; /// &lt;summary&gt; /// 版本3：代码直接依赖于工厂类DataFactory， /// 与IntDataClass和DoubleDataClass彻底脱钩 /// &lt;/summary&gt; static void TestVersion3() &#123; Console.WriteLine("\nversion3:"); version3.IDataClass obj = version3.DataFactory.CreateDataClassObject("int"); obj.DisplayValue(); obj = version3.DataFactory.CreateDataClassObject("double"); obj.DisplayValue(); &#125; //构建一个工厂类 namespace version3 &#123; interface IDataClass &#123; void DisplayValue(); &#125; class IntDataClass : IDataClass &#123; private int Value = 100; public void DisplayValue() &#123; Console.WriteLine("Value=&#123;0&#125;", Value); &#125; &#125; class DoubleDataClass : IDataClass &#123; private double Value = 100.001; public void DisplayValue() &#123; Console.WriteLine("Value=&#123;0&#125;", Value); &#125; &#125; class DataFactory &#123; public static IDataClass CreateDataClassObject(String DataCategory) &#123; switch (DataCategory.ToLower()) &#123; case "int": return new version3.IntDataClass(); case "double": return new version3.DoubleDataClass(); default: break; &#125; return null; &#125; &#125; &#125; /// &lt;summary&gt; /// 抽象工厂设计模式，将工厂也进行抽象 /// 方法代码与所有具体类型完全脱钩 /// &lt;/summary&gt; static void TestVersion4(version4.IFactory factory) &#123; Console.WriteLine("\nversion4:"); version4.IDataClass obj = factory.CreateDataClassObject(); obj.DisplayValue(); &#125; //对工厂进行抽象,定义工厂接口 namespace version4 &#123; interface IDataClass &#123; void DisplayValue(); &#125; class IntDataClass : IDataClass &#123; private int Value = 100; public void DisplayValue() &#123; Console.WriteLine("Value=&#123;0&#125;", Value); &#125; &#125; class DoubleDataClass : IDataClass &#123; private double Value = 100.001; public void DisplayValue() &#123; Console.WriteLine("Value=&#123;0&#125;", Value); &#125; &#125; interface IFactory &#123; IDataClass CreateDataClassObject(); &#125; class IntDataFactory:IFactory &#123; public IDataClass CreateDataClassObject() &#123; return new version4.IntDataClass(); &#125; &#125; class DoubleDataFactory : IFactory &#123; public IDataClass CreateDataClassObject() &#123; return new version4.DoubleDataClass(); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930// 树节点工厂 负责生产节点 CreateNodeInfo 封装节点对象的信息namespace TreeNodeFactory&#123; public class TreeNodeFactory &#123; public TreeNode ProduceTreeNode(CreateNodeInfo info) &#123; TreeNode node = null; switch (info.NodeCategory) &#123; case "类型1": node = new MyTreeNode1(info.NodeText); break; case "类型2": node = new MyTreeNode2(info.NodeText); break; case "类型3": node = new MyTreeNode3(info.NodeText); break; case "类型4": node = new MyTreeNode4(info.NodeText); break; case "类型5": node = new MyTreeNode5(info.NodeText); break; &#125; return node; &#125; &#125;&#125; 123456789//节点显示文本 和节点类型namespace TreeNodeFactory&#123; public class CreateNodeInfo &#123; public String NodeCategory &#123; get; set; &#125; public String NodeText &#123; get; set; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//各种节点的构造namespace TreeNodeFactory&#123; public class MyTreeNode1:TreeNode &#123; public MyTreeNode1(String text) : base(text,0,0) &#123; &#125; &#125; public class MyTreeNode2 : TreeNode &#123; public MyTreeNode2(String text) : base(text,1,1) &#123; &#125; &#125; public class MyTreeNode3 : TreeNode &#123; public MyTreeNode3(String text) : base(text,2,2) &#123; &#125; &#125; public class MyTreeNode4 : TreeNode &#123; public MyTreeNode4(String text) : base(text,3,3) &#123; &#125; &#125; public class MyTreeNode5 : TreeNode &#123; public MyTreeNode5(String text) : base(text,4,4) &#123; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132//管理节点树namespace TreeNodeFactory&#123; public class TreeViewManager &#123; private ImageList imageList = null; private TreeView treeView = null; public TreeViewManager(TreeView tree,ImageList 几种常见设计模式概述) &#123; treeView = tree; imageList = 几种常见设计模式概述; &#125; public void AddNode(TreeNode node) &#123; if (treeView != null &amp;&amp; node != null) &#123; if (treeView.SelectedNode != null) &#123; treeView.SelectedNode.Nodes.Add(node); //展开节点 treeView.SelectedNode.Expand(); &#125; else &#123; treeView.Nodes.Add(node); treeView.ExpandAll(); &#125; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//窗体代码namespace TreeNodeFactory&#123; public partial class frmMain : Form &#123; private TreeViewManager treeManager = null; private TreeNodeFactory factory = null; public frmMain() &#123; InitializeComponent(); Init(); &#125; //初始化 创建节点管理对象 和节点工厂对象 private void Init() &#123; treeManager = new TreeViewManager(treeView1, imageList1); factory = new TreeNodeFactory(); &#125; private void btnCreateNode_Click(object sender, EventArgs e) &#123; CreateNode(); &#125; private void CreateNode() &#123; if (txtNode.Text.Trim() == "") &#123; MessageBox.Show("请输入节点文本"); txtNode.Focus(); return; &#125; if (cboNodeType.SelectedIndex == -1) &#123; MessageBox.Show("请选择节点类型"); cboNodeType.SelectedIndex = 0; return; &#125; CreateNodeInfo info = new CreateNodeInfo() &#123; NodeText = txtNode.Text, NodeCategory = cboNodeType.Items[cboNodeType.SelectedIndex].ToString() &#125;; TreeNode newNode = factory.ProduceTreeNode(info); treeManager.AddNode(newNode); &#125; &#125;&#125; Decorator模式(对象注入) 1234567891011121314151617181920public class InputTest &#123; public static void main(String[] args) throws IOException &#123; int c; try &#123; InputStream in = new LowerCaseInputStream( new BufferedInputStream( new FileInputStream("test.txt"))); while((c = in.read()) &gt;= 0) &#123; System.out.print((char)c); &#125; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415161718192021import java.io.*;public class LowerCaseInputStream extends FilterInputStream &#123; public LowerCaseInputStream(InputStream in) &#123; super(in); &#125; public int read() throws IOException &#123; int c = in.read(); return (c == -1 ? c : Character.toLowerCase((char)c)); &#125; public int read(byte[] b, int offset, int len) throws IOException &#123; int result = in.read(b, offset, len); for (int i = offset; i &lt; offset+result; i++) &#123; b[i] = (byte)Character.toLowerCase((char)b[i]); &#125; return result; &#125;&#125; Composite模式 12345678910111213141516171819202122232425262728293031namespace CompositePatternDemo&#123; /// &lt;summary&gt; /// 代表一种计算机配件 /// &lt;/summary&gt; public abstract class Component &#123; protected readonly string _name; protected readonly int _price; protected Component(string name, int price) &#123; _name = name; _price = price; &#125; public virtual void Add(Component component) &#123; throw new Exception("此配件不能包容其他配件"); &#125; public virtual string Name &#123; get &#123; return _name; &#125; &#125; public virtual int Price &#123; get &#123; return _price; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536namespace CompositePatternDemo&#123; /// &lt;summary&gt; /// 代表那些可以包容其他配件的计算机配件，比如机箱和主板 /// &lt;/summary&gt; public abstract class CompositeComponent : Component &#123; protected readonly List&lt;Component&gt; _components = new List&lt;Component&gt;(); protected CompositeComponent(string name, int price) : base(name, price) &#123; &#125; public override void Add(Component component) &#123; if (component is Computer) &#123; throw new Exception("计算机是最顶层的容器对象"); &#125; _components.Add(component); &#125; public override int Price &#123; get &#123; var total = _price; foreach (var component in _components) &#123; total += component.Price; &#125; return total; &#125; &#125; &#125;&#125; 12345678namespace CompositePatternDemo&#123; public class Ram : Component &#123; public Ram(int price) : base("Ram", price) &#123; &#125; &#125;&#125; 12345678namespace CompositePatternDemo&#123; public class Ssd : Component &#123; public Ssd(int price) : base("Ssd", price) &#123; &#125; &#125;&#125; 12345678namespace CompositePatternDemo&#123; public class Cpu : Component &#123; public Cpu(int price) : base("Cpu", price) &#123; &#125; &#125;&#125; 123456789101112//可以包含其他配件namespace CompositePatternDemo&#123; /// &lt;summary&gt; /// 主板 /// &lt;/summary&gt; public class Motherboard : CompositeComponent &#123; public Motherboard(int price) : base("Motherboard", price) &#123; &#125; &#125;&#125; 12345678namespace CompositePatternDemo&#123; public class Computer : CompositeComponent &#123; public Computer() : base("Computer", 0) &#123; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132namespace CompositePatternDemo&#123; class Program &#123; static void Main(string[] args) &#123; var computer = AssembleComputer(); Console.WriteLine("电脑总价：&#123;0&#125;",computer.Price); Console.ReadKey(); &#125; /// &lt;summary&gt; /// 装配一台电脑 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private static Computer AssembleComputer() &#123; var computer = new Computer(); // composite var motherboard = new Motherboard(125); // composite var cpu = new Cpu(250); // leaf var ram = new Ram(160); // leaf var drive = new Ssd(250); // leaf motherboard.Add(cpu); motherboard.Add(ram); computer.Add(motherboard); computer.Add(drive); return computer; &#125; &#125;&#125; Command模式 12345678910namespace MyLibrary&#123; /// &lt;summary&gt; /// 所有命令都必须实现此接口 /// &lt;/summary&gt; public interface ICommand &#123; void Execute(); &#125;&#125; 12345678910111213namespace MyLibrary&#123; /// &lt;summary&gt; /// 接收命令的窗体必须实现的接口 /// &lt;/summary&gt; public interface IForm &#123; void Max(); void Restore(); void ChangeColor(int Red,int Green,int Blue); &#125;&#125; 123456789101112131415161718192021222324252627namespace MyLibrary&#123; public class FormCommand : ICommand &#123; protected IForm InnerForm &#123;get;set;&#125; /// &lt;summary&gt; /// 命令名字 /// &lt;/summary&gt; public string Command &#123; get; set; &#125; /// &lt;summary&gt; /// 命令参数 /// &lt;/summary&gt; public string Parameter &#123; get; set; &#125; public String toJson() &#123; return JsonConvert.SerializeObject(this); &#125; public static FormCommand GetCommandFromJosn(String json) &#123; return JsonConvert.DeserializeObject&lt;FormCommand&gt;(json); &#125; public virtual void Execute() &#123; &#125; &#125;&#125; 123456789101112131415161718192021222324252627namespace MyLibrary&#123; public class MaxCommand : FormCommand &#123; public const string CommandType = "Max"; public MaxCommand():this(null) &#123; &#125; public MaxCommand(IForm form) : base() &#123; Command = CommandType; InnerForm = form; &#125; public override void Execute() &#123; if (InnerForm == null) &#123; return; &#125; InnerForm.Max(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627namespace MyLibrary&#123; public class RestoreCommand : FormCommand, ICommand &#123; public const string CommandType = "Restore"; public RestoreCommand() : this(null) &#123; &#125; public RestoreCommand(IForm form) : base() &#123; Command = CommandType; InnerForm = form; &#125; public override void Execute() &#123; if (InnerForm == null) &#123; return; &#125; InnerForm.Restore(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435namespace MyLibrary&#123; /// &lt;summary&gt; /// 更改颜色命令 /// &lt;/summary&gt; public class ChangeColorCommand : FormCommand &#123; public const string CommandType = "ChangeColor"; public ChangeColorCommand(IForm form) : base() &#123; Command = CommandType; InnerForm = form; &#125; public void setColor(int Red, int Green, int Blue) &#123; Parameter = String.Format("&#123;0&#125;,&#123;1&#125;,&#123;2&#125;", Red, Green, Blue); &#125; public override void Execute() &#123; if (InnerForm == null) &#123; return; &#125; string[] values = Parameter.Split(new String[] &#123; "," &#125;, StringSplitOptions.RemoveEmptyEntries); if (values.Length != 3) &#123; throw new ArgumentException("传入的参数格式为: Red,Green,Blue"); &#125; InnerForm.ChangeColor(int.Parse(values[0]), int.Parse(values[1]), int.Parse(values[2])); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435namespace FormClient&#123; /// &lt;summary&gt; /// 完成网络数据发送任务 /// &lt;/summary&gt; public class Sender &#123; private IPEndPoint ipep = null; public Sender(IPEndPoint server) &#123; ipep = server; &#125; public String Send(FormCommand command) &#123; //创建套接字，使用TCP协议 Socket server = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); try &#123; server.Connect(ipep); byte[] SentBytes = Encoding.UTF8.GetBytes(command.toJson()); SocketHelper.SendVarData(server, SentBytes); server.Shutdown(SocketShutdown.Both); server.Close(); &#125; catch (SocketException e) &#123; return String.Format("无法连接远程主机 &#123;0&#125; ,原因：&#123;1&#125;，NativeErrorCode：&#123;2&#125;,SocketErrorCode:&#123;3&#125;", ipep.Address, e.Message, e.NativeErrorCode, e.SocketErrorCode); &#125; return "数据发送完毕，断开与服务端的连接。"; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677namespace FormClient&#123; public partial class frmClient : Form &#123; public frmClient() &#123; InitializeComponent(); &#125; private void btnMax_Click(object sender, EventArgs e) &#123; SendCommand(new MaxCommand()); &#125; private void SendCommand(FormCommand command) &#123; Sender messageSender = GetSender(); Thread thread = new Thread(() =&gt; &#123; String sendresult = messageSender.Send(command); ShowInfo(sendresult); &#125;); thread.Start(); &#125; private Sender GetSender() &#123; IPAddress serverAddress=IPAddress.Parse(txtIP.Text); int port=int.Parse(txtPort.Text); Sender sender = new Sender(new System.Net.IPEndPoint(serverAddress, port)); return sender; &#125; private void ShowInfo(String message) &#123; Action showInfo = () =&gt; &#123; lblInfo.Text = message; &#125;; lblInfo.Invoke(showInfo); &#125; private void btnRestore_Click(object sender, EventArgs e) &#123; SendCommand(new RestoreCommand()); &#125; private void numericUpDown1_ValueChanged(object sender, EventArgs e) &#123; ShowColor(); &#125; private void ShowColor() &#123; Color color = Color.FromArgb((int)updnRed.Value, (int)updnGreen.Value, (int)updnBlue.Value); pnlColor.BackColor = color; &#125; private void updnGreen_ValueChanged(object sender, EventArgs e) &#123; ShowColor(); &#125; private void updnBlue_ValueChanged(object sender, EventArgs e) &#123; ShowColor(); &#125; private void btnChangeColor_Click(object sender, EventArgs e) &#123; ChangeColorCommand comm = new ChangeColorCommand(null); comm.setColor((int)updnRed.Value, (int)updnGreen.Value, (int)updnBlue.Value); SendCommand(comm); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130namespace FormServer&#123; public partial class frmServer : Form, IForm &#123; public frmServer() &#123; InitializeComponent(); &#125; public void Max() &#123; this.WindowState = FormWindowState.Maximized; &#125; public void Restore() &#123; this.WindowState = FormWindowState.Normal; &#125; public void ChangeColor(int Red, int Green, int Blue) &#123; Color color = Color.FromArgb(Red, Green, Blue); BackColor = color; &#125; private void btnBeginListen_Click(object sender, EventArgs e) &#123; BeginListening(); &#125; /// &lt;summary&gt; /// 数据接收缓冲区尺寸， /// &lt;/summary&gt; private const int BufferSize = 1024; private void BeginListening() &#123; byte[] data = new byte[BufferSize]; //获取本机地址 IPAddress localAddress = AddressHelper.GetLocalhostIPv4Addresses().First(); int LocalPort = AddressHelper.GetOneAvailablePortInLocalhost(); //创建IP终结点 IPEndPoint ipep = new IPEndPoint(localAddress, LocalPort); Thread thread = new Thread(() =&gt; &#123; while (true) &#123; //创建套接字，使用TCP协议 Socket newsock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); using (newsock) &#123; //绑定 newsock.Bind(ipep); //开始监听 newsock.Listen(1); ShowInfo(String.Format("主机 &#123;0&#125; 正在监听端口 &#123;1&#125; ，等待客户端连接……", localAddress, ipep.Port)); //如果有客户端连接…… Socket client = newsock.Accept(); IPEndPoint clientep = (IPEndPoint)client.RemoteEndPoint; AppendInfo(String.Format("已接收客户端连接，客户端IP地址：&#123;0&#125; 开放端口：&#123;1&#125;", clientep.Address, clientep.Port)); string StringSentByClient = ""; byte[] receivedData = SocketHelper.ReceiveVarData(client); StringSentByClient = Encoding.UTF8.GetString(receivedData); AppendInfo(StringSentByClient); FormCommand command = FormCommand.GetCommandFromJosn(StringSentByClient); ProcessReceivedCommand(command); &#125; &#125; &#125;); thread.IsBackground = true; thread.Start(); &#125; private void ProcessReceivedCommand(FormCommand command) &#123; if (command == null) &#123; return; &#125; Action action = () =&gt; &#123; switch (command.Command) &#123; case MaxCommand.CommandType: new MaxCommand(this).Execute(); break; case RestoreCommand.CommandType: new RestoreCommand(this).Execute(); break; case ChangeColorCommand.CommandType: ChangeColorCommand comm = new ChangeColorCommand(this); comm.Parameter = command.Parameter; comm.Execute(); break; default: break; &#125; &#125;; this.Invoke(action); &#125; private void ShowInfo(String message) &#123; Action showInfo = () =&gt; &#123; lblInfo.Text = message; &#125;; lblInfo.Invoke(showInfo); &#125; private void AppendInfo(String message) &#123; Action showInfo = () =&gt; &#123; rtfMessage.AppendText(message + "\n"); &#125;; rtfMessage.Invoke(showInfo); &#125; &#125;&#125; 设计模式应用指南]]></content>
      <categories>
        <category>Object Oriented</category>
        <category>面向对象软件设计</category>
      </categories>
      <tags>
        <tag>软件设计</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SOLID设计原则]]></title>
    <url>%2F2019%2F03%2F11%2FSOLID%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[SOLID设计原则是什么意思？ SOLID设计原则 SRP–单一职责原则 OCP开闭原则 LSP–liskov替换原则 ISP–接口隔离原则 DIP–依赖倒置原则]]></content>
      <categories>
        <category>Object Oriented</category>
        <category>面向对象软件设计</category>
      </categories>
      <tags>
        <tag>软件设计</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类设计指南]]></title>
    <url>%2F2019%2F03%2F10%2F%E7%B1%BB%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[如何设计一个类 合理封装 类的封装 “神奇”的java代码 封装是一种重构方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091namespace FileSaverDemo&#123; //原始版本 namespace Original &#123; public class MyEditor &#123; /// &lt;summary&gt; /// 把文档保存到本地磁盘 /// &lt;/summary&gt; /// &lt;param name="FileName"&gt;&lt;/param&gt; public void SaveToLocalDisk(String FileName) &#123; &#125; /// &lt;summary&gt; /// 把文档保存到网盘 /// &lt;/summary&gt; /// &lt;param name="NetworkDiskWebSiteUrl"&gt;&lt;/param&gt; /// &lt;param name="UserName"&gt;&lt;/param&gt; /// &lt;param name="Password"&gt;&lt;/param&gt; /// &lt;param name="FileName"&gt;&lt;/param&gt; public void SaveToNetworkDisk(String NetworkDiskWebSiteUrl, String UserName, String Password, String FileName) &#123; &#125; &#125; &#125; namespace EncapulatedAndAbstracted &#123; public interface IFileSaver &#123; void Save(String FileName); &#125; /// &lt;summary&gt; /// 本地文件存储 /// &lt;/summary&gt; public class LocalFileSaver : IFileSaver &#123; public void Save(string FileName) &#123; throw new NotImplementedException(); &#125; &#125; /// &lt;summary&gt; /// 网络文件存储 /// &lt;/summary&gt; public class NetworkFileSaver : IFileSaver &#123; private NetworkDiskInfo _NetworkDiskInfo = null; public NetworkFileSaver(NetworkDiskInfo info) &#123; _NetworkDiskInfo=info; &#125; public void Save(string FileName) &#123; &#125; &#125; /// &lt;summary&gt; /// 用于封装网盘存储相关的信息 /// &lt;/summary&gt; public class NetworkDiskInfo &#123; public String NetworkDiskWebSiteUrl &#123; get; set; &#125; public String UserName &#123; get; set; &#125; public String Password &#123; get; set; &#125; &#125; public class MyEditor &#123; private List&lt;IFileSaver&gt; _FileSavers = null; public MyEditor(List&lt;IFileSaver&gt; fileSavers) &#123; _FileSavers = fileSavers; &#125; public void Save(String FileName) &#123; foreach (var saver in _FileSavers) &#123; saver.Save(FileName); &#125; &#125; &#125; &#125;&#125; 1以下三个在data文件夹(包括接口 两个仓库) 123456789namespace EncapsulationAndIsolation.Data&#123; public interface IUserRepository &#123; IEnumerable&lt;User&gt; All(); User GetBy(int Id); void Delete(int Id); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435namespace EncapsulationAndIsolation.Data&#123; public class TestUserRepository : IUserRepository &#123; private readonly List&lt;User&gt; _store; public TestUserRepository() &#123; _store = new List&lt;User&gt;(new[] &#123; new User &#123; Id = 1, FirstName = "John", LastName = "Doe"&#125;, new User &#123; Id = 2, FirstName = "James", LastName = "Doe"&#125;, new User &#123; Id = 3, FirstName = "Jane", LastName = "Doe"&#125;, new User &#123; Id = 4, FirstName = "Jennifer", LastName = "Doe"&#125; &#125;); &#125; public IEnumerable&lt;User&gt; All() &#123; return _store.ToArray(); &#125; public User GetBy(int Id) &#123; return _store.SingleOrDefault(user =&gt; user.Id == Id); &#125; public void Delete(int Id) &#123; User user = _store.FirstOrDefault(u =&gt; u.Id == Id); if (user != null) &#123; _store.Remove(user); &#125; &#125; &#125;&#125; 123456789101112131415161718192021//数据访问层namespace EncapsulationAndIsolation.Data&#123; public class UserRepositoryFromDB : IUserRepository &#123; public IEnumerable&lt;User&gt; All() &#123; throw new NotImplementedException(); &#125; public User GetBy(int Id) &#123; throw new NotImplementedException(); &#125; public void Delete(int Id) &#123; throw new NotImplementedException(); &#125; &#125;&#125; 12345678910//实体类namespace EncapsulationAndIsolation.Model&#123; public class User &#123; public int Id &#123; get; set; &#125; public string FirstName &#123; get; set; &#125; public string LastName &#123; get; set; &#125; &#125;&#125; 1234567891011121314151617181920212223namespace EncapsulationAndIsolation&#123; class Program &#123; static void Main(string[] args) &#123; DisplayUsers(new TestUserRepository()); Console.ReadKey(); &#125; public static void DisplayUsers(IUserRepository repo) &#123; foreach (var user in repo.All()) &#123; var userData = string.Format("&#123;0&#125;\t&#123;1&#125; &#123;2&#125;", user.Id, user.FirstName, user.LastName); Console.WriteLine(userData); &#125; &#125; &#125;&#125; 基于职责设计类(功能、数据处理任务) 避免过大的类 通用职责分派软件模式 (GRASP原则) Expert/Information Expert原则 Creator原则 Controller原则 高内聚 低耦合（组合优于继承） 间接性原则 Pure Fabrication原则 隔离变化原则 Protected Variations 多态性原则 Polymorthism 命令方法和查询方法对象的状态（告诉而不是询问） 命令Vs查询 类方法设计原则]]></content>
      <categories>
        <category>Object Oriented</category>
        <category>面向对象软件设计</category>
      </categories>
      <tags>
        <tag>软件设计</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象软件设计基本原则]]></title>
    <url>%2F2019%2F03%2F09%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[了解基本软件开发设计原则 糟糕的软件设计什么是软件设计？ 僵化的设计 脆弱的设计 无法重用的设计 过于复杂的设计 DRY原则–老路不走两遍 YNGAI原则–绝不画蛇添足 KISS原则–简单即美 DDIY原则–不要一切自己动手]]></content>
      <categories>
        <category>Object Oriented</category>
        <category>面向对象软件设计</category>
      </categories>
      <tags>
        <tag>软件设计</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重构与代码质量]]></title>
    <url>%2F2019%2F03%2F08%2F%E9%87%8D%E6%9E%84%E4%B8%8E%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[代码质量与重构 代码常见毛病“菜鸟”典型代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114本示例存在的问题：1 全部采用Visual Studio起的默认名字2 直接在事件代码中书写功能代码3 随意Copy &amp; Paste，导致大量代码重复4 界面代码与功能代码混杂，全部位于窗体文件中5 没有进行数据有效性检测namespace SimpleCalculator&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void button1_Click(object sender, EventArgs e) &#123; double num1 = double.Parse(textBox1.Text); double num2 = double.Parse(textBox2.Text); double result = 0; switch (comboBox1.SelectedIndex) &#123; case 0: result = num1 + num2; break; case 1: result = num1 - num2; break; case 2: result = num1 * num2; break; case 3: result = (double)num1 / num2; break; &#125; label1.Text = result.ToString(); &#125; private void comboBox1_SelectedIndexChanged(object sender, EventArgs e) &#123; double num1 = double.Parse(textBox1.Text); double num2 = double.Parse(textBox2.Text); double result = 0; switch (comboBox1.SelectedIndex) &#123; case 0: result = num1 + num2; break; case 1: result = num1 - num2; break; case 2: result = num1 * num2; break; case 3: result = num1 / num2; break; &#125; label1.Text = result.ToString(); &#125; private void Form1_Load(object sender, EventArgs e) &#123; comboBox1.SelectedIndex = 0; &#125; private void textBox1_TextChanged(object sender, EventArgs e) &#123; double num1 = double.Parse(textBox1.Text); double num2 = double.Parse(textBox2.Text); double result = 0; switch (comboBox1.SelectedIndex) &#123; case 0: result = num1 + num2; break; case 1: result = num1 - num2; break; case 2: result = num1 * num2; break; case 3: result = num1 / num2; break; &#125; label1.Text = result.ToString(); &#125; private void textBox2_TextChanged(object sender, EventArgs e) &#123; double num1 = double.Parse(textBox1.Text); double num2 = double.Parse(textBox2.Text); double result = 0; switch (comboBox1.SelectedIndex) &#123; case 0: result = num1 + num2; break; case 1: result = num1 - num2; break; case 2: result = num1 * num2; break; case 3: result = num1 / num2; break; &#125; label1.Text = result.ToString(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106使用之重构方式：1 标识符望名知义，使用region分隔代码2 显式初始化（因为控件的属性很多，如果直接在属性窗口中进行设置，时间一长，就记不住改了哪些属性值）3 数据处理功能封装到MathFunc中4 事件响应代码抽取为函数5 加入异常处理功能6 状态条显示的通用文本定义为常量，因为在不少地方都需要重置此状态条。进一步：可以把MathFunc独立抽取到一个类库项目中，从而将界面与数据处理功能彻底分开。namespace SimpleCalulator2&#123; public partial class frmMain : Form &#123; private const String Information = "请在文本框中输入数进行计算"; public frmMain() &#123; InitializeComponent(); &#125; private void frmMain_Load(object sender, EventArgs e) &#123; Init(); &#125; #region "系统初始化" private void Init() &#123; InitUIControl(); setEventHandler(); &#125; /// &lt;summary&gt; /// 初始化可视化界面 /// &lt;/summary&gt; private void InitUIControl() &#123; var Operators = new List&lt;string&gt;() &#123; "+", "-", "*", "/" &#125;; cboOperator.DataSource = Operators; cboOperator.SelectedIndex = 0; txtNum1.Text = "0"; txtNum2.Text = "0"; lblResult.Text = "0"; statusLabelInfo.Text = Information; &#125; /// &lt;summary&gt; /// 设置各个控件的事件响应 /// &lt;/summary&gt; private void setEventHandler() &#123; EventHandler calculateEventHandler = (sender, e) =&gt; &#123; Calculate(); &#125;; txtNum1.TextChanged += calculateEventHandler; txtNum2.TextChanged += calculateEventHandler; cboOperator.SelectedIndexChanged += calculateEventHandler; btnCalculate.Click += calculateEventHandler; &#125; #endregion /// &lt;summary&gt; /// 完成计算功能 /// &lt;/summary&gt; private void Calculate() &#123; try &#123; double num1 = double.Parse(txtNum1.Text); double num2 = double.Parse(txtNum2.Text); double result = 0; switch (cboOperator.SelectedIndex) &#123; case 0: result = MathFunc.Add(num1, num2); break; case 1: result = MathFunc.Subtract(num1, num2); break; case 2: result = MathFunc.Multiply(num1, num2); break; case 3: result = MathFunc.Divide(num1, num2); break; default: throw new NotSupportedException("不支持的计算类型"); &#125; lblResult.Text = result.ToString(); statusLabelInfo.Text = Information; &#125; catch (Exception ex) &#123; statusLabelInfo.Text = ex.Message; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829namespace SimpleCalulator2&#123; /// &lt;summary&gt; /// 封装数学运算功能 /// &lt;/summary&gt; public class MathFunc &#123; public static double Add(double x, double y) &#123; return x + y; &#125; public static double Subtract(double x, double y) &#123; return x - y; &#125; public static double Multiply(double x, double y) &#123; return x * y; &#125; public static double Divide(double x, double y) &#123; if (y == 0) &#123; throw new InvalidOperationException("被除数不能为0"); &#125; return x / y; &#125; &#125;&#125; 重复代码 过长的函数 过大的类 过多的参数 原子弹的链式反应 曝光隐私 乱起名字 重构 什么是重构？ 何时重构？ 处理“神奇数字” 函数代替复杂逻辑表达式 外置重复语句 降低嵌套 逻辑紧密抽取为独立函数 引入局部变量改善可读性 防卫式编程 增加参数合并功能类似函数 依赖于参数值的函数分解 组合取代继承 小结]]></content>
      <categories>
        <category>Object Oriented</category>
        <category>面向对象软件设计</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Socket网络开发进阶]]></title>
    <url>%2F2019%2F03%2F07%2FSocket%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[Socket开发进阶基础 “数据缓冲区”陷阱背景 缓冲区设置的“陷阱” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162namespace TcpServerApp&#123; class Program &#123; /// &lt;summary&gt; /// 数据接收缓冲区尺寸， /// 过大，将一次读入多个消息 /// 过小，则导致一个消息分多次输出，有可能导致汉字解码失败 /// &lt;/summary&gt; //private const int BufferSize = 10; private const int BufferSize = 1024; static void Main(string[] args) &#123; byte[] data = new byte[BufferSize]; //获取本机地址 IPAddress localAddress = AddressHelper.GetLocalhostIPv4Addresses().First(); int LocalPort = AddressHelper.GetOneAvailablePortInLocalhost(); //创建IP终结点 IPEndPoint ipep = new IPEndPoint(localAddress, LocalPort); while (true) &#123; //创建套接字，使用TCP协议 Socket newsock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); using (newsock) &#123; //绑定 newsock.Bind(ipep); //开始监听 newsock.Listen(1); Console.WriteLine("主机 &#123;0&#125; 正在监听端口 &#123;1&#125; ，等待客户端连接……", localAddress, ipep.Port); //如果有客户端连接…… Socket client = newsock.Accept(); IPEndPoint clientep = (IPEndPoint)client.RemoteEndPoint; Console.WriteLine("已接收客户端连接，客户端IP地址：&#123;0&#125; 开放端口：&#123;1&#125;", clientep.Address, clientep.Port); int recv = 0; string StringSentByClient = ""; while (true) &#123; // Thread.Sleep(4000); //当服务端延迟较大并且设置了较大的缓冲区时，有可能一次会收到客户端发来的多条消息 recv = client.Receive(data); StringSentByClient = Encoding.UTF8.GetString(data, 0, recv); Console.WriteLine("客户端传来：&#123;0&#125;", StringSentByClient); if (StringSentByClient == "exit" ) &#123; Console.WriteLine("检测到exit命令，断开客户端 &#123;0&#125; 连接\n", clientep.Address); client.Close(); break; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455namespace TCPClientApp&#123; /// &lt;summary&gt; /// Note: /// 按以下方式测试 /// 1 去掉客户端的Thread.Sleep()语句 /// 2 修改服务端的数据缓冲区大小 /// 3 让客户端与服务端都随机休眠 /// 4 如果让客户端与服务端都采用不同的编码，将导致服务端无法正常解码 /// &lt;/summary&gt; class Program &#123; static void Main(string[] args) &#123; IPEndPoint ipep = null; //要求用户输入有效的远程主机IP地址和端口 while (true) &#123; ipep = AddressHelper.GetRemoteMachineIPEndPoint(); if (ipep != null) break; &#125; //创建套接字，使用TCP协议 Socket server = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); try &#123; server.Connect(ipep); &#125; catch (SocketException e) &#123; Console.WriteLine("无法连接远程主机 &#123;0&#125; ,原因：&#123;1&#125;，NativeErrorCode：&#123;2&#125;,SocketErrorCode:&#123;3&#125;", ipep.Address, e.Message, e.NativeErrorCode, e.SocketErrorCode); Console.WriteLine("敲任意键退出……"); Console.ReadKey(); return; &#125; //按行发送文本文件中的内容到服务端 foreach (String UserInput in File.ReadLines("TextFile1.txt")) &#123; byte[] SentBytes = Encoding.UTF8.GetBytes(UserInput); server.Send(SentBytes); Thread.Sleep(1000); //如果不让客户端暂停发送一段时间等待服务端，将导致服务端解码失败！ &#125; Console.WriteLine("数据发送完毕，断开与服务端的连接..."); server.Shutdown(SocketShutdown.Both); server.Close(); Console.WriteLine("敲任意键退出……"); Console.ReadKey(); &#125; &#125;&#125; 服务器端汉字无法解码 服务器端陷入“死循环” 可靠传输关键点（发射接收配对–缓冲区大小设置–处理速度配对） 黏包与丢包 Socket开发中的两种缓冲区 “TCP系统缓冲区” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253namespace ServerApp&#123; class Program &#123; static void Main(string[] args) &#123; Socket server = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); IPAddress localAddr = AddressHelper.GetLocalhostIPv4Addresses()[0]; int Port = AddressHelper.GetOneAvailablePortInLocalhost(); IPEndPoint iep = new IPEndPoint(localAddr, Port); server.Bind(iep); server.Listen(1); Console.WriteLine("在&#123;0&#125;：&#123;1&#125;上监听...", localAddr, Port); Socket client = server.Accept(); //如果接收方的数据缓冲区比发送方小，必须多次调用Receive方法 List&lt;ArraySegment&lt;byte&gt;&gt; buffers = CreateBuffers(); //如果接收方的数据缓冲区比发送方小，必须多次调用Receive方法 client.Receive(buffers); Console.WriteLine("收到客户端发来的信息："); PrintBuffers(buffers); Console.ReadKey(); &#125; // private static int ArraySegmentSize = 10; private static int ArraySegmentSize = 5; private static List&lt;ArraySegment&lt;byte&gt;&gt; CreateBuffers() &#123; //创建服务端数据接收缓存区 ArraySegment&lt;byte&gt; arrseg1 = new ArraySegment&lt;byte&gt;(new byte[ArraySegmentSize]); ArraySegment&lt;byte&gt; arrseg2 = new ArraySegment&lt;byte&gt;(new byte[ArraySegmentSize]); ArraySegment&lt;byte&gt; arrseg3 = new ArraySegment&lt;byte&gt;(new byte[ArraySegmentSize]); List&lt;ArraySegment&lt;byte&gt;&gt; buffers = new List&lt;ArraySegment&lt;byte&gt;&gt;(); buffers = new List&lt;ArraySegment&lt;byte&gt;&gt;(); buffers.Add(arrseg1); buffers.Add(arrseg2); buffers.Add(arrseg3); return buffers; &#125; private static void PrintBuffers(List&lt;ArraySegment&lt;byte&gt;&gt; buffers) &#123; foreach (var buffer in buffers) &#123; Console.WriteLine(BitConverter.ToString(buffer.Array)); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374namespace ClientApp&#123; class Program &#123; static void Main(string[] args) &#123; Socket client = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); IPEndPoint iep = AddressHelper.GetRemoteMachineIPEndPoint(); client.Connect(iep); //从数据缓存区中提取数据并发送给服务端应用程序 List&lt;ArraySegment&lt;byte&gt;&gt; buffers = CreateBuffers(); client.Send(buffers); Console.WriteLine("以下信息已被发送……"); PrintBuffers(buffers); Console.ReadKey(); &#125; //每个数据块中的数据大小 private static int DataBlockSize = 10; private static int ArraySegmentSize = 10; //private static int ArraySegmentSize = 5; private static List&lt;ArraySegment&lt;byte&gt;&gt; CreateBuffers() &#123; //客户端创建三个数据块，第一块放的是“1”，第二块放的是“2”，第三块放的是“3”， ArraySegment&lt;byte&gt; arrseg1 = new ArraySegment&lt;byte&gt;(new byte[ArraySegmentSize]); for (int i = 0; i &lt; DataBlockSize; i++) &#123; if (i &gt;= arrseg1.Count) &#123; break; &#125; arrseg1.Array[i] = 1; &#125; ArraySegment&lt;byte&gt; arrseg2 = new ArraySegment&lt;byte&gt;(new byte[ArraySegmentSize]); for (int i = 0; i &lt; DataBlockSize; i++) &#123; if (i &gt;= arrseg2.Count) &#123; break; &#125; arrseg2.Array[i] = 2; &#125; ArraySegment&lt;byte&gt; arrseg3 = new ArraySegment&lt;byte&gt;(new byte[ArraySegmentSize]); for (int i = 0; i &lt; DataBlockSize; i++) &#123; if (i &gt;= arrseg3.Count) &#123; break; &#125; arrseg3.Array[i] = 3; &#125; //数据发送缓冲区包容上述三个数据块 List&lt;ArraySegment&lt;byte&gt;&gt; buffers = new List&lt;ArraySegment&lt;byte&gt;&gt;(); buffers = new List&lt;ArraySegment&lt;byte&gt;&gt;(); buffers.Add(arrseg1); buffers.Add(arrseg2); buffers.Add(arrseg3); return buffers; &#125; private static void PrintBuffers(List&lt;ArraySegment&lt;byte&gt;&gt; buffers) &#123; foreach (var buffer in buffers) &#123; Console.WriteLine(BitConverter.ToString(buffer.Array)); &#125; &#125; &#125;&#125; 彻底解决缓冲区问题 发送接收定长的消息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879namespace TCPServerApp&#123; class Program &#123; /// &lt;summary&gt; /// 数据接收缓冲区尺寸， /// &lt;/summary&gt; private const int BufferSize = 1024; /// &lt;summary&gt; /// 消息的长度尺寸 /// &lt;/summary&gt; private const int MessageSize = 4; static void Main(string[] args) &#123; byte[] data = new byte[BufferSize]; //获取本机地址 IPAddress localAddress = AddressHelper.GetLocalhostIPv4Addresses().First(); int LocalPort = AddressHelper.GetOneAvailablePortInLocalhost(); //创建IP终结点 IPEndPoint ipep = new IPEndPoint(localAddress, LocalPort); while (true) &#123; //创建套接字，使用TCP协议 Socket newsock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); using (newsock) &#123; //绑定 newsock.Bind(ipep); //开始监听 newsock.Listen(1); Console.WriteLine("主机 &#123;0&#125; 正在监听端口 &#123;1&#125; ，等待客户端连接……", localAddress, ipep.Port); //如果有客户端连接…… Socket client = newsock.Accept(); IPEndPoint clientep = (IPEndPoint)client.RemoteEndPoint; Console.WriteLine("已接收客户端连接，客户端IP地址：&#123;0&#125; 开放端口：&#123;1&#125;", clientep.Address, clientep.Port); int recv = 0; //用于暂存数据的内存流 MemoryStream mem = new MemoryStream(); while (true) &#123; //将接收到的全部数据保存到数据缓存区中 返回字节大小 recv = client.Receive(data); //将缓存区的数据移到“流”中 //之所以这样做，是因为我们想直接使用BinaryReader内置的读取int数据的方法 //不想自己直接处理放在字节数组中的原始数据。 mem.Write(data, 0, recv); if (recv == 0) &#123; Console.WriteLine("数据接收完毕，断开客户端 &#123;0&#125; 连接\n", clientep.Address); client.Close(); break; &#125; &#125; //将当前流中的位置设置为指定值 0是偏移 mem.Seek(0, SeekOrigin.Begin); long datalength = mem.Length; BinaryReader reader = new BinaryReader(mem); Console.WriteLine("接收到数据为："); while (reader.BaseStream.Position &lt; datalength) &#123; //(已经知道对方发过来的数据是int类型，所以这边就按照4个字节一组 //切分数据，并转换为int数值 Console.Write("&#123;0&#125;,", reader.ReadInt32()); &#125; reader.Close(); Console.WriteLine(); &#125; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657namespace TCPClientApp&#123; class Program &#123; private static int DataSize = 10; static int[] GenerateDataToBeSent() &#123; int[] data = new int[DataSize]; for (int i = 0; i &lt; DataSize; i++) data[i] = 100 + i; return data; &#125; static void Main(string[] args) &#123; IPEndPoint ipep = null; //要求用户输入有效的远程主机IP地址和端口 while (true) &#123; ipep = AddressHelper.GetRemoteMachineIPEndPoint(); if (ipep != null) break; &#125; //创建套接字，使用TCP协议 Socket server = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); try &#123; server.Connect(ipep); &#125; catch (SocketException e) &#123; Console.WriteLine("无法连接远程主机 &#123;0&#125; ,原因：&#123;1&#125;，NativeErrorCode：&#123;2&#125;,SocketErrorCode:&#123;3&#125;", ipep.Address, e.Message, e.NativeErrorCode, e.SocketErrorCode); return; &#125; StringBuilder sendData = new StringBuilder(); foreach (int value in GenerateDataToBeSent()) &#123; //整型数据变为字节数组 byte[] SentBytes = BitConverter.GetBytes(value); server.Send(SentBytes); sendData.Append(value); sendData.Append(","); &#125; Console.WriteLine("发送数据“&#123;0&#125;”给服务端",sendData.ToString()); Console.WriteLine("数据发送完毕，断开与服务端的连接..."); server.Shutdown(SocketShutdown.Both); server.Close(); Console.WriteLine("敲任意键退出……"); Console.ReadKey(); &#125; &#125;&#125; 采用一问一答方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101namespace TcpServerApp&#123; class Program &#123; /// &lt;summary&gt; /// 数据接收缓冲区尺寸， /// &lt;/summary&gt; private const int BufferSize = 1024; private const string SendFinshedString = "SendFinished"; private const string ReceiveFinishedString = "ReceiveFinished"; /// &lt;summary&gt; /// 接收客户端传送的数据，直到收到SendFinished才返回 /// &lt;/summary&gt; /// &lt;param name="s"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static string ReceiveData(Socket s) &#123; string StringSentByClient = ""; MemoryStream mem = new MemoryStream(); //消息结束字串的长度 int count = Encoding.UTF8.GetByteCount(SendFinshedString); //缓冲1024字节 byte[] buffer = new byte[BufferSize]; while (true) &#123; int recv = s.Receive(buffer); mem.Write(buffer, 0, recv); //检测一下是否收到了足够的数据 if (mem.Length &gt; count) &#123; //比对一下最后收到的数据是不是“SendFinished”字符串 byte[] temp = mem.ToArray(); String theLastData = Encoding.UTF8.GetString(temp, temp.Length - count, count); if (theLastData == SendFinshedString) &#123; StringSentByClient = Encoding.UTF8.GetString(temp, 0, temp.Length - count); break; &#125; &#125; &#125; return StringSentByClient; &#125; private static Random ran = new Random(); static void Main(string[] args) &#123; byte[] data = new byte[BufferSize]; //获取本机地址 IPAddress localAddress = AddressHelper.GetLocalhostIPv4Addresses().First(); int LocalPort = AddressHelper.GetOneAvailablePortInLocalhost(); //创建IP终结点 IPEndPoint ipep = new IPEndPoint(localAddress, LocalPort); while (true) &#123; //创建套接字，使用TCP协议 Socket newsock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); using (newsock) &#123; //绑定 newsock.Bind(ipep); //开始监听 newsock.Listen(1); Console.WriteLine("主机 &#123;0&#125; 正在监听端口 &#123;1&#125; ，等待客户端连接……", localAddress, ipep.Port); //如果有客户端连接…… Socket client = newsock.Accept(); IPEndPoint clientep = (IPEndPoint)client.RemoteEndPoint; Console.WriteLine("已接收客户端连接，客户端IP地址：&#123;0&#125; 开放端口：&#123;1&#125;", clientep.Address, clientep.Port); String StringSentByClient = ""; while (true) &#123; StringSentByClient = ReceiveData(client); Console.WriteLine("客户端传来：&#123;0&#125;", StringSentByClient); //发送接收完毕的命令 client.Send(Encoding.UTF8.GetBytes(ReceiveFinishedString)); //如果客户端发来 if (StringSentByClient == "exit") &#123; Console.WriteLine("检测到exit命令，断开客户端 &#123;0&#125; 连接\n", clientep.Address); client.Close(); break; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293namespace TcpClientApp&#123; class Program &#123; private const string SendFinshedString = "SendFinished"; private const string ReceiveFinishedString = "ReceiveFinished"; /// &lt;summary&gt; /// 等待接收到ReceiveFinished消息 /// &lt;/summary&gt; /// &lt;param name="s"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; static bool WaitForReceiveFinishedMessage(Socket s) &#123; int count = Encoding.UTF8.GetByteCount(ReceiveFinishedString); int total = 0; int recv; //数据长度 int dataleft = count; byte[] data = new byte[count]; while (total &lt; count) &#123; // An array of type System.Byte that is the storage location for received data. //The location in buffer to store the received data. // The number of bytes to receive. // A bitwise combination of the System.Net.Sockets.SocketFlags values. recv = s.Receive(data, total, dataleft, 0); if (recv == 0) &#123; break; &#125; total += recv; dataleft -= recv; &#125; return Encoding.UTF8.GetString(data) == ReceiveFinishedString; &#125; private static Random ran = new Random(); static void Main(string[] args) &#123; IPEndPoint ipep = null; //要求用户输入有效的远程主机IP地址和端口 while (true) &#123; ipep = AddressHelper.GetRemoteMachineIPEndPoint(); if (ipep != null) break; &#125; //创建套接字，使用TCP协议 Socket server = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); try &#123; server.Connect(ipep); &#125; catch (SocketException e) &#123; Console.WriteLine("无法连接远程主机 &#123;0&#125; ,原因：&#123;1&#125;，NativeErrorCode：&#123;2&#125;,SocketErrorCode:&#123;3&#125;", ipep.Address, e.Message, e.NativeErrorCode, e.SocketErrorCode); return; &#125; foreach (String UserInput in File.ReadLines("TextFile1.txt")) &#123; byte[] SentBytes = Encoding.UTF8.GetBytes(UserInput); //发送读取的文件每行内容 server.Send(SentBytes); //Thread.Sleep(ran.Next(100, 5000)); //用于拖慢程序的运行速度 SentBytes = Encoding.UTF8.GetBytes(SendFinshedString); //同时发送：发送结束字符串 服务器端会接收到一整串字符 然后解析 server.Send(SentBytes); //等待服务端发来"ReceiveFinish"命令 while (!WaitForReceiveFinishedMessage(server)) &#123; &#125; &#125; Console.WriteLine("数据发送完毕，断开与服务端的连接..."); server.Shutdown(SocketShutdown.Both); server.Close(); Console.WriteLine("敲任意键退出……"); Console.ReadKey(); &#125; &#125;&#125; 1234围炉夜话天地无穷期，生命则有穷期，去一日，便少一日;富贵有定数，学问则无定数，求一分，便得一分。exit 在消息开头附上消息的尺寸信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667namespace MyNetworkLibrary&#123; public static class SocketHelper &#123; /// &lt;summary&gt; /// 接收变长的数据，要求其打头的4个字节代表有效数据的长度 /// &lt;/summary&gt; /// &lt;param name="s"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static byte[] ReceiveVarData(Socket s) &#123; if (s == null) throw new ArgumentNullException("s"); int total = 0; //已接收的字节数 int recv; //接收4个字节，得到“消息长度” byte[] datasize = new byte[4]; //接收的长度 buffer 偏移 大小 标志 recv = s.Receive(datasize, 0, 4, 0); // 发送的长度 数组 开始索引 int size = BitConverter.ToInt32(datasize, 0); //按消息长度接收数据 int dataleft = size; byte[] data = new byte[size]; while (total &lt; size) &#123; // 接收的长度 buffer 偏移 大小 标志 recv = s.Receive(data, total, dataleft, 0); if (recv == 0) &#123; break; &#125; total += recv; dataleft -= recv; &#125; return data; &#125; /// &lt;summary&gt; /// 发送变长的数据，将数据长度附加于数据开头 /// &lt;/summary&gt; /// &lt;param name="s"&gt;&lt;/param&gt; /// &lt;param name="data"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static int SendVarData(Socket s, byte[] data) &#123; int total = 0; int size = data.Length; //要发送的消息长度 int dataleft = size; //剩余的消息 int sent; //将消息长度（int类型）的，转为字节数组 byte[] datasize = BitConverter.GetBytes(size); //将消息长度发送出去 sent = s.Send(datasize); //发送消息剩余的部分 while (total &lt; size) &#123; // 发送的长度 buffer 偏移 长度 标志 sent = s.Send(data, total, dataleft, SocketFlags.None); total += sent; dataleft -= sent; &#125; return total; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859namespace TCPServerApp&#123; class Program &#123; /// &lt;summary&gt; /// 数据接收缓冲区尺寸， /// &lt;/summary&gt; private const int BufferSize = 1024; static void Main(string[] args) &#123; byte[] data = new byte[BufferSize]; //获取本机地址 IPAddress localAddress = AddressHelper.GetLocalhostIPv4Addresses().First(); int LocalPort = AddressHelper.GetOneAvailablePortInLocalhost(); //创建IP终结点 IPEndPoint ipep = new IPEndPoint(localAddress, LocalPort); while (true) &#123; //创建套接字，使用TCP协议 Socket newsock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); using (newsock) &#123; //绑定 newsock.Bind(ipep); //开始监听 newsock.Listen(1); Console.WriteLine("主机 &#123;0&#125; 正在监听端口 &#123;1&#125; ，等待客户端连接……", localAddress, ipep.Port); //如果有客户端连接…… Socket client = newsock.Accept(); IPEndPoint clientep = (IPEndPoint)client.RemoteEndPoint; Console.WriteLine("已接收客户端连接，客户端IP地址：&#123;0&#125; 开放端口：&#123;1&#125;", clientep.Address, clientep.Port); string StringSentByClient = ""; while (true) &#123; byte[] receivedData = SocketHelper.ReceiveVarData(client); StringSentByClient = Encoding.UTF8.GetString(receivedData); Console.WriteLine("客户端传来：&#123;0&#125;", StringSentByClient); if (StringSentByClient == "exit") &#123; Console.WriteLine("检测到exit命令，断开客户端 &#123;0&#125; 连接\n", clientep.Address); client.Close(); break; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445namespace TcpClientApp&#123; class Program &#123; static void Main(string[] args) &#123; IPEndPoint ipep = null; //要求用户输入有效的远程主机IP地址和端口 while (true) &#123; ipep = AddressHelper.GetRemoteMachineIPEndPoint(); if (ipep != null) break; &#125; //创建套接字，使用TCP协议 Socket server = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); try &#123; server.Connect(ipep); &#125; catch (SocketException e) &#123; Console.WriteLine("无法连接远程主机 &#123;0&#125; ,原因：&#123;1&#125;，NativeErrorCode：&#123;2&#125;,SocketErrorCode:&#123;3&#125;", ipep.Address, e.Message, e.NativeErrorCode, e.SocketErrorCode); return; &#125; foreach (String UserInput in File.ReadLines("TextFile1.txt")) &#123; byte[] SentBytes = Encoding.UTF8.GetBytes(UserInput); SocketHelper.SendVarData(server, SentBytes); &#125; Console.WriteLine("数据发送完毕，断开与服务端的连接..."); server.Shutdown(SocketShutdown.Both); server.Close(); Console.WriteLine("敲任意键退出……"); Console.ReadKey(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980namespace NetCalculatorServer&#123; class Program &#123; /// &lt;summary&gt; /// 数据接收缓冲区尺寸， /// &lt;/summary&gt; private const int BufferSize = 1024; static void Main(string[] args) &#123; byte[] data = new byte[BufferSize]; //获取本机地址 IPAddress localAddress = AddressHelper.GetLocalhostIPv4Addresses().First(); int LocalPort = AddressHelper.GetOneAvailablePortInLocalhost(); //创建IP终结点 IPEndPoint ipep = new IPEndPoint(localAddress, LocalPort); while (true) &#123; //创建套接字，使用TCP协议 Socket newsock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); using (newsock) &#123; //绑定 newsock.Bind(ipep); //开始监听 newsock.Listen(1); Console.WriteLine("主机 &#123;0&#125; 正在监听端口 &#123;1&#125; ，等待客户端连接……", localAddress, ipep.Port); //如果有客户端连接…… Socket client = newsock.Accept(); IPEndPoint clientep = (IPEndPoint)client.RemoteEndPoint; Console.WriteLine("已接收客户端连接，客户端IP地址：&#123;0&#125; 开放端口：&#123;1&#125;", clientep.Address, clientep.Port); string StringSentFromClient = ""; InfixAlgorithm calculator = new InfixAlgorithm(); while (true) &#123; byte[] receivedData = SocketHelper.ReceiveVarData(client); StringSentFromClient = Encoding.UTF8.GetString(receivedData); Console.WriteLine("客户端传来：&#123;0&#125;", StringSentFromClient); if (StringSentFromClient == "exit") &#123; Console.WriteLine("检测到exit命令，断开客户端 &#123;0&#125; 连接\n", clientep.Address); client.Close(); break; &#125; double result = 0; String ResultSentToClient = ""; try &#123; //检测表达式有效性 PreProcess.CheckExprValidate(PreProcess.ClearAllSpace(StringSentFromClient)); //计算 result = calculator.Calculate(StringSentFromClient); //生成计算结果 ResultSentToClient = string.Format("&#123;0&#125;=&#123;1&#125;", StringSentFromClient, result); Console.WriteLine("将计算结果&#123;0&#125;发回给客户端&#123;1&#125;:&#123;2&#125;", ResultSentToClient, clientep.Address, clientep.Port); &#125; catch (CalculatorException ex) &#123; ResultSentToClient = string.Format("计算表达式&#123;0&#125;出错：&#123;1&#125;", ResultSentToClient, ex.Message); &#125; finally &#123; SocketHelper.SendVarData(client, Encoding.UTF8.GetBytes(ResultSentToClient)); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657namespace NetCalculatorClient&#123; class Program &#123; static void Main(string[] args) &#123; IPEndPoint ipep = null; //要求用户输入有效的远程主机IP地址和端口 while (true) &#123; ipep = AddressHelper.GetRemoteMachineIPEndPoint(); if (ipep != null) break; &#125; //创建套接字，使用TCP协议 Socket server = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); try &#123; server.Connect(ipep); &#125; catch (SocketException e) &#123; Console.WriteLine("无法连接远程主机 &#123;0&#125; ,原因：&#123;1&#125;，NativeErrorCode：&#123;2&#125;,SocketErrorCode:&#123;3&#125;", ipep.Address, e.Message, e.NativeErrorCode, e.SocketErrorCode); return; &#125; while (true) &#123; Console.Write("输入四则运算表达式或输入exit退出："); String Expression = Console.ReadLine(); if (Expression.Length == 0) continue; //将表达式发送到服务端 byte[] SentBytes = Encoding.UTF8.GetBytes(Expression); SocketHelper.SendVarData(server, SentBytes); if (Expression == "exit") &#123; break; &#125; //接收结果 byte[] ReceivedBytes = SocketHelper.ReceiveVarData(server); String result = Encoding.UTF8.GetString(ReceivedBytes); Console.WriteLine(result); &#125; Console.WriteLine("数据发送完毕，断开与服务端的连接..."); server.Shutdown(SocketShutdown.Both); server.Close(); Console.WriteLine("敲任意键退出……"); Console.ReadKey(); &#125; &#125;&#125; Socket应用实例选讲 跨网络传递自定义对象 123456789namespace ImageTransfer&#123; [Serializable] public class PicInfo &#123; public Image Picture &#123; get; set; &#125; public String Information &#123; get; set; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152namespace ImageTransfer&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); Init(); &#125; private PicInfo curPicInfo = null; private Socket mySocket = null; private IPEndPoint localEP = null; private void Init() &#123; try &#123; IPAddress addr = AddressHelper.GetLocalhostIPv4Addresses()[0]; int port = AddressHelper.GetOneAvailablePortInLocalhost(); localEP = new IPEndPoint(addr, port); mySocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); mySocket.Bind(localEP); mySocket.Listen(1); //新创建的线程 接收客户端的访问 Thread th = new Thread(OnReceive); th.IsBackground = true; th.Start(); tlblStatus.Text = string.Format("正在&#123;0&#125;:&#123;1&#125;上监听", addr, port); txtIP.Text = addr.ToString(); &#125; catch (Exception ex) &#123; tlblStatus.Text = ex.Message; &#125; &#125; private void OnReceive() &#123; while (true) &#123; //此线程会在这里停止 连接后会获取到连接的对象 Socket client= mySocket.Accept(); //获取连接的对象后 读取发送的数据 byte[] imgData=SocketHelper.ReceiveVarData(client); PicInfo img = DeserializePicInfo(imgData); //利用委托 将图片显示操作 推送到UI线程 Action del = () =&gt; &#123; ShowPicInfoInForm(img); &#125;; this.Invoke(del); &#125; &#125; /// &lt;summary&gt; /// 显示图片和说明文字 /// &lt;/summary&gt; /// &lt;param name="img"&gt;&lt;/param&gt; private void ShowPicInfoInForm(PicInfo img) &#123; if (img == null) return; pictureBox1.Image = img.Picture; txtPicDescription.Text = img.Information; &#125; /// &lt;summary&gt; /// 将PicInfo对象序列化为字符数组,无法序列化时，返回null /// &lt;/summary&gt; /// &lt;param name="img"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private byte[] SerializePicInfo(PicInfo img) &#123; if (img == null) return null; MemoryStream mem = new MemoryStream(); BinaryFormatter formatter = new BinaryFormatter(); formatter.Serialize(mem, img); return mem.ToArray(); &#125; /// &lt;summary&gt; /// 反序列化PicInfo对象 /// &lt;/summary&gt; /// &lt;param name="buffer"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private PicInfo DeserializePicInfo(byte[] buffer) &#123; if (buffer.Length == 0) return null; MemoryStream mem = new MemoryStream(buffer); BinaryFormatter formatter = new BinaryFormatter(); return formatter.Deserialize(mem) as PicInfo; &#125; private void btnChoosePic_Click(object sender, EventArgs e) &#123; if (openFileDialog1.ShowDialog() == DialogResult.OK) &#123; curPicInfo = new PicInfo() &#123; Information = openFileDialog1.FileName, Picture = new Bitmap(openFileDialog1.FileName) &#125;; ShowPicInfoInForm(curPicInfo); &#125; &#125; private void btnSend_Click(object sender, EventArgs e) &#123; //以文本框中的值创建一个终结点对象 IPEndPoint remoteEP = GetRemoteEP(); if (remoteEP == null) return; try &#123; Socket newSock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); //与终结点对象连接（对方计算机） newSock.Connect(remoteEP); byte[] data = SerializePicInfo(curPicInfo); if (data == null) return; SocketHelper.SendVarData(newSock, data); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); &#125; &#125; /// &lt;summary&gt; /// 获取远程主机终结点,无法获取时返回null /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private IPEndPoint GetRemoteEP() &#123; try &#123; IPAddress addr = IPAddress.Parse(txtIP.Text.Trim()); int port = int.Parse(txtPort.Text.Trim()); return new IPEndPoint(addr, port); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); return null; &#125; &#125; &#125;&#125; 文件传送器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237namespace FileReceiverApp&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); Init(); &#125; /// &lt;summary&gt; /// 打开的本地端口 /// &lt;/summary&gt; private int LocalPort = AddressHelper.GetOneAvailablePortInLocalhost(); /// &lt;summary&gt; /// 数据接收缓冲区尺寸， /// &lt;/summary&gt; private const int BufferSize = 1024; private IPAddress localAddress = AddressHelper.GetLocalhostIPv4Addresses().First(); private IPEndPoint LocalEndpoint; private Socket LocalSocket; private Thread ListenerThread; //跨线程调用的委托 Action&lt;string&gt; ShowInfoInForm = null; /// &lt;summary&gt; /// 初始化系统 /// &lt;/summary&gt; private void Init() &#123; ShowInfoInForm = delegate(string info) &#123; rtfInfo.AppendText("\n" + info); &#125;; CreateLocalSocket(); &#125; /// &lt;summary&gt; /// 创建本地套接字 /// &lt;/summary&gt; private void CreateLocalSocket() &#123; try &#123; //创建IP终结点 LocalEndpoint = new IPEndPoint(localAddress, LocalPort); //创建套接字，使用TCP协议 LocalSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); //绑定 LocalSocket.Bind(LocalEndpoint); String info = string.Format("本地套接字创建完毕，绑定IP：&#123;0&#125;，将使用端口：&#123;1&#125;，请点击“开始监听”，做好接收文件的准备……",localAddress, LocalPort); rtfInfo.AppendText(info); &#125; catch (Exception ex) &#123; rtfInfo.AppendText(ex.Message); &#125; &#125; private void ListenerThreadMethod() &#123; //开始监听 LocalSocket.Listen(10); String info = string.Format("\n正在监听端口 &#123;0&#125; ，等待客户端连接……", LocalEndpoint.Port); this.BeginInvoke(ShowInfoInForm, info); while (true) &#123; Socket ClientSocket = null; try &#123; //接收客户连接 ClientSocket = LocalSocket.Accept(); IPEndPoint clientep = (IPEndPoint)ClientSocket.RemoteEndPoint; info = String.Format("已接收客户端连接，客户端IP地址：&#123;0&#125; 开放端口：&#123;1&#125;", clientep.Address, clientep.Port); this.BeginInvoke(ShowInfoInForm, info); //启动处理线程 Thread th = new Thread(HandlerThread); th.IsBackground = true; th.Start(ClientSocket); &#125; catch (ThreadAbortException ex) &#123; this.BeginInvoke(ShowInfoInForm, ex.Message); &#125; catch (Exception ex) &#123; this.BeginInvoke(ShowInfoInForm, ex.Message); &#125; &#125; &#125; private void HandlerThread(object handlerSocket) &#123; Socket ClientSocket = null; try &#123; ClientSocket = (Socket)handlerSocket; //接收文件名： byte[] receivedData = SocketHelper.ReceiveVarData(ClientSocket); String FileName = Encoding.UTF8.GetString(receivedData); this.Invoke(ShowInfoInForm, String.Format("客户端传来文件：&#123;0&#125;", FileName)); SocketHelper.SendVarData(ClientSocket, Encoding.UTF8.GetBytes("准备好接收文件")); receivedData = SocketHelper.ReceiveVarData(ClientSocket); int FileLength = BitConverter.ToInt32(receivedData, 0); SocketHelper.SendVarData(ClientSocket, Encoding.UTF8.GetBytes("文件长度" + FileLength)); //保存文件 int recv = 0; int blockSize = 8192; byte[] data = new byte[blockSize]; int AlreadyRead = 0; using (FileStream fs = new FileStream(Path.Combine(txtSaveDir.Text, FileName as string), FileMode.Create)) &#123; //一边接收一边写 while (true) &#123; recv = ClientSocket.Receive(data); fs.Write(data, 0, recv); AlreadyRead += recv; if (AlreadyRead == FileLength) break; &#125; &#125; this.Invoke(ShowInfoInForm, "接收到的数据写入到了文件:" + FileName); //向客户端发送回执 SocketHelper.SendVarData(ClientSocket, Encoding.UTF8.GetBytes("文件接收完毕")); &#125; catch (ThreadAbortException ex) &#123; this.BeginInvoke(ShowInfoInForm, ex.Message); &#125; catch (Exception ex) &#123; this.BeginInvoke(ShowInfoInForm, ex.Message); &#125; finally &#123; ClientSocket.Close(); //关闭Socket &#125; &#125; private void btnStart_Click(object sender, EventArgs e) &#123; if(Directory.Exists(txtSaveDir.Text.Trim())==false) &#123; ShowInfoInForm("必须指定一个有效的文件保存路径"); txtSaveDir.Focus(); return; &#125; if (LocalSocket == null) CreateLocalSocket(); btnStart.Enabled = false; btnStopFileReceive.Enabled = true; //启动监听线程 ListenerThread = new Thread(ListenerThreadMethod); ListenerThread.IsBackground = true; ListenerThread.Start(); &#125; private void frmMain_FormClosing(object sender, FormClosingEventArgs e) &#123; if (LocalSocket != null) &#123; if (LocalSocket.Connected) &#123; LocalSocket.Shutdown(SocketShutdown.Both); &#125; LocalSocket.Close(); &#125; &#125; private void btnStopFileReceive_Click(object sender, EventArgs e) &#123; if (LocalSocket.Connected) &#123; LocalSocket.Shutdown(SocketShutdown.Both); LocalSocket.Disconnect(false); &#125; LocalSocket.Close(); LocalSocket = null; ListenerThread.Abort(); btnStopFileReceive.Enabled = false; btnStart.Enabled = true; &#125; private void btnChooseSaveDir_Click(object sender, EventArgs e) &#123; if (folderBrowserDialog1.ShowDialog() == DialogResult.OK) txtSaveDir.Text = folderBrowserDialog1.SelectedPath; &#125; private void btnFolder_Click(object sender, EventArgs e) &#123; if (Directory.Exists(txtSaveDir.Text.Trim())) Process.Start(txtSaveDir.Text.Trim()); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188namespace FileSenderApp&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); //将信息显示在RichTextBox中 ShowInfoInForm = delegate(string info) &#123; rtfInfo.AppendText("\n" + info); &#125;; //更新进度条，显示上传文件的信息 ShowUploadProcess = delegate(int value) &#123; prgUpload.Value = value; &#125;; //激活或屏蔽控件 EnableOrDisableControl = delegate(Control ctl, bool value) &#123; ctl.Enabled = value; &#125;; //显示或隐蔽控件 ShowOrHideControl = delegate(Control ctl, bool value) &#123; ctl.Visible = value; &#125;; &#125; private string UploadFileName = ""; //跨线程调用的委托 Action&lt;string&gt; ShowInfoInForm = null; Action&lt;int&gt; ShowUploadProcess = null; Action&lt;Control, bool&gt; EnableOrDisableControl = null; Action&lt;Control, bool&gt; ShowOrHideControl = null; private void btnChooseFile_Click(object sender, EventArgs e) &#123; if (openFileDialog1.ShowDialog() == DialogResult.OK) &#123; UploadFileName = openFileDialog1.FileName; rtfInfo.AppendText("\n准备上传文件：" + UploadFileName); &#125; &#125; private void btnUpload_Click(object sender, EventArgs e) &#123; if (UploadFileName == "") &#123; MessageBox.Show("请选择要上传的文件"); return; &#125; try &#123; remoteAddress = IPAddress.Parse(txtIP.Text); remotePort = int.Parse(txtPort.Text); if (remotePort &lt; 1024 || remotePort &gt; 65535) throw new FormatException(); &#125; catch (FormatException ex) &#123; MessageBox.Show("必须输入一个有效的IP地址，同时端口必须是[1024,65535]之间的整数"); return; &#125; catch (Exception ex) &#123; MessageBox.Show(String.Format("&#123;0&#125;:&#123;1&#125;", ex.GetType(), ex.Message)); return; &#125; //屏蔽掉两个按钮 EnableOrDisableControl(btnChooseFile, false); EnableOrDisableControl( btnUpload, false); Thread th = new Thread(Upload); th.IsBackground = true; th.Start(UploadFileName); &#125; private IPAddress remoteAddress = null; private int remotePort; private void Upload(object FileName) &#123; string Info = ""; IPEndPoint remoteEndPoint = new IPEndPoint(remoteAddress, remotePort); //创建套接字，使用TCP协议 Socket server = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); try &#123; server.Connect(remoteEndPoint); &#125; catch (SocketException e) &#123; Info = string.Format("无法连接远程主机 &#123;0&#125; ,原因：&#123;1&#125;，NativeErrorCode：&#123;2&#125;,SocketErrorCode:&#123;3&#125;", remoteAddress, e.Message, e.NativeErrorCode, e.SocketErrorCode); this.Invoke(ShowInfoInForm, Info); //激活掉两个按钮 this.Invoke(EnableOrDisableControl, btnChooseFile, true); this.Invoke(EnableOrDisableControl, btnUpload, true); //隐藏进度条 this.Invoke(ShowOrHideControl, prgUpload, false); return; &#125; try &#123; //将文件名发送到远程主机 SocketHelper.SendVarData(server, Encoding.UTF8.GetBytes(Path.GetFileName(FileName as string))); //等待服务端发回响应…… Info = "服务端发回：" + Encoding.UTF8.GetString(SocketHelper.ReceiveVarData(server)); this.Invoke(ShowInfoInForm, Info); //发送文件长度 FileInfo fi = new FileInfo(FileName as string); long fileLength = fi.Length; SocketHelper.SendVarData(server, BitConverter.GetBytes(fileLength)); Info = "服务端发回：" + Encoding.UTF8.GetString(SocketHelper.ReceiveVarData(server)); this.Invoke(ShowInfoInForm, Info); //显示进度条 this.Invoke(ShowOrHideControl, prgUpload, true); this.Invoke(ShowUploadProcess, 0); byte[] fileBuffer = null; long sentBytes = 0; int progress = 0; //将文件内容读到内存中 using (FileStream fs = new FileStream(FileName as String, FileMode.Open)) &#123; fileBuffer = new byte[8192]; int ReadBytes = 0; while (true) &#123; ReadBytes = fs.Read(fileBuffer, 0, 8192); if (ReadBytes == 0) break; server.Send(fileBuffer, 0, ReadBytes, SocketFlags.None); sentBytes += ReadBytes; double temp = (sentBytes / (double)fileLength) * 100; if (progress &lt; (int)temp) &#123; progress = (int)temp; //显示上传进度…… this.BeginInvoke(ShowUploadProcess, progress); &#125; &#125; &#125; byte[] message = SocketHelper.ReceiveVarData(server); Info = "服务端发来：" + Encoding.UTF8.GetString(message); this.Invoke(ShowInfoInForm, Info); server.Shutdown(SocketShutdown.Both); Info = string.Format("数据发送完毕，断开与服务端的连接..."); this.Invoke(ShowInfoInForm, Info); &#125; catch (Exception ex) &#123; this.Invoke(ShowInfoInForm, ex.Message); &#125; finally &#123; //激活掉两个按钮 this.Invoke(EnableOrDisableControl, btnChooseFile, true); this.Invoke(EnableOrDisableControl, btnUpload, true); //隐藏进度条 this.Invoke(ShowOrHideControl, prgUpload, false); server.Close(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>.NET Framework</category>
        <category>多线程、Socket、异步编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络开发技术基础]]></title>
    <url>%2F2019%2F03%2F07%2F%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Socket开发概述 网络编程预备知识网络协议与信息交换 IP知识 地址种类 IPAddress字段中的特殊IP地址 Any地址 (Socket套接字 绑定到 Any地址) 之所以是合适的额本机IP地址 因为一个主机可以有多个网卡 None地址 IPv6None和IPV6Any的值虽然一样 但是是两个不同的IPAddress对象 所以Socket对象绑定时一个会监听所有网络接口 一个不会监听任何一个接口 广播地址 “环回接口”与本地主机 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394namespace TestIPAddress&#123; class Program &#123; static void Main(string[] args) &#123; //一些特殊的IP地址 Console.WriteLine("一些特殊的IP地址:"); PrintSpecialIPAddress(); //查看指定IP地址的十六进制形式 PrintIPAddress(IPAddress.Any); PrintIPAddress(IPAddress.IPv6Any); PrintIPAddress(IPAddress.IPv6Loopback); //获取本地计算机主机名 String LocalhostName = Dns.GetHostName(); Console.WriteLine("\n本机名称:&#123;0&#125;", LocalhostName); Console.WriteLine("\n本地主机IP地址："); PrintHostAddresses(LocalhostName); Console.WriteLine("\n微软公司主机IP地址："); PrintHostAddresses("www.microsoft.com"); Console.WriteLine("\n微软公司主机的详细信息："); PrintHostEntry("www.microsoft.com"); Console.ReadKey(); &#125; public static void PrintSpecialIPAddress() &#123; Console.WriteLine("IPAddress.Any:\t&#123;0&#125;", IPAddress.Any); Console.WriteLine("IPAddress.IPv6Any:\t&#123;0&#125;", IPAddress.IPv6Any); Console.WriteLine("IPAddress.IPv6Loopback:\t&#123;0&#125;", IPAddress.IPv6Loopback); Console.WriteLine("IPAddress.Loopback:\t&#123;0&#125;", IPAddress.Loopback); Console.WriteLine("IPAddress.None:\t&#123;0&#125;", IPAddress.None); Console.WriteLine("IPAddress.IPv6None:\t&#123;0&#125;", IPAddress.IPv6None); Console.WriteLine("IPAddress.Broadcast:\t&#123;0&#125;", IPAddress.Broadcast); &#125; /// &lt;summary&gt; /// 输出IP地址的经典形式和十六进制形式 /// &lt;/summary&gt; /// &lt;param name="ipAddress"&gt;&lt;/param&gt; public static void PrintIPAddress(IPAddress ipAddress) &#123; Console.WriteLine(ipAddress.ToString()); //获取字节数组 不带点的 Byte[] bytes = ipAddress.GetAddressBytes(); //BitConverter 将基数据类型转换为一个字节数组以及将一个字节数组转换为基数据类型。 //将指定的字节数组的每个元素的数值转换为其等效的十六进制字符串表示形式。 Console.WriteLine(BitConverter.ToString(bytes)); &#125; public static void PrintHostAddresses(string hostname) &#123; // 返回指定的主机的 Internet 协议 (IP) 地址。 IPAddress[] ips = Dns.GetHostAddresses(hostname); Console.WriteLine("GetHostAddresses(&#123;0&#125;) returns:", hostname); foreach (IPAddress ip in ips) &#123; Console.WriteLine(" AddressFamily:&#123;0&#125; Address:&#123;1&#125;", ip.AddressFamily, ip); &#125; &#125; public static void PrintHostEntry(string hostname) &#123; IPHostEntry host = Dns.GetHostEntry(hostname); //主机名或 IP 地址解析为 System.Net.IPHostEntry 实例。 Console.WriteLine("GetHostEntry(&#123;0&#125;) returns:", hostname); Console.WriteLine("主机名称:&#123;0&#125;", host.HostName); if (host.Aliases.Length &gt; 0) &#123; Console.WriteLine("主机&#123;0&#125;拥有以下别名:",hostname); foreach (string name in host.Aliases) Console.WriteLine(" &#123;0&#125;", name); &#125; Console.WriteLine("主机&#123;0&#125;拥有以下IP地址:", hostname); foreach (IPAddress ip in host.AddressList) &#123; Console.WriteLine(" AddressFamily:&#123;0&#125; Address:&#123;1&#125;", ip.AddressFamily, ip); &#125; &#125; &#125;&#125; 理解“IPEndPoint”–网络服务访问点 Tcp数据包中的端口 IP数据包中的IP地址信息 网络数据包之洋葱结构 网络服务点 Socket概述Socket与网络编程 .NET Framework中的Socket .NET Socket支持的四种编程模式 Windows平台网络技术 为什么要学Socket Socket编程初步 服务端Socket 什么是绑定 什么叫监听 服务端Socket的连接队列 响应连接请求 服务端Socket接收数据 关闭Socket 客户端Socket 小结：使用Socket的步骤 示例：服务器端和客户端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455namespace MyServerApp&#123; class Program &#123; /// &lt;summary&gt; /// 数据接收缓冲区尺寸 /// &lt;/summary&gt; private const int BufferSize = 1024; static void Main(string[] args) &#123; byte[] data = new byte[BufferSize]; //获取本机地址 IPAddress localAddress = AddressHelper.GetLocalhostIPv4Addresses().First(); int LocalPort = AddressHelper.GetOneAvailablePortInLocalhost(); //创建IP终结点 IPEndPoint ipep = new IPEndPoint(localAddress,LocalPort); //创建套接字，使用TCP协议 Socket server = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); using (server) &#123; //绑定 server.Bind(ipep); //开始监听 server.Listen(10); //server.Listen(1); while (true) &#123; Console.WriteLine("主机 &#123;0&#125; 正在监听端口 &#123;1&#125; ，等待客户端连接……", localAddress,ipep.Port ); //如果有客户端连接…… 程序会在这里等待连接 Socket client = server.Accept(); IPEndPoint clientep = (IPEndPoint)client.RemoteEndPoint; Console.WriteLine("已接收客户端连接，客户端IP地址：&#123;0&#125; 开放端口：&#123;1&#125;", clientep.Address, clientep.Port); //接收数据到接收缓冲区 返回长度 int recv = client.Receive(data); //有意拖慢server处理速度 Thread.Sleep(300); Console.WriteLine(Encoding.UTF8.GetString(data, 0, recv)); Console.WriteLine("客户端 &#123;0&#125; 断开连接\n", clientep.Address); client.Shutdown(SocketShutdown.Both); client.Close(); &#125; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950namespace MyClientApp&#123; class Program &#123; /// &lt;summary&gt; /// 数据接收缓冲区尺寸 /// &lt;/summary&gt; private const int BufferSize = 1024; static void Main(string[] args) &#123; IPEndPoint iep = null; //要求用户输入有效的远程主机IP地址和端口 while (true) &#123; iep = AddressHelper.GetRemoteMachineIPEndPoint(); if (iep != null) break; &#125; byte[] data = new byte[BufferSize]; Socket server = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); try &#123; server.Connect(iep); IPAddress localAddress = AddressHelper.GetLocalhostIPv4Addresses().First(); string Message = string.Format("客户端 &#123;0&#125; 向服务端问好！", localAddress); server.Send(Encoding.UTF8.GetBytes(Message)); server.Shutdown(SocketShutdown.Both); &#125; catch (SocketException e) &#123; Console.WriteLine("无法连接远程主机 &#123;0&#125; ,原因：&#123;1&#125;，NativeErrorCode：&#123;2&#125;,SocketErrorCode:&#123;3&#125;", iep.Address, e.Message, e.NativeErrorCode, e.SocketErrorCode); &#125; finally &#123; server.Close(); &#125; Console.WriteLine("消息发送完毕，断开与服务端的连接。"); Console.WriteLine("敲任意键退出..."); Console.ReadKey(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586namespace MyNetworkLibrary&#123; public static class AddressHelper &#123; /// &lt;summary&gt; /// 获取本机IPv4地址的集合 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static IPAddress[] GetLocalhostIPv4Addresses() &#123; String LocalhostName = Dns.GetHostName(); IPHostEntry host = Dns.GetHostEntry(LocalhostName); List&lt;IPAddress&gt; addresses=new List&lt;IPAddress&gt;(); foreach (IPAddress ip in host.AddressList) &#123; if (ip.AddressFamily == AddressFamily.InterNetwork) addresses.Add(ip); &#125; return addresses.ToArray(); &#125; /// &lt;summary&gt; /// 以交互方式生成有效的远程主机访问终结点,适用于控制台程序 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static IPEndPoint GetRemoteMachineIPEndPoint() &#123; IPEndPoint iep = null; try &#123; Console.Write("请输入远程主机的IP地址："); IPAddress address = IPAddress.Parse(Console.ReadLine()); Console.Write("请输入远程主机打开的端口号："); int port = Convert.ToInt32(Console.ReadLine()); if (port &gt; 65535 || port &lt; 1024) throw new Exception("端口号应该为[1024,65535]范围内的整数"); iep = new IPEndPoint(address, port); &#125; catch (ArgumentNullException) &#123; Console.WriteLine("输入的数据有误！"); &#125; catch (FormatException) &#123; Console.WriteLine("输入的数据有误！"); &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); &#125; return iep; &#125; /// &lt;summary&gt; /// 获取本机当前可用的端口号，此方法是线程安全的 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static int GetOneAvailablePortInLocalhost() &#123; //The name of the System.Threading.Mutex. Mutex mtx = new Mutex(false, "MyNetworkLibrary.AddressHelper.GetOneAvailablePort"); try &#123; // Blocks the current thread until the current System.Threading.WaitHandle receives a signal. mtx.WaitOne(); // 0 to specify any available port. IPEndPoint ep = new IPEndPoint(IPAddress.Any, 0); using (Socket tempSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp)) &#123; tempSocket.Bind(ep); IPEndPoint ipep = tempSocket.LocalEndPoint as IPEndPoint; return ipep.Port; &#125; &#125; finally &#123; mtx.ReleaseMutex(); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162namespace MyNetworkLibrary&#123; public static class SocketHelper &#123; /// &lt;summary&gt; /// 接收变长的数据，要求其打头的4个字节代表有效数据的长度 /// &lt;/summary&gt; /// &lt;param name="s"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static byte[] ReceiveVarData(Socket s) &#123; if (s == null) throw new ArgumentNullException("s"); int total = 0; //已接收的字节数 int recv; //接收4个字节，得到“消息长度” byte[] datasize = new byte[4]; recv = s.Receive(datasize, 0, 4, 0); int size = BitConverter.ToInt32(datasize, 0); //按消息长度接收数据 int dataleft = size; byte[] data = new byte[size]; while (total &lt; size) &#123; recv = s.Receive(data, total, dataleft, 0); if (recv == 0) &#123; break; &#125; total += recv; dataleft -= recv; &#125; return data; &#125; /// &lt;summary&gt; /// 发送变长的数据，将数据长度附加于数据开头 /// &lt;/summary&gt; /// &lt;param name="s"&gt;&lt;/param&gt; /// &lt;param name="data"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static int SendVarData(Socket s, byte[] data) &#123; int total = 0; int size = data.Length; //要发送的消息长度 int dataleft = size; //剩余的消息 int sent; //将消息长度（int类型）的，转为字节数组 byte[] datasize = BitConverter.GetBytes(size); //将消息长度发送出去 sent = s.Send(datasize); //发送消息剩余的部分 while (total &lt; size) &#123; sent = s.Send(data, total, dataleft, SocketFlags.None); total += sent; dataleft -= sent; &#125; return total; &#125; &#125;&#125; Socket示例分析与展示Socket连接队列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374namespace MyClientApp2&#123; class Program &#123; /// &lt;summary&gt; /// 数据接收缓冲区尺寸 /// &lt;/summary&gt; private const int BufferSize = 1024; /// &lt;summary&gt; /// 要打开的Socket的数目 /// &lt;/summary&gt; private const int SocketCount = 10; static void Main(string[] args) &#123; IPEndPoint iep = null; //要求用户输入有效的远程主机IP地址和端口 while (true) &#123; iep = AddressHelper.GetRemoteMachineIPEndPoint(); if (iep != null) break; &#125; IPAddress localAddress = AddressHelper.GetLocalhostIPv4Addresses().First(); Socket[] Sockets = new Socket[SocketCount]; for (int i = 0; i &lt; SocketCount; i++) Sockets[i] = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); for (int i = 0; i &lt; SocketCount; i++) &#123; Socket server = Sockets[i]; Action&lt;object&gt; dele = delegate(object index) &#123; byte[] data = new byte[BufferSize]; try &#123; server.Connect(iep); string Message = string.Format("客户端 &#123;0&#125;:&#123;1&#125; 向服务端问好！", localAddress, index); byte[] bytes = Encoding.UTF8.GetBytes(Message); server.Send(bytes); Console.WriteLine("客户端 &#123;0&#125;:&#123;1&#125;完成向服务端发送信息的任务", localAddress, index); &#125; catch (SocketException e) &#123; Console.WriteLine("无法连接远程主机 &#123;0&#125; ,原因：&#123;1&#125;，NativeErrorCode：&#123;2&#125;,SocketErrorCode:&#123;3&#125;", iep.Address, e.Message, e.NativeErrorCode, e.SocketErrorCode);//NativeErrorCode The Win32 error code associated with this exception.//SocketErrorCode Gets the error code that is associated with this exception. &#125; finally &#123; server.Close(); &#125; &#125;; Thread th = new Thread(new ParameterizedThreadStart(dele)); th.Start(i); &#125; //catch (Exception ex) //&#123; // Console.WriteLine(ex); //&#125; Console.WriteLine("敲任意键退出..."); Console.ReadKey(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364namespace EchoServiceApp&#123; class Program &#123; /// &lt;summary&gt; /// 数据接收缓冲区尺寸 /// &lt;/summary&gt; private const int BufferSize = 1024; static void Main(string[] args) &#123; byte[] data = new byte[BufferSize]; //获取本机地址 IPAddress localAddress = AddressHelper.GetLocalhostIPv4Addresses().First(); int LocalPort = AddressHelper.GetOneAvailablePortInLocalhost(); //创建IP终结点 IPEndPoint ipep = new IPEndPoint(localAddress, LocalPort); while (true) &#123; //创建套接字，使用TCP协议 Socket newsock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); using (newsock) &#123; //绑定 newsock.Bind(ipep); //开始监听 newsock.Listen(1); Console.WriteLine("主机 &#123;0&#125; 正在监听端口 &#123;1&#125; ，等待客户端连接……", localAddress, ipep.Port); //如果有客户端连接…… Socket client = newsock.Accept(); IPEndPoint clientep = (IPEndPoint)client.RemoteEndPoint; Console.WriteLine("已接收客户端连接，客户端IP地址：&#123;0&#125; 开放端口：&#123;1&#125;", clientep.Address, clientep.Port); string welcome = "欢迎使用本网络服务,请输入字串，输入exit退出……"; data = Encoding.UTF8.GetBytes(welcome); client.Send(data, data.Length, SocketFlags.None); int recv = 0; string StringSentByClient = ""; while (true) &#123; recv = client.Receive(data); StringSentByClient = Encoding.UTF8.GetString(data, 0, recv); Console.WriteLine("客户端传来：&#123;0&#125;", StringSentByClient); if (StringSentByClient == "exit") &#123; Console.WriteLine("断开客户端 &#123;0&#125; 连接\n", clientep.Address); client.Close(); break; &#125; byte[] EchoStringBytes = Encoding.UTF8.GetBytes(String.Format("你所发来的信息“&#123;0&#125;”已收到，谢谢！", StringSentByClient)); client.Send(EchoStringBytes); &#125; &#125; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667namespace EchoServiceClientApp&#123; class Program &#123; /// &lt;summary&gt; /// 数据接收缓冲区尺寸 /// &lt;/summary&gt; private const int BufferSize = 1024; static void Main(string[] args) &#123; byte[] data = new byte[BufferSize]; IPEndPoint ipep = null; //要求用户输入有效的远程主机IP地址和端口 while (true) &#123; ipep = AddressHelper.GetRemoteMachineIPEndPoint(); if (ipep != null) break; &#125; //创建套接字，使用TCP协议 Socket server = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); String stringData = ""; try &#123; server.Connect(ipep); Console.WriteLine("服务端已连接"); &#125; catch (SocketException e) &#123; Console.WriteLine("无法连接远程主机 &#123;0&#125; ,原因：&#123;1&#125;，NativeErrorCode：&#123;2&#125;,SocketErrorCode:&#123;3&#125;", ipep.Address, e.Message, e.NativeErrorCode, e.SocketErrorCode); Console.WriteLine("敲任意键退出..."); Console.ReadKey(); return; &#125; int recv = server.Receive(data); stringData = Encoding.UTF8.GetString(data, 0, recv); Console.WriteLine(stringData); String UserInput = ""; while (true) &#123; UserInput = Console.ReadLine(); if (UserInput == "") continue; byte[] SentBytes = Encoding.UTF8.GetBytes(UserInput); server.Send(SentBytes); if (UserInput == "exit") &#123; server.Shutdown(SocketShutdown.Both); server.Close(); Console.WriteLine("断开与服务端的连接。"); break; &#125; recv = server.Receive(data); stringData = Encoding.UTF8.GetString(data, 0, recv); Console.WriteLine(stringData); &#125; Console.WriteLine("敲任意键退出……"); Console.ReadKey(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>.NET Framework</category>
        <category>多线程、Socket、异步编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程同步]]></title>
    <url>%2F2019%2F03%2F06%2F%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[遵守交通规则 多线程开发困境 线程同步 死锁线程交叉等待 123456789101112131415161718192021222324252627282930313233namespace JoinLeadToDeadlock&#123; class Program &#123; static Thread mainThread; static void Main(string[] args) &#123; Console.WriteLine("主线程开始运行"); mainThread = Thread.CurrentThread; Thread ta = new Thread(new ThreadStart(ThreadAMethod)); ta.Start(); Console.WriteLine("主线程等待线程A结束……"); ta.Join(); //等待线程A结束 Console.WriteLine("主线程退出"); &#125; static void ThreadAMethod() &#123; for (int i = 0; i &lt; 10; i++) &#123; Console.WriteLine(Convert.ToString(i) + ": 线程A正在执行"); Thread.Sleep(1000); &#125; Console.WriteLine("线程A等待主线程退出……"); //等待主线程结束 mainThread.Join(); &#125; &#125;&#125; 共享资源造成死锁 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455namespace SharedResourceLeadToDeadlock&#123; class Program &#123; //共享资源 static SharedResource R1 = new SharedResource(); static SharedResource R2 = new SharedResource(); static void Main(string[] args) &#123; Thread th1 = new Thread(UseSharedResource1); Thread th2 = new Thread(UseSharedResource2); th1.Start(); th2.Start(); //等待两线程运行结束 th1.Join(); th2.Join(); &#125; static void UseSharedResource1() &#123; System.Console.WriteLine("线程&#123;0&#125;申请使用资源R1", Thread.CurrentThread.ManagedThreadId); Monitor.Enter(R1); System.Console.WriteLine("线程&#123;0&#125;独占使用资源R1", Thread.CurrentThread.ManagedThreadId); Thread.Sleep(1000); System.Console.WriteLine("线程&#123;0&#125;申请使用资源R2", Thread.CurrentThread.ManagedThreadId); Monitor.Enter(R2); System.Console.WriteLine("线程&#123;0&#125;独占使用资源R2", Thread.CurrentThread.ManagedThreadId); Thread.Sleep(1000); System.Console.WriteLine("线程&#123;0&#125;资源R2使用完毕，放弃", Thread.CurrentThread.ManagedThreadId); Monitor.Exit(R2); System.Console.WriteLine("线程&#123;0&#125;资源R1使用完毕，放弃", Thread.CurrentThread.ManagedThreadId); Monitor.Exit(R1); &#125; static void UseSharedResource2() &#123; System.Console.WriteLine("线程&#123;0&#125;申请使用资源R2", Thread.CurrentThread.ManagedThreadId); Monitor.Enter(R2); System.Console.WriteLine("线程&#123;0&#125;独占使用资源R2", Thread.CurrentThread.ManagedThreadId); Thread.Sleep(500); System.Console.WriteLine("线程&#123;0&#125;申请使用资源R1", Thread.CurrentThread.ManagedThreadId); Monitor.Enter(R1); System.Console.WriteLine("线程&#123;0&#125;独占使用资源R1", Thread.CurrentThread.ManagedThreadId); Thread.Sleep(500); System.Console.WriteLine("线程&#123;0&#125;资源R1使用完毕，放弃", Thread.CurrentThread.ManagedThreadId); Monitor.Exit(R1); System.Console.WriteLine("线程&#123;0&#125;资源R2使用完毕，放弃", Thread.CurrentThread.ManagedThreadId); Monitor.Exit(R2); &#125; &#125; class SharedResource &#123; &#125;&#125; 多线程读写出错 12345678910111213141516171819202122232425262728293031323334353637383940namespace SharedResourceLeadToDataError&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine("4个线程递增SharedResource.Count值，每个线程增加10000，最后结果应该为40000"); Thread[] ths = new Thread[4]; for (int i = 0; i &lt; 4; i++) &#123; ths[i]=new Thread(increaseCount); ths[i].Start(); &#125; System.Console.ReadKey(); &#125; static void increaseCount() &#123; Random ran = new Random(); Thread.Sleep(ran.Next(100, 5000)); int beginNum = SharedResource.Count; System.Console.WriteLine("线程 &#123;0&#125; 读到的起始值为 &#123;1&#125; ", Thread.CurrentThread.ManagedThreadId, beginNum ); for (int i = 0; i &lt; 10000; i++) &#123; beginNum ++; &#125; SharedResource.Count = beginNum; System.Console.WriteLine("线程 &#123;0&#125; 结束，SharedResource.Count=&#123;1&#125;", Thread.CurrentThread.ManagedThreadId,SharedResource.Count); &#125; &#125; class SharedResource &#123; public static int Count = 0; &#125;&#125; 线程同步方法-锁 .NET的Monitor对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576namespace UseMonitor1&#123; class Program &#123; static void Main(string[] args) &#123; SharedResource obj = new SharedResource(); Thread[] ths = new Thread[4]; for (int i = 0; i &lt; 4; i++) &#123; ths[i] = new Thread(increaseCount); ths[i].Start(obj); &#125; Console.ReadKey(); Console.WriteLine("最终结果：obj.DynamicCount=&#123;0&#125;,SharedResource.StaticCount=&#123;1&#125;", obj.DynamicCount, SharedResource.StaticCount); Console.ReadKey(); &#125; static void increaseCount(Object obj) &#123; //访问实例字段 VisitDynamicField(obj); //访问静态字段 VisitStaticField(); &#125; //访问静态字段 private static void VisitStaticField() &#123; //访问静态字段 Monitor.Enter(typeof(SharedResource)); int beginNumber = SharedResource.StaticCount; System.Console.WriteLine("线程 &#123;0&#125; 读到的StaticCount起始值为 &#123;1&#125; ", Thread.CurrentThread.ManagedThreadId, beginNumber); for (int i = 0; i &lt; 10000; i++) &#123; beginNumber++; &#125; SharedResource.StaticCount = beginNumber; System.Console.WriteLine("线程 &#123;0&#125; 结束， SharedResource.StaticCount=&#123;1&#125;", Thread.CurrentThread.ManagedThreadId, SharedResource.StaticCount); Monitor.Exit(typeof(SharedResource)); &#125; //访问实例字段 private static void VisitDynamicField(Object obj) &#123; Monitor.Enter(obj); //lock (obj) //&#123; int beginNumber = (obj as SharedResource).DynamicCount; System.Console.WriteLine("线程 &#123;0&#125; 读到的DynamicCount起始值为 &#123;1&#125; ", Thread.CurrentThread.ManagedThreadId, beginNumber); for (int i = 0; i &lt; 10000; i++) &#123; beginNumber++; &#125; (obj as SharedResource).DynamicCount = beginNumber; System.Console.WriteLine("线程 &#123;0&#125; 结束，Obj.DynamicCount=&#123;1&#125;", Thread.CurrentThread.ManagedThreadId, (obj as SharedResource).DynamicCount); //&#125; Monitor.Exit(obj); &#125; &#125; //共享资源类 class SharedResource &#123; public int DynamicCount = 0; //多线程共享的实例字段 public static int StaticCount = 0; //多线程共享的静态字段 &#125;&#125; Lock关键字简化Monitor适用于互斥访问，尽量不要用于线程同步 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152namespace UseMonitor2&#123; class Program &#123; static void Main(string[] args) &#123; //创建共享资源 SharedResource obj = new SharedResource(); //创建线程对象并启动 Thread tha = new Thread(ThreadMethodA); Thread thb = new Thread(ThreadMethodB); tha.Start(obj); thb.Start(obj); //程序暂停 System.Console.ReadKey(); &#125; static void ThreadMethodA(Object obj) &#123; lock (obj) &#123; (obj as SharedResource).DynamicCount+=100; System.Console.WriteLine("线程A完成工作，obj.DynamicCount=&#123;0&#125;", (obj as SharedResource).DynamicCount); Monitor.Pulse(obj); //通知B线程 &#125; &#125; static void ThreadMethodB(Object obj) &#123; lock (obj) &#123; //如果注释掉此条件判断语句，则会发生死锁 if((obj as SharedResource).DynamicCount==0) &#123; //释放对象上的锁并阻止当前线程，直到它重新获取该锁。 Monitor.Wait(obj);//等待 &#125; (obj as SharedResource).DynamicCount+=100; System.Console.WriteLine("线程B完成工作，obj.DynamicCount=&#123;0&#125;", (obj as SharedResource).DynamicCount); &#125; &#125; &#125; //共享资源类 class SharedResource &#123; public int DynamicCount = 0; //多线程共享的实例字段 &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455namespace UseMonitor3&#123; class Program &#123; static void Main(string[] args) &#123; //创建共享资源 SharedResource obj = new SharedResource(); //创建线程对象并启动 Thread th = new Thread(FirstThreadMethod); th.Start(obj); Thread[] ths = new Thread[10]; for (int i = 0; i &lt; 10; i++) &#123; ths[i] = new Thread(NextThreadMethod); ths[i].Start(obj); &#125; //程序暂停 System.Console.ReadKey(); &#125; static void FirstThreadMethod(Object obj) &#123; lock (obj) &#123; (obj as SharedResource).DynamicCount += 100; System.Console.WriteLine("线程&#123;0&#125;完成工作，obj.DynamicCount=&#123;1&#125;", Thread.CurrentThread.ManagedThreadId, (obj as SharedResource).DynamicCount); Monitor.Pulse(obj); //通知下一线程 &#125; &#125; static void NextThreadMethod(Object obj) &#123; lock (obj) &#123; //初始线程还未工作，因为字段保持初始值0 if ((obj as SharedResource).DynamicCount == 0) Monitor.Wait(obj);//等待 (obj as SharedResource).DynamicCount += 100; System.Console.WriteLine("线程&#123;0&#125;完成工作，obj.DynamicCount=&#123;1&#125;", Thread.CurrentThread.ManagedThreadId, (obj as SharedResource).DynamicCount); Monitor.Pulse(obj); &#125; &#125; &#125; //共享资源类 class SharedResource &#123; public int DynamicCount = 0; //多线程共享的实例字段 &#125;&#125; 1234567891011线程3完成工作，obj.DynamicCount=100线程4完成工作，obj.DynamicCount=200线程6完成工作，obj.DynamicCount=300线程7完成工作，obj.DynamicCount=400线程5完成工作，obj.DynamicCount=500线程8完成工作，obj.DynamicCount=600线程10完成工作，obj.DynamicCount=700线程9完成工作，obj.DynamicCount=800线程11完成工作，obj.DynamicCount=900线程12完成工作，obj.DynamicCount=1000线程13完成工作，obj.DynamicCount=1100 不要将Monitor用于值类型 编写“线程安全”的方法 线程同步方法–等待句柄waitXXX系列方法 waitHandle抽象类 Mutex(适用于整个操作系统进程互斥访问) 互斥访问共享资源 提款示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131namespace UseATM&#123; class Program &#123; static ATM OneATM=new ATM(); //共享资源 static void Main(string[] args) &#123; //向公共帐号存款2万 Console.Write("输入公司公共帐户的金额:"); int PublicAcountMoney =Convert.ToInt32(Console.ReadLine()); OneATM.Deposit(PublicAcountMoney); Console.Write("输入ATM中的现金额:"); int ATMLeftMoney = Convert.ToInt32(Console.ReadLine()); OneATM.SetATMLeftMoney(ATMLeftMoney); System.Console.WriteLine("\n敲任意键从公共帐户中取钱，ESC键退出……\n"); while (System.Console.ReadKey(true).Key !=ConsoleKey.Escape) &#123; System.Console.WriteLine(""); Thread One = new Thread(WithDrawMoney); Thread Two = new Thread(WithDrawMoney); Thread Three = new Thread(WithDrawMoney); //随机生成一个要提款的数额，最少100元，最高5000元 Random ran = new Random(); One.Start(ran.Next(100, 5000)); Two.Start(ran.Next(100, 5000)); Three.Start(ran.Next(100, 5000)); //等三人取完钱 One.Join(); Two.Join(); Three.Join(); System.Console.WriteLine("公共账号剩余&#123;0&#125;元，ATM中可提现金：&#123;1&#125;", OneATM.QueryPublicAccount(),OneATM.QueryATMLeftAccount()); &#125; &#125; //线程函数 static void WithDrawMoney(object amount) &#123; switch(OneATM.WithDraw((int)amount)) &#123; case WithDrawState.Succeed: System.Console.WriteLine("成功取出&#123;0&#125;元。",amount ); break; case WithDrawState.ATMHasNotEnoughCash: System.Console.WriteLine("ATM中现金不足，无法支取&#123;0&#125;元。", amount); break ; case WithDrawState.AccountHasNotEnoughMoney: System.Console.WriteLine("帐户中没钱了！无法取出&#123;0&#125;元",amount); break ; &#125; &#125; &#125; //自助取款机 class ATM &#123; private int PublicAcountLeftMoney;//帐户剩余的钱 private int ATMLeftMoney;//提款机剩余的钱 //同步信息号量 private Mutex m = new Mutex(); //取钱 public WithDrawState WithDraw(int amount) &#123; m.WaitOne(); //公共帐号钱不够 if (PublicAcountLeftMoney &lt; amount) &#123; m.ReleaseMutex(); return WithDrawState.AccountHasNotEnoughMoney; &#125; //ATM现金不够 if (ATMLeftMoney &lt; amount) &#123; m.ReleaseMutex(); return WithDrawState.ATMHasNotEnoughCash; &#125; //用户可以提取现金 ATMLeftMoney -= amount; PublicAcountLeftMoney -= amount; m.ReleaseMutex(); return WithDrawState.Succeed; &#125; //存钱 public void Deposit(int amount) &#123; m.WaitOne(); PublicAcountLeftMoney += amount; m.ReleaseMutex(); &#125; /// &lt;summary&gt; /// 设置ATM的现金金额 /// &lt;/summary&gt; /// &lt;param name="amount"&gt;&lt;/param&gt; public void SetATMLeftMoney(int amount) &#123; Interlocked.Exchange(ref ATMLeftMoney, amount); &#125; //获取还剩余多少钱 public int QueryPublicAccount() &#123; return PublicAcountLeftMoney; &#125; /// &lt;summary&gt; /// 查询ATM剩余多少钱 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public int QueryATMLeftAccount() &#123; return ATMLeftMoney; &#125; &#125; //取款状态 public enum WithDrawState &#123; Succeed, //取钱成功 AccountHasNotEnoughMoney, //账号中没钱了 ATMHasNotEnoughCash //ATM中没有足够的现金 &#125;&#125; Semaphore(多个资源同步访问) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677namespace UseLibraryComputer&#123; class Program &#123; //图书馆拥有的公用计算机 private const int ComputerNum = 3; private static Computer[] LibraryComputers; //同步信号量 public static Semaphore sp = new Semaphore( ComputerNum, ComputerNum); static void Main(string[] args) &#123; //图书馆拥有ComputerNum台电脑 LibraryComputers = new Computer[ComputerNum]; for (int i = 0; i &lt;ComputerNum; i++) LibraryComputers[i] = new Computer("Computer"+(i+1).ToString()); int peopleNum = 0; Random ran=new Random(); Thread user; System.Console.WriteLine("敲任意键模拟一批批的人排队使用&#123;0&#125;台计算机，ESC键结束模拟……" ,ComputerNum); //每次创建若干个线程，模拟人排队使用计算机 while (System.Console.ReadKey().Key != ConsoleKey.Escape) &#123; peopleNum = ran.Next(0, 10); System.Console.WriteLine("\n有&#123;0&#125;人在等待使用计算机。",peopleNum ); for (int i = 1; i &lt;= peopleNum; i++) &#123; user = new Thread(UseComputer); user.Start("User" + i.ToString()); &#125; &#125; &#125; //线程函数 static void UseComputer(Object UserName) &#123; sp.WaitOne();//等待计算机可用 //查找可用的计算机 Computer cp=null; for (int i = 0; i &lt; ComputerNum; i++) if (LibraryComputers[i].IsOccupied == false) &#123; cp = LibraryComputers[i]; break; &#125; //使用计算机工作 cp.Use(UserName.ToString()); //不再使用计算机，让出来给其他人使用 sp.Release(); &#125; &#125; class Computer &#123; public readonly string ComputerName = ""; public Computer(string Name) &#123; ComputerName = Name; &#125; //是否被占用 public bool IsOccupied = false; //人在使用计算机 public void Use(String userName) &#123; System.Console.WriteLine("&#123;0&#125;开始使用计算机&#123;1&#125;", userName,ComputerName); IsOccupied = true; Thread.Sleep(new Random().Next(1, 2000)); //随机休眠，以模拟人使用计算机 System.Console.WriteLine("&#123;0&#125;结束使用计算机&#123;1&#125;", userName,ComputerName); IsOccupied = false; &#125; &#125;&#125; EventWaitHandle和红绿灯 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475namespace UseManualResetEvent&#123; class Program &#123; static void Main(string[] args) &#123; CreateThread(); System.Console.WriteLine("R:停止线程,G:运行线程,ESC:退出\n"); while (true) &#123; ConsoleKey key = Console.ReadKey(true).Key; if (key == ConsoleKey.R) //红灯停 MyThread.Stop(); if (key == ConsoleKey.G) //绿灯行 MyThread.Go(); if (key == ConsoleKey.Escape) //程序退出 &#123; MyThread.Stop(); break; &#125; &#125; &#125; //创建3个线程并启动 private static void CreateThread() &#123; Thread[] ths=new Thread[3]; for (int i = 0; i &lt; 3; i++) &#123; ths[i]=new Thread((new MyThread()).DoWork); ths[i].IsBackground = true;//不加这句,则程序不会结束 ths[i].Start(); &#125; &#125; &#125; class MyThread &#123; //多个对象共享"红绿灯" static ManualResetEvent mre = new ManualResetEvent(false); static Random ran = new Random(); //线程函数 public void DoWork() &#123; int Counter = 0; while (true) &#123; mre.WaitOne(); //等待绿灯 Counter++; //随机休眠 Thread.Sleep(ran.Next(100,2000)); System.Console.WriteLine("线程&#123;0&#125;:第&#123;1&#125;次执行",Thread.CurrentThread.ManagedThreadId, Counter ); &#125; &#125; //通知阻塞的线程可以继续运行 public static void Go() &#123; mre.Set(); System.Console.WriteLine("\n绿灯,放行!"); &#125; //让所有正在运行的线程停止运行 public static void Stop() &#123; mre.Reset(); Thread.Sleep(2000); //休眠2秒，等待当前工作线程完成当前工作 System.Console.WriteLine("\n红灯,等待!"); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667namespace UseAutoResetEvent&#123; class Program &#123; static Thread th1, th2, th3; static void Main(string[] args) &#123; CreateThread(); System.Console.WriteLine("G:放行,ESC:退出\n"); while (true) &#123; ConsoleKey key = Console.ReadKey(true).Key; if (key == ConsoleKey.G) MyThread.Go(); if (key == ConsoleKey.Escape) &#123; break; &#125; &#125; &#125; //创建3个线程 private static void CreateThread() &#123; Thread[] ths = new Thread[10]; for (int i = 0; i &lt; 10; i++) &#123; ths[i] = new Thread((new MyThread()).DoWork); ths[i].IsBackground = true;//不加这句,则程序不会结束 ths[i].Start(); &#125; &#125; &#125; class MyThread &#123; //多个对象共享"红绿灯" static AutoResetEvent are = new AutoResetEvent(false); //线程函数,多个线程都拥有多个副本,彼此不相关 public void DoWork() &#123; int Counter = 0; while (true) &#123; are.WaitOne(); Counter++; Thread.Sleep(new Random().Next(100,1000)); System.Console.WriteLine("线程&#123;0&#125;:第&#123;1&#125;次执行", Thread.CurrentThread.ManagedThreadId, Counter); &#125; &#125; //通知阻塞的线程可以继续运行 public static void Go() &#123; are.Set(); System.Console.WriteLine("\n绿灯,放行!"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>.NET Framework</category>
        <category>多线程、Socket、异步编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程开发技术基础]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[让程序再快一点 线程与线程对象多线程认识 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125namespace WhatIsThread&#123; //让进度条显示进度的委托，用于跨线程调用 public delegate void ShowProgressDelegate(ProgressBar prog, int value); //激活某个控件的委托，，用于跨线程调用 public delegate void EnableControlDelegate (Control ctl); public partial class frmWhatIsThread : Form &#123; //当启动线程时，向线程函数传送的信息 class ThreadArgu &#123; public ProgressBar prog; //用于显示工作进度的进度条对象 public Button btnStart; //用于启动多线程工作的按钮对象 &#125; public frmWhatIsThread() &#123; InitializeComponent(); &#125; //一个执行比较长时间的函数(单线程) private void DoLongTaskInSingleThread() &#123; for (int i = 0; i &lt; 100; i++) &#123; progressBarSingleThread.Value= i; Thread.Sleep(100);//暂停，以模拟长的工作任务 &#125; &#125; //一个执行比较长时间的函数(多线程) private void DoLongTaskInMultiThread(Object argu) &#123; for (int i = 0; i &lt; 100; i++) &#123; //通过委托跨线程设置进度条的进度值 (argu as ThreadArgu).prog.Invoke(new ShowProgressDelegate(SetProgressBarValue), new object[] &#123; (argu as ThreadArgu).prog,i &#125;); Thread.Sleep(100);//暂停，以模拟长的工作任务 &#125; //工作结束时，回调，以激活对应的按钮 (argu as ThreadArgu).btnStart.Invoke(new EnableControlDelegate(EnabledControl), new object[] &#123; (argu as ThreadArgu).btnStart&#125;); &#125; //设置进度条的进度值，用于跨线程委托调用 private void SetProgressBarValue(ProgressBar prog,int value) &#123; prog.Value = value; &#125; //使某个控件激活，用于跨线程委托调用 private void EnabledControl(Control ctl) &#123; ctl.Enabled = true; &#125; private void btnStartSingleThread_Click(object sender, EventArgs e) &#123; lblSingleThreadID.Text = Thread.CurrentThread.ManagedThreadId.ToString(); lblSingleThreadID.Refresh(); //不加此句，则标签无法立即显示出信息 btnStartSingleThread.Enabled = false; DoLongTaskInSingleThread(); btnStartSingleThread.Enabled = true ; &#125; //代表两个线程对象 Thread th1, th2; private void btnStartMultiThread1_Click(object sender, EventArgs e) &#123; //灰掉自身，在线程完成前不允许用户再次点击按钮启动新的线程 btnStartMultiThread1.Enabled = false; //创建线程对象 th1 = new Thread(new ParameterizedThreadStart(DoLongTaskInMultiThread)); //显示线程ID lblMultiThreadID1.Text = th1.ManagedThreadId.ToString(); //封装参数 ThreadArgu argu = new ThreadArgu(); argu.prog = progressBarMultiThread1; argu.btnStart = btnStartMultiThread1; //启动线程 th1.Start((Object)argu); &#125; private void frmWhatIsThread_Load(object sender, EventArgs e) &#123; lblMainThread.Text = Thread.CurrentThread.ManagedThreadId.ToString(); &#125; private void btnStartMultiThread2_Click(object sender, EventArgs e) &#123; btnStartMultiThread2.Enabled = false; th2 = new Thread(new ParameterizedThreadStart(DoLongTaskInMultiThread)); lblMultiThreadID2.Text = th2.ManagedThreadId.ToString(); ThreadArgu argu = new ThreadArgu(); argu.prog = progressBarMultiThread2; argu.btnStart = btnStartMultiThread2; th2.Start((Object)argu); &#125; private void frmWhatIsThread_FormClosing(object sender, FormClosingEventArgs e) &#123; //若关闭程序时线程还未终止，则强行中止它 //也可以通过将线程设置为后台线程来自动完成这一工作 if (th1 != null) &#123; if (th1.ThreadState != ThreadState.Stopped) th1.Abort(); &#125; if (th2 != null) &#123; if (th2.ThreadState != ThreadState.Stopped) th2.Abort(); &#125; &#125; &#125;&#125; 线程与线程函数 线程的创建与运行 主线程执行完毕点不定 12345678910111213141516171819202122232425262728293031namespace ThreadCreate&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine("主线程ID：&#123;0&#125;",Thread.CurrentThread.ManagedThreadId); MyClass obj = new MyClass(); //原始写法 Thread th1 = new Thread(new ThreadStart(MyClass.StaticMethod)); Thread th2 = new Thread(new ThreadStart(obj.InstanceMethod)); //简化写法 Thread th3 = new Thread(MyClass.StaticMethod); Thread th4 = new Thread(obj.InstanceMethod); //Lambda表达式写法 Thread th5 = new Thread(() =&gt; &#123; Console.WriteLine("线程&#123;0&#125;执行Lambda表达式", Thread.CurrentThread.ManagedThreadId); &#125;); //启动3个线程运行 th1.Start(); th2.Start(); th5.Start(); Console.WriteLine("主线程&#123;0&#125;任务执行完毕，敲任意键退出", Thread.CurrentThread.ManagedThreadId); Console.ReadKey(); &#125; &#125;&#125; 1234567891011121314namespace ThreadCreate&#123; public class MyClass &#123; public static void StaticMethod() &#123; Console.WriteLine("线程&#123;0&#125;执行MyClass.StaticMethod",Thread.CurrentThread.ManagedThreadId); &#125; public void InstanceMethod() &#123; Console.WriteLine("线程&#123;0&#125;执行MyClass.InstanceMethod", Thread.CurrentThread.ManagedThreadId); &#125; &#125;&#125; 线程暂停和终止 1234567891011121314151617181920namespace ThreadSleep&#123; class Program &#123; static void Main(string[] args) &#123; Thread thread = new Thread(() =&gt; &#123; for(int i=0;i&lt;10;i++) &#123; //修眠0.3秒 Thread.Sleep(300); Console.WriteLine(i); &#125; &#125;); thread.Start(); Console.ReadKey(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748namespace ThreadAbort&#123; class Program &#123; static void Main(string[] args) &#123; System.Console.WriteLine("主线程开始"); //创建线程对象 MyThread obj = new MyThread(); Thread th = new Thread(obj.SomeLongTask); th.IsBackground = true; th.Start();//启动线程 Thread.Sleep(300); //主线程休眠0.3秒 System.Console.WriteLine("主线程调用Abort方法提前中止辅助线程……"); th.Abort(); //提前中止线程 System.Console.WriteLine("主线程结束"); Console.ReadKey(); &#125; &#125; class MyThread &#123; public void SomeLongTask() &#123; try &#123; System.Console.WriteLine("辅助线程开始..."); for (int i = 0; i &lt; 10; i++) &#123; System.Console.WriteLine(i); Thread.Sleep(200); &#125; &#125; catch (ThreadAbortException e) &#123; System.Console.WriteLine("辅助线程被提前中断:&#123;0&#125;", e.Message); Thread.ResetAbort(); //不加此句，CLR会再次抛出ThreadAbortException，从而导致函数最后一句代码不会执行。 &#125; finally &#123; System.Console.WriteLine("完成清理辅助线程占用的资源工作"); &#125; //如果前面没有Thread.ResetAbort()，则程序流程不会执行到此句。 System.Console.WriteLine("辅助线程结束"); &#125; &#125;&#125; 背景线程 线程等待 12345678910111213141516171819202122232425namespace ThreadJoin&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine("主线程开始运行"); Thread th = new Thread(new ThreadStart(ThreadAMethod)); th.Start(); th.Join(); Console.WriteLine("主线程退出"); Console.ReadKey(); &#125; static void ThreadAMethod() &#123; for (int i = 0; i &lt; 5; i++) &#123; Console.WriteLine("辅助线程正在执行:"+i.ToString()); Thread.Sleep(200); &#125; Console.WriteLine("辅助线程执行结束"); &#125; &#125;&#125; 线程状态 123456789101112131415161718namespace ThreadState&#123; class Program &#123; static void Main(string[] args) &#123; Thread thread = new Thread(() =&gt; &#123; Console.WriteLine(Thread.CurrentThread.ThreadState); &#125;); Console.WriteLine(thread.ThreadState); thread.Start(); thread.Join(); Console.WriteLine(thread.ThreadState); Console.ReadKey(); &#125; &#125;&#125; 多线程开发技术基础线程函数带参数 外套函数 ParameterizedThreadStart委托 单参数、无返回值 多参数、有返回值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687namespace InvokeMethodDemo&#123; class Program &#123; static void Main(string[] args) &#123; // WrapperMethod(); //ThreadArgumentObject(); Console.ReadKey(); &#125; //外套方法 private static void WrapperMethod() &#123; //设定参数值 MyThread obj = new MyThread() &#123; x = 100, y = 200 &#125;; //启动线程 Thread th = new Thread(obj.ThreadMethod); th.Start(); //等待线程运行结束 th.Join(); //获取函数返回值 Console.WriteLine(obj.returnVaule); &#125; class MyThread &#123; public long SomeFunc(int x, int y) &#123; return x + y; &#125; //将SomeFunc参数和返回值外化为类的公有字段 public int x; public int y; public long returnVaule; //供多线程调用的“外套”函数 public void ThreadMethod() &#123; returnVaule = SomeFunc(x, y); &#125; &#125; private static void ThreadArgumentObject() &#123; //创建 线程执行函数的对象 MyThread2 obj = new MyThread2(); var argu = new ThreadMethodHelper(); //设定线程函数参数 argu.x = 100; argu.y = 200; //创建线程对象 Thread t = new Thread( new ParameterizedThreadStart(obj.SomeFunc)); //启动线程,向线程传送线程参数 t.Start(argu); //主线程干其他事…… t.Join();//等待辅助线程结束 Console.WriteLine(argu.returnVaule); //取回线程结果 &#125; &#125; class MyThread2 &#123; public void SomeFunc(object argu) &#123; int x = (argu as ThreadMethodHelper).x; int y = (argu as ThreadMethodHelper).y; //使用x和y完成一些工作，结果保存在returnVaule中 (argu as ThreadMethodHelper).returnVaule = x+y; &#125; &#125; class ThreadMethodHelper &#123; //线程输入参数 public int x; public int y; //函数返回值 public long returnVaule; &#125;&#125; 线程辅助参数对象示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556namespace UseArray&#123; class Program &#123; static void Main(string[] args) &#123; //创建线程 线程函数带参数（返回void 参数是object ） Thread th = new Thread(DoWithArray); //封装线程的输入输出参数 ThreadMethodHelper argu = new ThreadMethodHelper(); argu.arr = new int[] &#123; -1, 9, 100, 78, 23, 54, -90 &#125;; th.Start(argu); th.Join(); Console.WriteLine("数组元素清单"); foreach (int i in argu.arr) &#123; Console.Write(i.ToString() + " "); &#125; Console.WriteLine(); Console.WriteLine("最大值:&#123;0&#125;", argu.MaxValue); Console.WriteLine("最小值:&#123;0&#125;", argu.MinValue); Console.WriteLine("总和:&#123;0&#125;", argu.Sum ); Console.WriteLine("平均值:&#123;0&#125;", argu.Average ); Console.ReadKey(); &#125; static void DoWithArray(object obj) &#123; ThreadMethodHelper argu = obj as ThreadMethodHelper; for (int i = 0; i &lt; argu.arr.Length; i++) &#123; if (argu.arr[i] &gt; argu.MaxValue) argu.MaxValue = argu.arr[i]; if (argu.arr[i] &lt; argu.MinValue) argu.MinValue = argu.arr[i]; argu.Sum += argu.arr[i]; &#125; argu.Average = argu.Sum / argu.arr.Length; &#125; &#125; //封装线程的输入和输出信息 class ThreadMethodHelper &#123; //线程输入参数 public int[] arr; //函数返回值 public int MaxValue=0; public int MinValue=0; public long Sum=0; public double Average=0; &#125;&#125; 多线程回调示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273namespace SortArray&#123; class Program &#123; static void Main(string[] args) &#123; MyThread obj = new MyThread(); //挂接回调函数 obj.createArr = CreateIntArray; obj.showArr = ShowArray; //启动线程 Thread th = new Thread(obj.SortArray); th.Start(); System.Console.ReadKey(); &#125; //供回调的方法，其功能为：创建数组，以随机数填充 static int[] CreateIntArray() &#123; int[] arr=new int[10]; Random ran=new Random(); for(int i=0;i&lt;10;i++) arr[i]=ran.Next(1,100); //生成1～100间的随机数 return arr; &#125; //供回调的方法，其功能为：显示所有数组元素 static void ShowArray(int[] arr) &#123; foreach (int elem in arr) System.Console.Write(elem.ToString() + " "); &#125; &#125; //定义两个用于回调的委托 public delegate int[] CreateIntArrayDelegate(); public delegate void ShowArrayDelegate(int[] arr); class MyThread &#123; //由外界负责提供的数组生成函数和显示数组内容的函数 public CreateIntArrayDelegate createArr; public ShowArrayDelegate showArr; public void SortArray() &#123; //创建一个数组 int[] arr=createArr(); System.Console.WriteLine("原始数组："); //回调：显示数组原先的元素内容 showArr(arr); //使用冒泡法对数组元素排序（升序） int temp = 0; for(int i=0;i&lt;arr.Length-1 ;i++) for(int j=i+1;j&lt;arr.Length;j++) if (arr[i] &gt; arr[j]) //交换两个数组元素 &#123; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; System.Console.WriteLine("\n排序之后："); //回调：显示排序之后的数组元素 showArr(arr); &#125; &#125;&#125; 跨线程更新UI界面 UI线程(消息循环、消息队列） 窗体过程(响应消息函数) 跨线程访问UI的方法 12345678910111213141516171819202122232425262728namespace VisitVisualControl2&#123; public partial class frmVisitControl : Form &#123; public frmVisitControl() &#123; InitializeComponent(); &#125; private void ThreadMethod() &#123; Action del = delegate() &#123; label1.Text = "Hello"; &#125;; label1.Invoke(del); //或异步调用方法 //label1.BeginInvoke(del); &#125; private void btnVisitLabel_Click(object sender, EventArgs e) &#123; Thread th = new Thread(ThreadMethod); th.Start(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627namespace VisitVisualControl3&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private void ThreadMethod(Object info) &#123; Action&lt;string&gt; del = delegate(string infovalue) &#123; lblInfo.Text = infovalue; &#125;; //参数是由 th.start(arg)传入 lblInfo.Invoke(del, new object[] &#123; info &#125;); &#125; private void btnVisitLabel_Click(object sender, EventArgs e) &#123; Thread th = new Thread(ThreadMethod); th.Start(txtUserInput.Text); &#125; &#125;&#125; BackGroundWork组件使用指南组件概述 任务信息传送 任务结果取回 取消工作任务 向外界报告工作进度ProgressChanged响应事件代码是运行再UI线程中的，不需要用Invoke方法。 组件使用要点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485namespace UseBackgroundWorker&#123; public partial class frmShowPercentage : Form &#123; public frmShowPercentage() &#123; InitializeComponent(); &#125; //线程干活代码 通过参数e 可以获取外界传入的参数 private void backgroundWorker1_DoWork(object sender, DoWorkEventArgs e) &#123; //获取BackgroundWorker组件的引用 BackgroundWorker bw=sender as BackgroundWorker; //开始计算1＋2＋……＋100 int result = 0; //暂存结果 for (int i = 0; i &lt;=100; i++) &#123; //如果用户取消了操作--外界调用组件的CancelAsync()方法时 这个标志会置位 if (bw.CancellationPending) &#123; e.Cancel = true;//此结果将会被传送到RunWorkerCompleted事件中 return ; //提前结束工作任务 &#125; result += i; //累加 //报告进度-- 触发ProgressChanged事件 参数： int 百分比 object useState //当前工作完成的百分比和其他附加信息 bw.ReportProgress(i,"已完成了"+(i).ToString()+"%"); Thread.Sleep((int)e.Argument); //外部传入的参数，休眠特定的时间 &#125; e.Result = result; //向外界返回1＋2＋……＋100的值 &#125; private void backgroundWorker1_ProgressChanged(object sender, ProgressChangedEventArgs e) &#123; //进度改变事件参数对象 包括 进度值和附加信息 progressBar1.Value = e.ProgressPercentage;//显示百分比 lblInfo.Text = e.UserState.ToString(); //显示文字信息 &#125;//工作任务结束后BackgroundWorker组件激发RunWorkerCompleted事件，在//此事件的参数e（RunWorkerCompletedEventArgs 类型的对象）中可以取回工//作结果。 private void backgroundWorker1_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e) &#123; if (e.Cancelled) &#123; toolStripStatusLabel1.Text = "用户取消了操作"; btnStart.Enabled = true; return; &#125; if (e.Error != null) &#123; toolStripStatusLabel1.Text = e.Error.Message; return; &#125; lblResult.Text = e.Result.ToString(); btnStart.Enabled = true; toolStripStatusLabel1.Text = "计算完成"; &#125; private void btnStart_Click(object sender, EventArgs e) &#123; lblResult.Text = "?"; lblResult.Refresh(); //启动工作任务 触发DoWork事件 同时传入线程工作需要的参数 形参是 object类型 backgroundWorker1.RunWorkerAsync(200); btnStart.Enabled = false; toolStripStatusLabel1.Text = "正在工作……"; &#125; private void btnCancel_Click(object sender, EventArgs e) &#123; backgroundWorker1.CancelAsync(); &#125; private void btnClose_Click(object sender, EventArgs e) &#123; Close(); &#125; &#125;&#125; 多线程文件搜索器开发 功能简介 技术分析 程序架构 系统设计结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106namespace MyFileSearcher&#123; /// &lt;summary&gt; /// 实现文件搜索功能 /// &lt;/summary&gt; public class FileSearcher : BackgroundWorker &#123; public FileSearcher() : base() &#123; this.WorkerReportsProgress = true; //允许报告进度 this.WorkerSupportsCancellation = true; //支持用户取消操作 &#125; /// &lt;summary&gt; /// 外界传入的用于显示搜索信息的委托，有一个参数表示文件列表 /// &lt;/summary&gt; public Action&lt;FileInfo[]&gt; ShowSearchResult = null; /// &lt;summary&gt; /// 代表一个将在UI线程中执行的异步操作 /// &lt;/summary&gt; private AsyncOperation asyncOperation = AsyncOperationManager.CreateOperation(null); /// &lt;summary&gt; /// 提供要搜索文件的相关信息 /// &lt;/summary&gt; public SearchInfo SearchInfoObj=null; /// &lt;summary&gt; /// 一个保存有完整搜索结果的列表 /// &lt;/summary&gt; public List&lt;FileInfo&gt; FoundFiles = new List&lt;FileInfo&gt;(); protected override void OnDoWork(DoWorkEventArgs e) &#123; //在此完成异步搜索文件的工作 DoSearchAsync(SearchInfoObj.SearchFile, SearchInfoObj.BeginDirectory, e); base.OnDoWork(e); &#125; /// &lt;summary&gt; /// 完成递归搜索文件的功能 /// &lt;/summary&gt; /// &lt;param name="SearchFile"&gt;&lt;/param&gt; /// &lt;param name="BeginDirectory"&gt;&lt;/param&gt; /// &lt;param name="e"&gt;&lt;/param&gt; void DoSearchAsync(string SearchFile, string BeginDirectory, DoWorkEventArgs e) &#123; if (Directory.Exists(BeginDirectory) == false) throw new DirectoryNotFoundException("文件夹不存在"); DirectoryInfo RootDir = new DirectoryInfo(BeginDirectory); FileInfo[] files = null; DirectoryInfo[] ChildDirs = null; try &#123; //注：有可能发生权限不足的异常，因为某些文件夹不允许检索文件和子文件夹 //获取所有的子文件夹 ChildDirs = RootDir.GetDirectories(); //获取当前文件夹中的所有符合条件的文件 files = RootDir.GetFiles(SearchInfoObj.SearchFile, SearchOption.TopDirectoryOnly); &#125; catch //不处理可能发生的权限异常，继续搜索 &#123; &#125; //如果用户取消了操作 if (this.CancellationPending) &#123; e.Cancel = true;//此结果将会被传送到RunWorkerCompleted事件中 return;//提前结束工作任务 &#125; if (files != null &amp;&amp; files.Length &gt; 0 &amp;&amp; ShowSearchResult != null) &#123; FoundFiles.AddRange(files); //将找到的文件加入到结果集合中 if (ShowSearchResult != null) //外界挂接了要显示中间结果的函数 &#123; SendOrPostCallback UICallback = (result) =&gt; &#123; ShowSearchResult(result as FileInfo[]); &#125;; asyncOperation.Post(UICallback, files); //在UI线程中执行它们 &#125; // ShowSearchResult(files);//调用外界传入的委托，向外界报告本次找到的文件 //激发ProgressChanged事件，外界可显示工作处理情况 this.ReportProgress(0, "在文件夹 “" + RootDir.Name+ " ”中找到了需要的文件，正在处理中..."); &#125; if (ChildDirs != null) //如果没有发生存取权限异常，则此变量不会为null &#123; //对每个子文件夹执行同样的查找过程 //这是通过递归调用实现的 foreach (DirectoryInfo dir in ChildDirs) &#123; DoSearchAsync(SearchFile, dir.FullName, e); &#125; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738namespace MyFileSearcher&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private void btnChooseSearchDirectory_Click(object sender, EventArgs e) &#123; if (folderBrowserDialog1.ShowDialog() == DialogResult.OK) &#123; this.txtBeginDirectory.Text = folderBrowserDialog1.SelectedPath; &#125; &#125; private void btnBeginSearch_Click(object sender, EventArgs e) &#123; if (txtSearchFileName.Text.Trim().Length == 0) &#123; MessageBox.Show("请输入要查找的文件名：", "提示信息", MessageBoxButtons.OK, MessageBoxIcon.Information); txtSearchFileName.Focus(); return; &#125; if (this.txtBeginDirectory.Text.Trim().Length == 0) &#123; MessageBox.Show("请选择查找起始目录：", "提示信息", MessageBoxButtons.OK, MessageBoxIcon.Information); btnChooseSearchDirectory.Focus(); return; &#125; SearchInfo info = new SearchInfo &#123; BeginDirectory = this.txtBeginDirectory.Text.Trim(), SearchFile = txtSearchFileName.Text.Trim() &#125;; frmFileSearcher frm = new frmFileSearcher(info); frm.Show(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119namespace MyFileSearcher&#123; public partial class frmFileSearcher : Form &#123; #region "重载的构造函数" public frmFileSearcher() &#123; InitializeComponent(); &#125; public frmFileSearcher(SearchInfo info) &#123; InitializeComponent(); SearchInfoObj = info; &#125; #endregion #region "变量区" private SearchInfo _SearchInfoObj = null; public SearchInfo SearchInfoObj &#123; get &#123; return _SearchInfoObj; &#125; set &#123; _SearchInfoObj = value; lblInfo.Text = string.Format("正在搜索：&#123;0&#125;，起始目录：&#123;1&#125;", value.SearchFile, value.BeginDirectory); &#125; &#125; /// &lt;summary&gt; /// 文件搜索器 /// &lt;/summary&gt; private FileSearcher searcher = new FileSearcher(); #endregion /// &lt;summary&gt; /// 显示当前已找到的文件 /// &lt;/summary&gt; /// &lt;param name="files"&gt;&lt;/param&gt; private void ShowSearchedFiles(FileInfo[] files) &#123; foreach (FileInfo file in files) lstFiles.Items.Add(file.FullName); &#125; private void btnBeginSearch_Click(object sender, EventArgs e) &#123; lstFiles.Items.Clear(); BeginSearch(); btnCancel.Enabled= true; btnBeginSearch.Enabled = false; &#125; /// &lt;summary&gt; /// 启动搜索 /// &lt;/summary&gt; public void BeginSearch() &#123; //挂接显示函数，此函数将在搜索过程中不断地被fileSearcher组件所调用。 fileSearcher1.ShowSearchResult = this.ShowSearchedFiles; //向fileSearcher组件提供要搜索文件的信息 fileSearcher1.SearchInfoObj = this.SearchInfoObj; //启动搜索 fileSearcher1.RunWorkerAsync(); //启动搜索 &#125; private void fileSearcher1_ProgressChanged(object sender, ProgressChangedEventArgs e) &#123; lblInfo2.Text = e.UserState.ToString(); lblInfo2.Refresh(); &#125; private void fileSearcher1_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e) &#123; if (e.Cancelled == true) lblInfo2.Text = string.Format("用户取消了操作，到目前为止，找到了&#123;0&#125;个文件",fileSearcher1.FoundFiles.Count); else lblInfo2.Text = string.Format("搜索完成，共找到&#123;0&#125;个文件。",fileSearcher1.FoundFiles.Count); btnBeginSearch.Enabled = true; btnCancel.Enabled = false; &#125; private void btnCancel_Click(object sender, EventArgs e) &#123; fileSearcher1.CancelAsync(); btnCancel.Enabled = false; btnBeginSearch.Enabled = true; &#125; private void btnClose_Click(object sender, EventArgs e) &#123; Close(); &#125; private void frmFileSearcher_Load(object sender, EventArgs e) &#123; BeginSearch(); &#125; private void frmFileSearcher_FormClosing(object sender, FormClosingEventArgs e) &#123; if (fileSearcher1.IsBusy) &#123; MessageBox.Show("搜索正在进行中，请先取消搜索任务后再关闭程序","提示信息",MessageBoxButtons.OK,MessageBoxIcon.Stop); e.Cancel = true; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>.NET Framework</category>
        <category>多线程、Socket、异步编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Winform数据绑定技术]]></title>
    <url>%2F2019%2F03%2F04%2FWinform%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[绑定技术，解放“枯燥代码” 数据绑定引例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455namespace WhatIsDataBinding&#123; public partial class frmAutoDataBind : Form &#123; public frmAutoDataBind() &#123; InitializeComponent(); &#125; private BindingSource bindingSource = new BindingSource(); /// &lt;summary&gt; /// 用于从数据库中提取数据 /// &lt;/summary&gt; private ClientsRepository repo = new ClientsRepository(); /// &lt;summary&gt; /// 设置控件的数据绑定 /// &lt;/summary&gt; private void SetBinding() &#123; txtAddress.DataBindings.Clear(); txtClientName.DataBindings.Clear(); txtPostCode.DataBindings.Clear(); txtAddress.DataBindings.Add("Text", bindingSource, "Address",false,DataSourceUpdateMode.OnPropertyChanged); txtClientName.DataBindings.Add("Text", bindingSource, "ClientName", false, DataSourceUpdateMode.OnPropertyChanged); txtPostCode.DataBindings.Add("Text", bindingSource, "PostCode", false, DataSourceUpdateMode.OnPropertyChanged); &#125; /// &lt;summary&gt; /// 将对象序列化为Json字符串，显示在窗体下部的文本框中 /// &lt;/summary&gt; private void ShowDataObjectInfo() &#123; var jsonString = JsonConvert.SerializeObject(bindingSource.Current, Formatting.Indented); txtInfo.Text = jsonString; &#125; private void btnLoadData_Click(object sender, EventArgs e) &#123; bindingSource.DataSource = repo.GetAllClients().First(); SetBinding(); btnShowObjectInfo.Enabled = true; btnModifyObject.Enabled = true; &#125; private void btnModifyObject_Click(object sender, EventArgs e) &#123; bindingSource.DataSource= repo.GetAllClients()[1]; &#125; private void btnShowObjectInfo_Click(object sender, EventArgs e) &#123; ShowDataObjectInfo(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596namespace WhatIsDataBinding&#123; public partial class frmDataBindByHand : Form &#123; public frmDataBindByHand() &#123; InitializeComponent(); &#125; /// &lt;summary&gt; /// 将要被处理的数据对象 /// &lt;/summary&gt; private OrderClient DataObject = null; /// &lt;summary&gt; /// 用于从数据库中提取数据 /// &lt;/summary&gt; private ClientsRepository repo = new ClientsRepository(); /// &lt;summary&gt; /// 从数据库中装入数据，创建OrderClient对象， /// 在窗体上显示OrderClient对象的各个属性值 /// &lt;/summary&gt; private void ShowObjectInForm() &#123; txtAddress.Text = DataObject.Address; txtClientName.Text = DataObject.ClientName; txtPostCode.Text = DataObject.PostCode; &#125; /// &lt;summary&gt; /// 使用窗体上控件的当前值，更新OrderClient对象的属性值 /// &lt;/summary&gt; private void SaveToObject() &#123; DataObject.PostCode = txtPostCode.Text; DataObject.Address = txtAddress.Text; DataObject.ClientName = txtClientName.Text; txtInfo.Text = "己经使用控件的当前值刷新了底层数据对象的属性值"; &#125; /// &lt;summary&gt; /// 将对象序列化为Json字符串，显示在窗体下部的文本框中 /// &lt;/summary&gt; private void ShowDataObjectInfo() &#123; var jsonString = JsonConvert.SerializeObject(DataObject, Formatting.Indented); txtInfo.Text = jsonString; &#125; private void ModifyObjectByCode() &#123; //装入第二条记录，表示程序代码直接修改了底层数据对象 DataObject = repo.GetAllClients()[1]; txtInfo.Text = "装入数据库中的第二条记录以更新底层数据对象"; &#125; /// &lt;summary&gt; /// 激活相应的按钮 /// &lt;/summary&gt; private void EnableButtons() &#123; btnRefresh.Enabled = true; btnSaveToObject.Enabled = true; btnShowObjectInfo.Enabled = true; btnModifyObject.Enabled = true; &#125; private void btnShowInfo_Click(object sender, EventArgs e) &#123; ShowDataObjectInfo(); &#125; private void btnLoadData_Click(object sender, EventArgs e) &#123; DataObject = repo.GetAllClients().First(); txtInfo.Text = "数据库中的第一条记录己经装入"; EnableButtons(); &#125; private void btnRefresh_Click(object sender, EventArgs e) &#123; ShowObjectInForm(); &#125; private void btnSaveToObject_Click(object sender, EventArgs e) &#123; SaveToObject(); &#125; private void btnModifyObject_Click(object sender, EventArgs e) &#123; ModifyObjectByCode(); &#125; &#125;&#125; 什么是数据绑定 数据绑定中的源和目标 实际开发 优势 探索Binding对象绑定示例 Binding对象的重要属性 控件的Bindings属性 Binding对象的职责 以特定的格式显示数据 https://docs.microsoft.com/en-us/dotnet/standard/base-types/formatting-types 对象属性变更通知 123456789101112131415161718192021222324252627282930313233343536373839namespace ExploreBindingObject&#123; /// &lt;summary&gt; /// 一个当作被绑定数据源的普通对象 /// &lt;/summary&gt; public class MySilentClass &#123; public double DoubleValue &#123; get; set; &#125; &#125; /// &lt;summary&gt; /// 一个当作被绑定数据源的对象，支持属性变更通知 /// &lt;/summary&gt; public class MySmartClass:INotifyPropertyChanged &#123; private double _value; public double DoubleValue &#123; get &#123; return _value; &#125; set &#123; _value = value; OnPropertyChanged("DoubleValue"); &#125; &#125; // 定义属性改变事件 public event PropertyChangedEventHandler PropertyChanged; private void OnPropertyChanged(string name) &#123; //多了一次赋值 其实没必要 PropertyChangedEventHandler handler = PropertyChanged; //事件不为空(有挂接方法) if (handler != null) &#123; handler(this, new PropertyChangedEventArgs(name)); &#125; &#125; &#125;&#125; 数据无效 数据无效焦点问题 数据和界面更新的时机选择 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145namespace ExploreBindingObject&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; /// &lt;summary&gt; /// 被绑定的数据对象 /// &lt;/summary&gt; private Object DataObject = null; /// &lt;summary&gt; /// 绑定文本框的Binding对象 /// &lt;/summary&gt; private Binding doubleBind = null; private void btnBindData_Click(object sender, EventArgs e) &#123; SetupBinding(); &#125; /// &lt;summary&gt; /// 建立文本框与数据源对象的数据绑定，设置其各种参数和事件响应方法 /// &lt;/summary&gt; private void SetupBinding() &#123; //清空原有绑定对象 txtDouble.DataBindings.Clear(); //依据复选框的状态，实例化不同的对象作为绑定数据源 if (chkNotifyPropertyChange.Checked) &#123; DataObject = new MySmartClass() &#123; DoubleValue = new Random().NextDouble(), &#125;; &#125; else &#123; DataObject = new MySilentClass() &#123; DoubleValue = new Random().NextDouble() &#125;; &#125; //设定数据绑定对象的相关参数 doubleBind = new Binding("Text", DataObject, "DoubleValue"); doubleBind.FormattingEnabled = true; doubleBind.FormatString = "N2"; doubleBind.ControlUpdateMode = ControlUpdateMode.OnPropertyChanged; doubleBind.DataSourceUpdateMode = DataSourceUpdateMode.OnPropertyChanged; //观察事件的触发顺序 doubleBind.Format += DoubleBind_Format; doubleBind.Parse += DoubleBind_Parse; doubleBind.BindingComplete += DoubleBind_BindingComplete; //设置文本框使用此Binding对象 txtDouble.DataBindings.Add(doubleBind); &#125; /// &lt;summary&gt; /// 在文本框中显示一条信息 /// &lt;/summary&gt; /// &lt;param name="message"&gt;&lt;/param&gt; private void ShowMessage(string message) &#123; rtfInfo.AppendText("\n" + message + "\n"); try &#123; //设定文本框选定的起始点 rtfInfo.SelectionStart = rtfInfo.TextLength; //控件内容滚动到当前位置 rtfInfo.ScrollToCaret(); &#125; catch (Exception) &#123; &#125; &#125; /// &lt;summary&gt; /// 当绑定过程完成时，触发此事件 /// &lt;/summary&gt; /// &lt;param name="sender"&gt;&lt;/param&gt; /// &lt;param name="e"&gt;&lt;/param&gt; private void DoubleBind_BindingComplete(object sender, BindingCompleteEventArgs e) &#123; string message = string.Format(@"在BindingComplete事件中：BindingCompleteContext:&#123;0&#125;, BindingCompleteState:&#123;1&#125;, Cancel:&#123;2&#125;, ErrorText:&#123;3&#125;, Exception:&#123;4&#125;", e.BindingCompleteContext,//绑定操作的方向 e.BindingCompleteState, //绑定操作的状态 e.Cancel, e.ErrorText, e.Exception == null ? "无" : e.Exception.GetType().ToString()); ShowMessage(message); &#125; /// &lt;summary&gt; /// 当解析用户输入的值，准备更新底层数据对象的属性时，触发此事件 /// &lt;/summary&gt; /// &lt;param name="sender"&gt;&lt;/param&gt; /// &lt;param name="e"&gt;&lt;/param&gt; private void DoubleBind_Parse(object sender, ConvertEventArgs e) &#123; string message = string.Format("在Parse事件中：Value:&#123;0&#125;,DesiredType:&#123;1&#125;", e.Value, e.DesiredType); ShowMessage(message); &#125; /// &lt;summary&gt; /// 当从底层数据对象属性中读取值，准备显示到控件上时，触发此事件 /// &lt;/summary&gt; /// &lt;param name="sender"&gt;&lt;/param&gt; /// &lt;param name="e"&gt;&lt;/param&gt; private void DoubleBind_Format(object sender, ConvertEventArgs e) &#123; string message = string.Format("在Format事件中：Value:&#123;0&#125;,DesiredType:&#123;1&#125;", e.Value, e.DesiredType); ShowMessage(message); &#125; private void btnClear_Click(object sender, EventArgs e) &#123; rtfInfo.Clear(); &#125; private void btnModifyObject_Click(object sender, EventArgs e) &#123; double newValue = new Random().NextDouble(); if (chkNotifyPropertyChange.Checked) &#123; (DataObject as MySmartClass).DoubleValue = newValue; &#125; else &#123; (DataObject as MySilentClass).DoubleValue = newValue; //如果对象没有实现INotifyPropertyChanged接口，则需要人工读入数据以刷新显示 //doubleBind.ReadValue(); &#125; &#125; private void chkNotifyPropertyChange_CheckedChanged(object sender, EventArgs e) &#123; SetupBinding(); &#125; &#125;&#125; 可绑定数据源数据源的职责 Winform控件可绑定数据源类型 集合类型的绑定数据源 IEnumerable接口 ICollection接口 Ilist接口 IBindingList接口 Ilist和IBindingList示例 123456789101112131415161718192021222324252627282930313233343536373839namespace UseIBindingList&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); objects = new BindingList&lt;MyClass&gt;(); dataGridView1.DataSource = objects; &#125; private IList&lt;MyClass&gt; objects = null; private void rdoList_CheckedChanged(object sender, EventArgs e) &#123; objects = new List&lt;MyClass&gt;(); dataGridView1.DataSource =objects ; &#125; private void rdoBindingList_CheckedChanged(object sender, EventArgs e) &#123; objects = new BindingList&lt;MyClass&gt;(); dataGridView1.DataSource = objects; &#125; private int counter=0; private void btnAdd_Click(object sender, EventArgs e) &#123; counter++; objects.Add(new MyClass &#123; ID = counter, info = "A" + counter.ToString() &#125;); &#125; private void btnDelete_Click(object sender, EventArgs e) &#123; if(dataGridView1.CurrentRow!=null) objects.RemoveAt(dataGridView1.CurrentRow.Index); &#125; &#125;&#125; 12345678910111213141516namespace UseIBindingList&#123; class MyClass &#123; public int ID &#123; get; set; &#125; public string info &#123; get; set; &#125; &#125;&#125; IBindingListView接口 绑定到对象集合示例DateGridView绑定数据集合 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283namespace WindowsFormsApplication1&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); FillData(); dataGridView1.DataSource = clients; &#125; private BindingList&lt;OrderClient&gt; clients = new BindingList&lt;OrderClient&gt;(); /// &lt;summary&gt; /// 填充数据 /// &lt;/summary&gt; private void FillData() &#123; clients.Add(new OrderClient &#123; ClientName = "陆宁", Address = "上海延安西路1228弄2号嘉利大厦31楼J座", PostCode = "200052" &#125;); clients.Add(new OrderClient &#123; ClientName = "王建国", Address = "山西省大同市新开北路81号大齿集团传动箱分公司", PostCode = "037006" &#125;); clients.Add(new OrderClient &#123; ClientName = "黄忠平", Address = "江苏无锡市新区科技园四区五楼中顺生物公司", PostCode = "214028" &#125;); &#125; private void btnDelete_Click(object sender, EventArgs e) &#123; int index = dataGridView1.CurrentRow.Index; if (index == -1) return; clients.RemoveAt(index); &#125; private void btnAdd_Click(object sender, EventArgs e) &#123; //主窗体new一个新对象，注入到“新建记录”窗体中 frmAddOrModify frm = new frmAddOrModify(new OrderClient(), false); if (frm.ShowDialog() == DialogResult.OK) &#123; //从“新建记录”窗体的公有属性中取出属性己更新的对象，并将其加入到数据源集合中 clients.Add(frm.OrderClientObj); &#125; &#125; private void btnModify_Click(object sender, EventArgs e) &#123; int index = dataGridView1.CurrentRow.Index; if (index == -1) return; //创建一个待编辑数据对象的副本 var modifyObject = OrderClientHelper.CloneOrderClient(clients[index]); //注入到“修改记录”窗体中 frmAddOrModify frm = new frmAddOrModify(modifyObject, true); if (frm.ShowDialog() == DialogResult.OK) &#123; //更新原始数据对象属性值 OrderClientHelper.Populate(frm.OrderClientObj, clients[index]); if (frm.OrderClientObj is INotifyPropertyChanged == false) &#123; //如果OrderClient没有实现INotifyPropertyChanged接口， //而DataGridView又是直接绑定到BindingList集合的 //当对象被修改时，只能通过重新绑定实现刷新。 dataGridView1.DataSource = null; dataGridView1.DataSource = clients; &#125; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748namespace WindowsFormsApplication1&#123; public partial class frmAddOrModify : Form &#123; public frmAddOrModify(OrderClient client, bool IsModify) &#123; InitializeComponent(); //将注入对象的引用保存于私有字段中 _client = client; //设定控件的数据绑定 txtClientName.DataBindings.Add("Text", client, "ClientName"); txtAddress.DataBindings.Add("Text", client, "Address"); txtPostCode.DataBindings.Add("Text", client, "PostCode"); if (!IsModify) &#123; this.Text = "新增记录"; &#125; else &#123; this.Text = "修改记录"; &#125; &#125; private OrderClient _client; public OrderClient OrderClientObj &#123; get &#123; return _client; &#125; &#125; private void btnOK_Click(object sender, EventArgs e) &#123; this.DialogResult = DialogResult.OK; Close(); &#125; private void btnCancel_Click(object sender, EventArgs e) &#123; this.DialogResult = DialogResult.Cancel; Close(); &#125; &#125;&#125; 窗体重用 新增的两种实现 数据绑定自动更新数据对象 “新增记录实现” 绑定机制的麻烦点 解决方式 修改记录实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344namespace WindowsFormsApplication1&#123; /// &lt;summary&gt; /// 此类封装了一些针对OrderClient对象的辅助方法 /// &lt;/summary&gt; public class OrderClientHelper &#123; /// &lt;summary&gt; /// 克隆一个新OrderClient对象 /// &lt;/summary&gt; /// &lt;param name="client"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static OrderClient CloneOrderClient(OrderClient client) &#123; if (client == null) &#123; return null; &#125; var clone = new OrderClient() &#123; ClientName = client.ClientName, Address = client.Address, PostCode = client.PostCode &#125;; return clone; &#125; /// &lt;summary&gt; /// 使用from对象的属性值更新to对象的相应属性值 /// &lt;/summary&gt; /// &lt;param name="from"&gt;&lt;/param&gt; /// &lt;param name="to"&gt;&lt;/param&gt; public static void Populate(OrderClient from,OrderClient to) &#123; if(from!=null &amp;&amp; to != null) &#123; to.Address = from.Address; to.ClientName = from.ClientName; to.PostCode = from.PostCode; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465namespace WindowsFormsApplication1&#123; //public class OrderClient //&#123; // public string ClientName &#123; get; set; &#125; // public string PostCode &#123; get; set; &#125; // public string Address &#123; get; set; &#125; //&#125; /// &lt;summary&gt; /// 使用属性变更事件通知数据绑定控件实现刷新 /// &lt;/summary&gt; public class OrderClient : INotifyPropertyChanged &#123; public event PropertyChangedEventHandler PropertyChanged; private void FirePropertyChangedEvent(string PropertyName) &#123; if (PropertyChanged != null) PropertyChanged(this, new PropertyChangedEventArgs(PropertyName)); &#125; private string _clientName; public string ClientName &#123; get &#123; return _clientName; &#125; set &#123; _clientName = value; FirePropertyChangedEvent("ClientName"); &#125; &#125; private string _postcode; public string PostCode &#123; get &#123; return _postcode; &#125; set &#123; _postcode = value; FirePropertyChangedEvent("PostCode"); &#125; &#125; private string _address; public string Address &#123; get &#123; return _address; &#125; set &#123; _address = value; FirePropertyChangedEvent("Address"); &#125; &#125; &#125;&#125; 小结 常用数据绑定控件IBindableComponent接口 绑定控件分类 简单数据绑定控件 复杂数据绑定控件 ComboBox的使用 12345678910111213141516171819202122232425namespace UseDataBoundControl&#123; public partial class frmComboBox : Form &#123; public frmComboBox() &#123; InitializeComponent(); ComboBoxBinding(); &#125; private void ComboBoxBinding() &#123; comboBox1.DisplayMember = "Name"; comboBox1.ValueMember = "Capital"; comboBox1.DataSource = ProvinceRepository.GetProvinces(); &#125; private void comboBox1_SelectedIndexChanged(object sender, EventArgs e) &#123; lblCapital.Text = comboBox1.SelectedValue.ToString(); string json = JsonConvert.SerializeObject(comboBox1.SelectedItem,Formatting.Indented); //SelectedItem 引用当前的数据源对象 txtInfo.Text = json; &#125; &#125;&#125; ListBox 1234567891011121314151617181920212223242526272829303132333435363738394041424344namespace UseDataBoundControl&#123; public partial class frmListBox : Form &#123; public frmListBox() &#123; InitializeComponent(); &#125; private ClientsRepository repo = new ClientsRepository(); private BindingList&lt;OrderClient&gt; clients = null; private void SetupBind() &#123; lstClients.DisplayMember = "ClientName"; lstClients.ValueMember = "ClientID"; lstClients.DataSource = clients; if (txtAddress.DataBindings.Count &gt; 0) &#123; txtAddress.DataBindings.Clear(); &#125; txtAddress.DataBindings.Add("Text", clients, "Address"); if (txtPostCode.DataBindings.Count &gt; 0) &#123; txtPostCode.DataBindings.Clear(); &#125; txtPostCode.DataBindings.Add("Text", clients, "PostCode"); &#125; private void btnFetchData_Click(object sender, EventArgs e) &#123; clients = repo.GetAllClients(); SetupBind(); &#125; private void lstClients_SelectedIndexChanged(object sender, EventArgs e) &#123; lblClientID.Text = lstClients.SelectedValue.ToString(); string json = JsonConvert.SerializeObject(lstClients.SelectedItem,Formatting.Indented); txtInfo.Text = json; &#125; &#125;&#125; BindingSource组件开发实例地位 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197namespace UseBindingSource&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); repo = new ClientsRepository(); dataGridViewClients.AutoGenerateColumns = false; cboFindWhat.SelectedIndex = 0; FillDataAndSetBindingSource(); &#125; private ClientsRepository repo = null; private BindingList&lt;OrderClient&gt; clients = null; /// &lt;summary&gt; /// 从数据库中提取所有数据，并且绑定显示于DataGridView中 /// &lt;/summary&gt; private void FillDataAndSetBindingSource() &#123; try &#123; //响应BindingSource的相关事件 bindingSourceClients.AddingNew += bindingSourceClients_AddingNew; bindingSourceClients.BindingComplete += bindingSourceClients_BindingComplete; bindingSourceClients.CurrentChanged += bindingSourceClients_CurrentChanged; bindingSourceClients.CurrentItemChanged += bindingSourceClients_CurrentItemChanged; bindingSourceClients.ListChanged += bindingSourceClients_ListChanged; bindingSourceClients.PositionChanged += bindingSourceClients_PositionChanged; //从数据库中提取数据，放到BindingList&lt;T&gt;集合中 clients = repo.GetAllClients(); //将其关联上BindingSource组件 bindingSourceClients.DataSource = clients; //设定DataGridView的数据源引用BindingSource dataGridViewClients.DataSource = bindingSourceClients; lblInfo.Text = string.Format("装入记录&#123;0&#125;条", clients.Count); &#125; catch (Exception ex) &#123; lblInfo.Text = ex.Message; &#125; &#125; private void bindingSourceClients_CurrentChanged(object sender, EventArgs e) &#123; Console.WriteLine("\nBindingSource1_CurrentChanged"); &#125; private void bindingSourceClients_PositionChanged(object sender, EventArgs e) &#123; Console.WriteLine("\nBindingSource1_PositionChanged"); lblInfo.Text = string.Format("第&#123;0&#125;条/共&#123;1&#125;条", bindingSourceClients.Position + 1, bindingSourceClients.Count); &#125; private void bindingSourceClients_ListChanged(object sender, ListChangedEventArgs e) &#123; Console.WriteLine("\nBindingSource1_ListChanged,ListChangedType:&#123;0&#125;,NewIndex:&#123;1&#125;,OldIndex:&#123;2&#125;",e.ListChangedType,e.NewIndex,e.OldIndex); &#125; private void bindingSourceClients_CurrentItemChanged(object sender, EventArgs e) &#123; Console.WriteLine("\nBindingSource1_CurrentItemChanged"); &#125; private void bindingSourceClients_BindingComplete(object sender, BindingCompleteEventArgs e) &#123; Console.WriteLine("\nBindingSource1_BindingComplete,BindingCompleteState:&#123;0&#125;,Cancel:&#123;1&#125;,Exception:&#123;2&#125;,ErrorText:&#123;3&#125;", e.BindingCompleteState,e.Cancel,e.Exception,e.ErrorText); &#125; private void bindingSourceClients_AddingNew(object sender, AddingNewEventArgs e) &#123; Console.WriteLine("\nBindingSource1_AddingNew,&#123;0&#125;",e.NewObject); &#125; private void btnFirst_Click(object sender, EventArgs e) &#123; bindingSourceClients.MoveFirst(); &#125; private void btnPrev_Click(object sender, EventArgs e) &#123; bindingSourceClients.MovePrevious(); &#125; private void btnNext_Click(object sender, EventArgs e) &#123; bindingSourceClients.MoveNext(); &#125; private void btnLast_Click(object sender, EventArgs e) &#123; bindingSourceClients.MoveLast(); &#125; private void btnAdd_Click(object sender, EventArgs e) &#123; frmAddOrModify frm = new frmAddOrModify(new OrderClient(), false); if (frm.ShowDialog() == DialogResult.OK) &#123; bindingSourceClients.Add(frm.OrderClientObj); &#125;; &#125; private void btnModify_Click(object sender, EventArgs e) &#123; var modifyObj = OrderClientHelper.CloneOrderClient(bindingSourceClients.Current as OrderClient); frmAddOrModify frm = new frmAddOrModify(modifyObj, true); if (frm.ShowDialog() == DialogResult.OK) &#123; OrderClientHelper.Populate(frm.OrderClientObj, bindingSourceClients.Current as OrderClient); //刷新显示 bindingSourceClients.ResetCurrentItem(); &#125; &#125; private void btnDelete_Click(object sender, EventArgs e) &#123; try &#123; OrderClient client = bindingSourceClients.Current as OrderClient; if (client != null) &#123; repo.Delete(client.ClientID); &#125; bindingSourceClients.RemoveCurrent(); &#125; catch (Exception ex) &#123; lblInfo.Text = ex.Message; &#125; &#125; private void bindingSource1_CurrentChanged(object sender, EventArgs e) &#123; Console.WriteLine("\nBindingSource1_PositionChanged"); &#125; private void txtUserInput_TextChanged(object sender, EventArgs e) &#123; FilterData(); &#125; private void FilterData() &#123; if (clients == null) &#123; return; &#125; //获取用户输入 string userinput = txtUserInput.Text.Trim(); BindingList&lt;OrderClient&gt; result = null; switch (cboFindWhat.SelectedIndex) &#123; case 0: //按ClientName过滤数据 result =new BindingList&lt;OrderClient&gt;( clients.Where(client =&gt; client.ClientName.Contains(userinput)).ToList()); break; case 1: //按Address过滤数据 result = new BindingList&lt;OrderClient&gt;( clients.Where(client =&gt; client.Address.Contains(userinput)).ToList()); break; case 2: //按PostCode过滤数据 result = new BindingList&lt;OrderClient&gt;( clients.Where(client =&gt; client.PostCode.Contains(userinput)).ToList()); break; default: result = clients; break; &#125; bindingSourceClients.DataSource = result; &#125; private void cboFindWhat_SelectedIndexChanged(object sender, EventArgs e) &#123; FilterData(); &#125; &#125;&#125; BindingSource的代码模板 DataGridView 浏览状态 设置列宽自动调整 设置中文列名 数据导航的实现 BindingSource的各种事件 ErrorProvider组件 数据验证 通知所有控件验证 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139namespace UseBindingSource&#123; public partial class frmAddOrModify : Form &#123; public frmAddOrModify(OrderClient client, bool IsModify) &#123; InitializeComponent(); _client = client; SetBinding(); if (!IsModify) &#123; this.Text = "新增记录"; &#125; else &#123; this.Text = "修改记录"; &#125; _isModify = IsModify; &#125; private OrderClient _client = null; public OrderClient OrderClientObj &#123; get &#123; return _client; &#125; &#125; private bool _isModify = false; private bool CanClose = false; /// &lt;summary&gt; /// 给文本框控件设置数据绑定 /// &lt;/summary&gt; private void SetBinding() &#123; txtClientName.DataBindings.Add("Text", _client, "ClientName"); txtAddress.DataBindings.Add("Text", _client, "Address"); txtPostCode.DataBindings.Add("Text", _client, "PostCode"); &#125; private void btnOK_Click(object sender, EventArgs e) &#123; if (this.ValidateChildren() == false) &#123; MessageBox.Show("你输入了无效的数据,请更正……"); return; &#125; CanClose = true; //保存到数据库中 ClientsRepository repo = new ClientsRepository(); try &#123; if (_isModify) &#123; repo.Modify(_client); &#125; else &#123; repo.AddNew(_client); &#125; this.DialogResult = DialogResult.OK; Close(); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); &#125; &#125; private void btnCancel_Click(object sender, EventArgs e) &#123; CanClose = true; Close(); &#125; private void frmAddOrModify_FormClosing(object sender, FormClosingEventArgs e) &#123; //如果不是点击“取消”或“确定”按钮，不允许用户关闭窗体 if (CanClose == false) e.Cancel = true; &#125; private void txtClientName_Validating(object sender, CancelEventArgs e) &#123; if (string.IsNullOrEmpty(txtClientName.Text)) &#123; errProviderForClientName.SetError(txtClientName, "姓名不能为空"); e.Cancel = true; &#125; else &#123; errProviderForClientName.SetError(txtClientName, null); &#125; &#125; private void txtPostCode_Validating(object sender, CancelEventArgs e) &#123; //如果用户没有按“取消”按钮，则进行数据验证 if (CanClose == false) &#123; //使用正则表达式验证邮编 Regex rgx = new Regex(@"^\d&#123;6&#125;$"); if (rgx.Match(txtPostCode.Text).Success == false) &#123; //显示出错信息 errProviderForPostCode.SetError(txtPostCode, "邮编为6位数字"); e.Cancel = true; //未通过验证 &#125; else &#123; //通过数据验证，取消出错信息的显示 errProviderForPostCode.SetError(txtPostCode, null); &#125; &#125; &#125; private void txtAddress_Validating(object sender, CancelEventArgs e) &#123; if (CanClose == false) &#123; if (string.IsNullOrEmpty(txtAddress.Text)) &#123; errProvideAddressStr.SetError(txtAddress, "地址不能为空"); e.Cancel = true; &#125; else &#123; errProvideAddressStr.SetError(txtAddress, null); &#125; &#125; &#125; &#125;&#125; 数据验证带来的麻烦 数据的过滤 分页浏览数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788namespace BrowseByPage&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); FillData(); &#125; //每页展示数据条数 private const int PageSize = 10; //有多少页 private int PageCount = 0; //当前页 private int CurrentPage = 1; ClientsRepository repo = null; BindingList&lt;OrderClient&gt; clients = null; private void FillData() &#123; repo = new ClientsRepository(); clients = repo.GetAllClients(); int count = clients.Count; PageCount = count % PageSize == 0 ? count / PageSize : count / PageSize + 1; txtPageIndex.Text = PageCount.ToString(); ShowPage(CurrentPage); dataGridView1.DataSource = bindingSource1; &#125; /// &lt;summary&gt; /// 显示指定页的记录 /// &lt;/summary&gt; /// &lt;param name="PageIndex"&gt;&lt;/param&gt; private void ShowPage(int PageIndex) &#123; if (PageIndex &lt;= 0 || PageIndex &gt; PageCount) return; var result =new BindingList&lt;OrderClient&gt;(clients.Skip((PageIndex - 1) * PageSize) .Take(PageSize).ToList()); bindingSource1.DataSource = result; lblInfo.Text = string.Format("第&#123;0&#125;页/共&#123;1&#125;页", CurrentPage, PageCount); &#125; private void btnFirstPage_Click(object sender, EventArgs e) &#123; CurrentPage = 1; ShowPage(1); &#125; private void btnPrevPage_Click(object sender, EventArgs e) &#123; if (CurrentPage &gt; 1) CurrentPage--; else return; ShowPage(CurrentPage); &#125; private void btnNextPage_Click(object sender, EventArgs e) &#123; if (CurrentPage == PageCount) return; CurrentPage++; ShowPage(CurrentPage); &#125; private void btnLastPage_Click(object sender, EventArgs e) &#123; CurrentPage = PageCount; ShowPage(PageCount); &#125; private void btnJump_Click(object sender, EventArgs e) &#123; int JumpToPage; if (int.TryParse(txtPageIndex.Text, out JumpToPage)) &#123; CurrentPage = JumpToPage; ShowPage(CurrentPage); &#125; &#125; &#125;&#125; 一对多关联数据浏览 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071namespace BookAndBookReview&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); FetchBooks(); lstBooks.DataSource = bindingSourceBook; lstBooks.DisplayMember = "BookName"; txtAuthor.DataBindings.Add("Text", bindingSourceBook, "Author"); txtPrice.DataBindings.Add("Text", bindingSourceBook, "Price"); dgvBookReview.AutoGenerateColumns = false; dgvBookReview.DataSource = bindingSourceBookReview; &#125; private BookRepository bookRepo = new BookRepository(); private BookCategoryRepository categoryRepo = new BookCategoryRepository(); private List&lt;Book&gt; books = null; private void FetchBooks() &#123; comboBoxCategory.DisplayMember = "Category"; comboBoxCategory.ValueMember = "CategoryId"; var categories = categoryRepo.GetAllCategories(); categories.Insert(0, new BookCategory() &#123; CategoryId = 0, Category = "所有种类" &#125;); comboBoxCategory.DataSource = categories; &#125; private void bindingSourceBook_CurrentChanged(object sender, EventArgs e) &#123; Book currentBook = bindingSourceBook.Current as Book; if (currentBook != null) bindingSourceBookReview.DataSource = currentBook.BookReviews; &#125; private void comboBoxCategory_SelectedIndexChanged(object sender, EventArgs e) &#123; if (comboBoxCategory.SelectedIndex == 0) &#123; books = bookRepo.GetAllBooksWithItsBookReview(); bindingSourceBook.DataSource = books; &#125; else &#123; bindingSourceBook.DataSource = categoryRepo.GetBooksByCategory(comboBoxCategory.SelectedIndex); &#125; Book currentBook = bindingSourceBook.Current as Book; if (currentBook != null) &#123; bindingSourceBookReview.DataSource = currentBook.BookReviews; &#125; else &#123; bindingSourceBookReview.DataSource = null; &#125; &#125; &#125;&#125; 学习指南]]></content>
      <categories>
        <category>.NET Framework</category>
        <category>基础入门到进阶-金旭亮</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>数据库</tag>
        <tag>SQLServer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EntityFramWork入门]]></title>
    <url>%2F2019%2F03%2F02%2FEntityFramWork%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[微软官方推荐框架 Entity Framework开发技术基础Entity Framework与ORM 实际开发中的困境 为什么学EF 在开发中使用Entity Framework 两种连接字符串 Database First开发模式 存在意义 using关键字与IDisposable 接口 Entity Framework如何从数据库中提取数据 SQL命令发送时机 EF对象模型与数据库间的映射 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/// &lt;summary&gt; /// 使用using关键字让EF自动关闭数据库连接 /// &lt;/summary&gt; private static void FetchDataUseUsingKeyWord() &#123; //using结构所监控的对象，必须实现IDisposable接口 using (var context = new MyDBContext()) &#123; //使用LINQ to Entities查询数据 var query = from client in context.OrderClients select client; //循环遍历结果集 foreach (var client in query) &#123; Console.WriteLine("&#123;0&#125;:&#123;1&#125;", client.ClientName, client.Address); &#125; &#125; &#125; /// &lt;summary&gt; /// 展示EF如何与数据库交互的 /// &lt;/summary&gt; private static void HowLINQIsWorking() &#123; //using结构所监控的对象，必须实现IDisposable接口 using (var context = new MyDBContext()) &#123; //指示要记录EF所进行的所有数据库相关活动 //Log属性是一个Action&lt;String&gt;委托 //我们可以把任意一个符合此委托的方法传给它, //从而以自己的方式处理这些数据库活动记录 //本例中使用Console.WriteLine方法, //表明希望在控制台窗口中输出这些信息 context.Database.Log = Console.WriteLine; //使用LINQ to Entities查询数据 var query = from client in context.OrderClients select client; //循环遍历结果集 foreach (var client in query) &#123; Console.WriteLine("&#123;0&#125;:&#123;1&#125;", client.ClientName, client.Address); &#125; &#125; &#125; &#125; class MyClass : IDisposable &#123; public void printMessage() &#123; Console.WriteLine("MyClass对象的HashCode=&#123;0&#125;", this.GetHashCode()); &#125; public void Dispose() &#123; Console.WriteLine("MyClass Object is Disposed."); &#125; &#125; Entity Framework查询数据查询主要方式 单条记录查询 注意点 C#对象之间的关联 DB表与EF数据实体间的关联 EF中的一对一关联 真的需要一对一关联 EF中的一对多关联 外键关联和独立关联 实践须知 EF中的多对多关联 关联数据的加载(延迟加载) virtual关键字的作用 结论和注意点 Eager Loading（预装载） 问题点 开发建议 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879namespace QueryData&#123; class Program &#123; static void Main(string[] args) &#123; //FindSingle(); TestFindMethod(); Console.ReadKey(); &#125; /// &lt;summary&gt; /// 混用LINQ和扩展方法查找单条记录 /// &lt;/summary&gt; static void FindSingle() &#123; using (var context = new MyDBContext()) &#123; //查找ID=10的客户信息，找不到,返回null var client = (from c in context.OrderClients where c.ClientID==-10 select c).SingleOrDefault(); if (client == null) &#123; Console.WriteLine("没有找到"); &#125; else &#123; Console.WriteLine("&#123;0&#125; 住在:&#123;1&#125;",client.ClientName,client.Address); &#125; &#125; &#125; /// &lt;summary&gt; /// 展示Find方法的特点 /// &lt;/summary&gt; static void TestFindMethod() &#123; using (var context = new MyDBContext()) &#123; context.Database.Log = Console.WriteLine; //提取所有ClientID大于10的客户记录 var allClient = from client in context.OrderClients where client.ClientID&gt;10 select client; //将导致一条SQL命令的发送，提取记录数 Console.WriteLine("共有&#123;0&#125;条记录",allClient.Count()); //循环访问记录，将EF发送Select命令装载并自动跟踪相关记录 foreach (var item in allClient) &#123; Console.WriteLine("ClientID：&#123;0&#125;, ClientName:&#123;1&#125;",item.ClientID,item.ClientName); &#125; //ClientID=30的记录在内存中，因此，Find方法不会导致再次发送SQL命令 var c = context.OrderClients.Find(30); if (c == null) &#123; Console.WriteLine("没有找到"); &#125; else &#123; Console.WriteLine("&#123;0&#125;(ClientID=&#123;1&#125;) 住在:&#123;2&#125;", c.ClientName,c.ClientID, c.Address); &#125; //EF发现ClientID=2的记录不在内存中， //因此，Find方法会发送SQL命令去原始数据库中查询 c = context.OrderClients.Find(2); if (c == null) &#123; Console.WriteLine("没有找到"); &#125; else &#123; Console.WriteLine("&#123;0&#125;(ClientID=&#123;1&#125;) 住在:&#123;2&#125;", c.ClientName, c.ClientID, c.Address); &#125; &#125; &#125; &#125;&#125; Entity Framework修改数据CURD基础什么是CRUD EF如何实现CRUD DB First 开发模式的致命弱点 修改数据实体类 ADD功能 Modify功能 Delete功能 数据更新原理两个核心类型职责 DBContext利用Database属性直接发送sql命令到数据库Entry方法传入一个实体对象，获取关联的装态对象 DBSet 数据实体状态 EF数据更新原理 实体对象状态确定 1234567891011121314151617181920212223242526272829303132[TestMethod]public void TestEntityState()&#123; using (var context = new MyDBContext()) &#123; //获取最后一条记录 //由于EF不支持Last()查询，因此，先对其进行降序排列，然后取第一条记录 var client = (from c in context.OrderClients orderby c.ClientID descending select c).FirstOrDefault(); if (client != null) &#123; DbEntityEntry&lt;OrderClient&gt; clientEntry = context.Entry&lt;OrderClient&gt;(client); Console.WriteLine("\n修改属性前：状态=&#123;0&#125;", clientEntry.State); Assert.IsTrue(clientEntry.State == EntityState.Unchanged); OrderClientHelper.PrintEntityPropertyValue(clientEntry, "PostCode"); //把邮编当成数字，加1，作为修改后的新值进行测试 int newPostCode = Int32.Parse(client.PostCode) + 1; client.PostCode = newPostCode.ToString(); //Savechanges()方法 其实会调用这个 context.ChangeTracker.DetectChanges(); Console.WriteLine("\n修改属性后：状态=&#123;0&#125;", clientEntry.State); Assert.IsTrue(clientEntry.State == EntityState.Modified); OrderClientHelper.PrintEntityPropertyValue(clientEntry, "PostCode"); int result = context.SaveChanges(); Assert.IsTrue(result == 1); Console.WriteLine("\n保存到数据库后：状态=&#123;0&#125;",clientEntry.State); OrderClientHelper.PrintEntityPropertyValue(clientEntry, "PostCode"); &#125; &#125;&#125; SQL命令的生成 禁用状态跟踪-只读数据 AsNotraking()的影响 一对多关联对象的CURD 数据库设计规范 创建Create 123456789101112131415161718192021222324252627282930313233343536373839404142434445#region "Add"/// &lt;summary&gt;/// 在内存中创建10本书，每本书10个书评，保存到数据库中/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;[TestMethod]public void TestAddBooks()&#123; using (var context = new MyDBContext()) &#123; List&lt;Book&gt; books = OneToManyHelper.CreateBooks(10, 10); context.Books.AddRange(books); int result = context.SaveChanges(); Assert.IsTrue(result &gt; 0); &#125;&#125;/// &lt;summary&gt;/// 给现成的书添加书评/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;[TestMethod]public void TestAddBookReviewToBooks()&#123; using (var context = new MyDBContext()) &#123; Book firstBook = context.Books.FirstOrDefault(); int reviewCount = firstBook.BookReviews.Count; BookReview review = OneToManyHelper.CreateBookReview(firstBook); int result = context.SaveChanges(); Assert.IsTrue(result &gt; 0); //重新加载图书 Book firstBookFromDB = context.Books.FirstOrDefault(); //书评数加一 Assert.IsTrue(firstBookFromDB.BookReviews.Count == reviewCount + 1); //应该能找得到新加的书评 BookReview newReview = firstBookFromDB.BookReviews.First(br =&gt; br.BookReviewId == review.BookReviewId); Assert.IsNotNull(newReview); &#125;&#125;#endregion 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475namespace CRUDTest.OneToMany&#123; public class OneToManyHelper &#123; private static Random ran = new Random(); public static Book CreateBook() &#123; Book book = new Book() &#123; BookName="Book"+ran.Next(1,10000) &#125;; return book; &#125; //创建指定数目的图书，每本书包容reviewCount个书评 public static List&lt;Book&gt; CreateBooks(int bookCount,int reviewCount) &#123; List&lt;Book&gt; books = new List&lt;Book&gt;(); Book book = null; for (int i = 0; i &lt;= bookCount; i++) &#123; book = CreateBook(); for (int j = 0; j &lt; reviewCount;j++) CreateBookReview(book); books.Add(book); &#125; return books; &#125; /// &lt;summary&gt; /// 如果book不为null，则创建一个BookReview并将其插入到Book的书评集合中 /// 否则，创建独立的BookReview /// &lt;/summary&gt; /// &lt;param name="book"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static BookReview CreateBookReview(Book book = null) &#123; BookReview review = new BookReview(); review.ReaderName = "读者" + ran.Next(1, 1000); if (book != null) &#123; //设置导航属性 review.Book = book; //设置外键关联 review.BookId = book.BookId; review.Review = book.BookName + "的书评" + ran.Next(1, 1000); //将自己追加到BookReivews集合中 book.BookReviews.Add(review); &#125; else &#123; review.Review = "书评" + ran.Next(1, 1000); &#125; return review; &#125; /// &lt;summary&gt; /// 显示一条书评的信息 /// &lt;/summary&gt; /// &lt;param name="review"&gt;&lt;/param&gt; public static void ShowBookReivew(BookReview review) &#123; if (review != null) &#123; Console.WriteLine("BookReviewId:&#123;0&#125; ReaderName:&#123;1&#125; Review:&#123;2&#125;,属于书：&#123;3&#125;", review.BookReviewId, review.ReaderName, review.Review, review.BookId); &#125; &#125; &#125;&#125; 删除Delete 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#region "Delete"//删除整本书[TestMethod]public void TestDeleteBook()&#123; using (var context = new MyDBContext()) &#123; Book firstBook = context.Books.FirstOrDefault(); if (firstBook != null) &#123; context.Books.Remove(firstBook); int result = context.SaveChanges(); Assert.IsTrue(result &gt; 0); //确认书的记录己经被删除 Book bookFromDB = context.Books.FirstOrDefault(b =&gt; b.BookId == firstBook.BookId); Assert.IsNull(bookFromDB); //确认相关书评己经被删除 var query = from review in context.BookReviews where review.BookId == firstBook.BookId select review; Assert.IsTrue(query.Count() == 0); &#125; &#125;&#125;//删除第一本书的第一个书评[TestMethod]public void TestDeleteFirstBookFirstBookReview()&#123; using (var context = new MyDBContext()) &#123; int reviewCount = 0; Book firstBook = context.Books.Include("BookReviews") .FirstOrDefault(); if (firstBook != null &amp;&amp; firstBook.BookReviews.Count &gt; 0) &#123; //删除第一条书评 BookReview firstBookReview = firstBook.BookReviews.FirstOrDefault(); reviewCount = firstBook.BookReviews.Count; //从主对象的集合属性中移除（可选） firstBook.BookReviews.Remove(firstBookReview); //从DbSet中移除 context.BookReviews.Remove(firstBookReview); int result = context.SaveChanges(); Assert.IsTrue(result ==1); //重新提取记录 Book bookFromDB = context.Books.Include("BookReviews").FirstOrDefault(b =&gt; b.BookId == firstBook.BookId); Assert.IsTrue(bookFromDB.BookReviews.Count() == reviewCount - 1); //确认相关书评己经被删除 var query = from review in context.BookReviews where review.BookReviewId == firstBookReview.BookReviewId select review; Assert.IsTrue(query.Count() == 0); &#125; &#125;&#125;#endregion Update(注意子对象搬家) 1234567891011121314151617181920212223242526272829303132333435#region "Update"//更新单个图书信息(略）//更新单个书评信息（略）//将第一本书的第一个书评移动到第二本书[TestMethod]public void TestBookReviewMove()&#123; using (var context = new MyDBContext()) &#123; //找到第一本和第二本书，把第一本书的第一条书评移给第二本书 Book firstBook = context.Books.Include("BookReviews").FirstOrDefault(); Book secondBook = context.Books.Include("BookReviews").ToList().ElementAt(1); if (firstBook != null &amp;&amp; firstBook.BookReviews.Count &gt; 0) &#123; BookReview bookReview = firstBook.BookReviews.ElementAt(0); OneToManyHelper.ShowBookReivew(bookReview); //先从原对象集合中移除 firstBook.BookReviews.Remove(bookReview); //再追加到新对象的集合中 secondBook.BookReviews.Add(bookReview); int result = context.SaveChanges(); Assert.IsTrue(result &gt; 0); //重新提取书评 BookReview reviewFromDB = context.BookReviews.FirstOrDefault(r =&gt; r.BookReviewId == bookReview.BookReviewId); Assert.IsTrue(reviewFromDB.BookId == secondBook.BookId); OneToManyHelper.ShowBookReivew(reviewFromDB); &#125; &#125;&#125;#endregion 插入多层组合对象 123456789101112131415161718192021222324252627282930313233namespace CRUDTest.MultiLevelEmbed&#123; [TestClass] public class MultiLevelEmbedTest &#123; [TestMethod] public void TestInsert() &#123; using (var context = new MyDBContext()) &#123; //创建一个容器对象 MyClassContainer container = MultiLevelEmbedTestHelper.CreateMyClassContainer(); MyClass obj = null; //创建5个MyClass对象，每个对象有5个MyClassChild对象 for (int i = 0; i &lt; 5; i++) &#123; obj = MultiLevelEmbedTestHelper.CreateMyClass(container); for (int j = 0; j &lt; 5; j++) &#123; MultiLevelEmbedTestHelper.CreateMyClassChild(obj); &#125; &#125; //仅需加入最顶层的容器 context.MyClassContainers.Add(container); int result = context.SaveChanges(); Assert.IsTrue(result&gt;0); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647namespace CRUDTest.MultiLevelEmbed&#123; public class MultiLevelEmbedTestHelper &#123; private static Random ran = new Random(); public static MyClassContainer CreateMyClassContainer() &#123; return new MyClassContainer() &#123; Information = "MyClassContainer" + ran.Next(1, 10000) &#125;; &#125; public static MyClass CreateMyClass(MyClassContainer container=null) &#123; MyClass obj = new MyClass(); if (container != null) &#123; obj.MyClassContainerID = container.MyClassContainerID; obj.Information = container.Information + "的MyClass子对象" + ran.Next(1, 1000); container.MyClasses.Add(obj); &#125; else &#123; obj.Information = "MyClass对象" + ran.Next(1, 1000); &#125; return obj; &#125; public static MyClassChild CreateMyClassChild(MyClass parent) &#123; MyClassChild child = new MyClassChild(); if (parent != null) &#123; child.MyClassID = parent.MyClassID; parent.MyClassChilds.Add(child); child.Informatin = parent.Information + "的MyClassChild子对象" + ran.Next(1, 1000); &#125; else &#123; child.Informatin = "MyClassChild对象" + ran.Next(1, 1000); &#125; return child; &#125; &#125;&#125; 多对多关联对象的CRUD数据库的设计规范 没有定义独立主键 定义了独立主键 Create Update delete 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120namespace CRUDTest&#123; public class ManyToManyHelper &#123; private static Random ran = new Random(); /// &lt;summary&gt; /// 创建一个用于测试的User对象 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static User CreateUser() &#123; User user = new User &#123; UserName = "User" + ran.Next(1, 100) &#125;; return user; &#125; /// &lt;summary&gt; /// 创建一个用于测试的Role对象 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static Role CreateRole() &#123; Role role = new Role &#123; RoleName = "Role" + ran.Next(1, 100) &#125;; return role; &#125; /// &lt;summary&gt; /// 删除所有数据 /// &lt;/summary&gt; public static void DeleteAllRecord() &#123; using (var context = new MyDBContext()) &#123; context.Database.ExecuteSqlCommand("Delete from [User]"); context.Database.ExecuteSqlCommand("Delete from Role"); context.Database.ExecuteSqlCommand("Delete from UserInRole"); &#125; &#125; /// &lt;summary&gt; /// 向数据库中添加初始记录（这是一种最规范的添加多对多关联的方式） /// &lt;/summary&gt; public static void Seed() &#123; using (var context = new MyDBContext()) &#123; DeleteAllRecord(); //添加管理员角色 Role role = new Role &#123; RoleName = "SystemAdmin" &#125;; context.Roles.Add(role); //管理员角色有三个用户 User user = null; for (int i = 0; i &lt; 3; i++) &#123; user = new User &#123; UserName = "SystemAdmin" + i &#125;; //设定其角色为管理员 user.Roles.Add(role); //加入到用户DbSet中 context.Users.Add(user); &#125; //添加游客角色 role = new Role &#123; RoleName = "Guest" &#125;; context.Roles.Add(role); //游客角色有三个用户 for (int i = 0; i &lt; 3; i++) &#123; user = new User &#123; UserName = "Guest" + i &#125;; //设定其角色为游客 user.Roles.Add(role); //加入到用户DbSet中 context.Users.Add(user); &#125; context.SaveChanges(); Console.WriteLine("测试数据己创建完毕"); &#125; &#125; /// &lt;summary&gt; /// 显示数据库中的所有记录 /// &lt;/summary&gt; public static void ShowRecords() &#123; using (var context = new MyDBContext()) &#123; ShowSystemAdmin(context); ShowGuest(context); &#125; &#125; public static void ShowGuest(MyDBContext context) &#123; Console.WriteLine("游客"); var query = from admin in context.Users where admin.Roles.FirstOrDefault(r =&gt; r.RoleName == "Guest") != null select admin; foreach (var user in query) &#123; Console.WriteLine("\t" + user.UserName); &#125; &#125; public static void ShowSystemAdmin(MyDBContext context) &#123; Console.WriteLine("管理员"); var query = from admin in context.Users where admin.Roles.FirstOrDefault(r =&gt; r.RoleName == "SystemAdmin") != null select admin; foreach (var user in query) &#123; Console.WriteLine("\t" + user.UserName); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225namespace CRUDTest.ManyToMany&#123; [TestClass] public class ManyToManyTest &#123; private TestContext testContextInstance; public TestContext TestContext &#123; get &#123; return testContextInstance; &#125; set &#123; testContextInstance = value; &#125; &#125; [ClassCleanup()] public static void MyClassCleanup() &#123; //测试结束时，自动地移除所有记录 ManyToManyHelper.DeleteAllRecord(); &#125; [ClassInitialize()] public static void MyClassInitialize(TestContext testContext) &#123; //开始测试时，自动创建测试用的数据 ManyToManyHelper.Seed(); &#125; #region "Add" /// &lt;summary&gt; /// 在内存中创建两个用户和一个角色，让这两个用户属于这个角色 /// 注意：这种编程方式不推荐，这里只是用于演示EF的特性 /// 推荐的创建多对多关联的实例，请参看 /// ManyToManyHelper.Seed()方法 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; [TestMethod] public void TestAddUserAndRoleAllInMemory() &#123; using (var context = new MyDBContext()) &#123; User user = ManyToManyHelper.CreateUser(); User user2 = ManyToManyHelper.CreateUser(); Role role = ManyToManyHelper.CreateRole(); //不管在哪一端添加对象，都可以达到添加目的 //在User端，给User添加角色 user.Roles.Add(role); //在Role端，给角色添加用户 role.Users.Add(user); role.Users.Add(user2); //将Role加入到DbSet，Save之后， //它将会在User表和UserInRole表中同时创建两个用户和一个角色 context.Roles.Add(role); //如果使用Users，则必须把两个用户都追加到DbSet中， //才能把两个用户和它们所属的角色保存到数据库表中 //context.Users.Add(user); //context.Users.Add(user2); int result = context.SaveChanges(); Console.WriteLine("result="+result); Assert.IsTrue(result &gt; 0); &#125; &#125; #endregion #region "修改多对多对象之间的关联" /// &lt;summary&gt; /// 将一个新用户加入到现有角色中 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; [TestMethod] public void TestAddUserToRole() &#123; using (var context = new MyDBContext()) &#123; Role admin = context.Roles .FirstOrDefault( r =&gt; r.RoleName == "SystemAdmin" ); if (admin != null) &#123; //添加一个系统管理员用户 User user = ManyToManyHelper.CreateUser(); admin.Users.Add(user); //保存修改，注意发出的SQL命令 int result=context.SaveChanges(); Assert.IsTrue(result &gt; 0); //验证用户己经加入到系统管理员角色中…… Role adminFromDB = context.Roles .FirstOrDefault( r =&gt; r.RoleName == "SystemAdmin" ); Assert.IsNotNull(adminFromDB.Users .FirstOrDefault(u =&gt; u.UserId == user.UserId)); Console.WriteLine(user.UserName + "己加入到SystemAdmin角色中"); ManyToManyHelper.ShowSystemAdmin(context); &#125; &#125; &#125; /// &lt;summary&gt; /// 给一个现有用户添加新角色（角色己经存在了） /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; [TestMethod] public void TestAssignRoleToUser() &#123; using (var context = new MyDBContext()) &#123; Role admin = context.Roles.FirstOrDefault( r =&gt; r.RoleName == "SystemAdmin"); Role guest = context.Roles.FirstOrDefault( r =&gt; r.RoleName == "Guest"); User user = context.Users.FirstOrDefault(); if (user.Roles.Count == 0) &#123; user.Roles.Add(admin); user.Roles.Add(guest); &#125; else &#123; if (user.Roles.Count == 1) &#123; if (user.Roles.ElementAt(0).RoleName == "SystemAdmin") &#123; user.Roles.Add(guest); &#125; else user.Roles.Add(admin); &#125; &#125; int result=context.SaveChanges(); Assert.IsTrue(result &gt; 0); Console.WriteLine("给" + user.UserName + "添加了SystemAdmin和Guest两个角色"); ManyToManyHelper.ShowRecords(); &#125; &#125; #endregion #region "Delete" /// &lt;summary&gt; /// 将一个用户从角色中移除 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; [TestMethod] public void TestRemoveUserFromRole() &#123; using (var context = new MyDBContext()) &#123; Role admin = context.Roles.FirstOrDefault( r =&gt; r.RoleName == "SystemAdmin"); if (admin != null) &#123; User user = admin.Users.FirstOrDefault(); if (user != null) &#123; admin.Users.Remove(user); int result = context.SaveChanges(); Assert.IsTrue(result &gt; 0); Console.WriteLine(user.UserName + "己从SystemAdmin角色中移除"); ManyToManyHelper.ShowSystemAdmin(context); &#125; &#125; &#125; &#125; /// &lt;summary&gt; /// 删除一个角色 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; [TestMethod] public void DeleteSystemAdminRole() &#123; using (var context = new MyDBContext()) &#123; Role systemAdmin = context.Roles.Include("Users") .FirstOrDefault(r =&gt; r.RoleName == "SystemAdmin"); if (systemAdmin != null) &#123; List&lt;User&gt; users= systemAdmin.Users.ToList(); Console.WriteLine("&#123;0&#125;中包容用户&#123;1&#125;个",systemAdmin.RoleName, users.Count); for (int i = 0; i &lt; users.Count; i++) &#123; Console.WriteLine("\t&#123;0&#125;",systemAdmin.Users.ElementAt(i).UserName); &#125; //删除“系统管理员”这个角色 context.Roles.Remove(systemAdmin); int result = context.SaveChanges(); Assert.IsTrue(result == users.Count + 1); //确认Role表中确实没有SystemAdmin的记录了 Role roleFromDB = context.Roles.FirstOrDefault( r =&gt; r.RoleName == "SystemAdmin"); Assert.IsNull(roleFromDB); //确认用户表中的记录仍然存在 User temp = null; for (int i = 0; i &lt; users.Count; i++) &#123; int id=users[i].UserId; temp = context.Users.FirstOrDefault( u =&gt; u.UserId == id); Assert.IsNotNull(temp); &#125; &#125; &#125; &#125; #endregion &#125;&#125; 学习指南 EF构建一个数据存取层数据流动方向 设计存取层 抽取数据实体到独立的项目 Repository 设计模式(定义接口) Repository典型实现 需要改进的点：每次操作都会新建一个context对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class SimplestOrderClientRepository : ISimplestOrderClientRepository&#123;public List&lt;OrderClient&gt; GetAllClients()&#123; using (var context = new MyDBEntities()) &#123; return context.OrderClients.ToList(); &#125;&#125;public int AddClient(OrderClient client)&#123; if (client == null) &#123; return 0; &#125; using (var context = new MyDBEntities()) &#123; context.OrderClients.Add(client); return context.SaveChanges(); &#125;&#125;public int DeleteClient(int ClientID)&#123; using (var context = new MyDBEntities()) &#123; var client = context.OrderClients.Find(ClientID); if (client != null) &#123; context.OrderClients.Remove(client); return context.SaveChanges(); &#125; else &#123; return 0; &#125; &#125;&#125;public int ModifyClient(OrderClient client)&#123; if (client == null) &#123; return 0; &#125; using (var context = new MyDBEntities()) &#123; var tempClient = context.OrderClients.FirstOrDefault(c =&gt; c.ClientID == client.ClientID); if (tempClient != null) &#123; tempClient.Address = client.Address; tempClient.ClientName = client.ClientName; tempClient.Email = client.Email; tempClient.PostCode = client.PostCode; tempClient.Telephone = client.Telephone; return context.SaveChanges(); &#125; else &#123; return 0; &#125; &#125;&#125;public List&lt;OrderClient&gt; FindClientsByName(string FindWhat)&#123; using (var context = new MyDBEntities()) &#123; return context.OrderClients.Where(c =&gt; c.ClientName.StartsWith(FindWhat)).ToList(); &#125;&#125; 改进版的Repository 应用继承特性的Repository 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455namespace DataAccessLayer&#123; public class BaseRepository&lt;TDbContext&gt; : IDisposable where TDbContext : DbContext &#123; protected TDbContext _dbContext = null; public BaseRepository(TDbContext context) &#123; _dbContext = context; &#125; public int SaveChanges() &#123; if (_dbContext != null) &#123; return _dbContext.SaveChanges(); &#125; return 0; &#125; public Task&lt;int&gt; SaveChangesAsync() &#123; if (_dbContext != null) &#123; return _dbContext.SaveChangesAsync(); &#125; return Task&lt;int&gt;.FromResult(0); &#125; #region "Disposable编程模式" private bool disposed = false; protected virtual void Dispose(bool disposing) &#123; if (!this.disposed) &#123; if (disposing) &#123; _dbContext.Dispose(); &#125; &#125; this.disposed = true; &#125; public void Dispose() &#123; Dispose(true); GC.SuppressFinalize(this); &#125; #endregion &#125;&#125; 12345678910111213141516namespace DataAccessLayer&#123; /// &lt;summary&gt; /// 一个需要手工Commit，支持同步/异步操作和Dispose的Repository， /// &lt;/summary&gt; public interface IOrderClientRepository &#123; Task&lt;List&lt;OrderClient&gt;&gt; GetAllClientsAsync(); List&lt;OrderClient&gt; GetAllClient(); void AddClient(OrderClient client); void DeleteClient(int ClientID); void ModifyClient(OrderClient client); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960namespace DataAccessLayer&#123; public class OrderClientRepository : BaseRepository&lt;MyDBEntities&gt;, IOrderClientRepository &#123; public OrderClientRepository(MyDBEntities dbContext) : base(dbContext) &#123; &#125; public OrderClientRepository() : base(new MyDBEntities()) &#123; &#125; public Task&lt;List&lt;OrderClient&gt;&gt; GetAllClientsAsync() &#123; return _dbContext.OrderClients.ToListAsync(); &#125; public List&lt;OrderClient&gt; GetAllClient() &#123; return _dbContext.OrderClients.ToList(); &#125; public void AddClient(OrderClient client) &#123; if (client != null) &#123; _dbContext.OrderClients.Add(client); &#125; &#125; public async void DeleteClient(int ClientID) &#123; var client = await _dbContext.OrderClients.FindAsync(ClientID); if (client != null) &#123; _dbContext.OrderClients.Remove(client); &#125; &#125; public async void ModifyClient(OrderClient client) &#123; var tempClient = await _dbContext.OrderClients.FindAsync(client.ClientID); if (tempClient != null) &#123; tempClient.Address = client.Address; tempClient.ClientName = client.ClientName; tempClient.Email = client.Email; tempClient.PostCode = client.PostCode; tempClient.Telephone = client.Telephone; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354namespace DALTestProject&#123; [TestClass] public class OrderClientRepositoryTest &#123; OrderClientRepository repo = null; [TestInitialize] public void TestInitialize() &#123; repo = new OrderClientRepository(); &#125; [TestMethod] public async Task TestGetAllClientsAsync() &#123; var Clients = await repo.GetAllClientsAsync(); Assert.IsTrue(Clients.Count() &gt; 0); &#125; [TestMethod] public async Task TestAddClient() &#123; OrderClient client = OrderClientHelper.CreateOrderClient(); repo.AddClient(client); int result = await repo.SaveChangesAsync(); Assert.IsTrue(result == 1); &#125; [TestMethod] public async Task TestDeleteClient() &#123; var Clients = await repo.GetAllClientsAsync(); repo.DeleteClient(Clients.Last().ClientID); int result = await repo.SaveChangesAsync(); Assert.IsTrue(result == 1); &#125; [TestMethod] public async Task TestModifyClient() &#123; var clients = await repo.GetAllClientsAsync(); OrderClient client = clients[0]; //修改邮编 int oldPostCode = int.Parse(client.PostCode); client.PostCode = (oldPostCode + 1).ToString(); repo.ModifyClient(client); int result = await repo.SaveChangesAsync(); Assert.IsTrue(result == 1); &#125; &#125;&#125; 真的需要Repository么 Repository学习指南]]></content>
      <categories>
        <category>.NET Framework</category>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>数据库</tag>
        <tag>ENtityFramework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLServer数据库初识]]></title>
    <url>%2F2019%2F03%2F01%2FSQLServer%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[认识数据库库 关系数据库基础发展历史 解决思路 数据库介绍 SQLServer使用基础安装SQL Server​ 使用 SQL Server Management Studio 附加数据库 常用数据类型 主键列设置 表关联 SQL Server 用户与角色 SQL–结构化查询语言基础C#和SQL Server对比 命令分类（数据操作、定义、控制） SQL命令四大金刚 三种基本关系数据操作（选择 投影 连接） select特性(使用排序 、分组、 聚集函数) select扩展特性（使用视图 存储过程）]]></content>
      <categories>
        <category>.NET Framework</category>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>数据库</tag>
        <tag>SQLServer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LINQ与Lambda表达式]]></title>
    <url>%2F2019%2F02%2F28%2FLINQ%E4%B8%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[认识Lambda表达式、LINQ、学会使用 Lambda表达式基础从匿名方法 -&gt; Lambda表达式委托的典型用法 1234567891011121314151617181920212223242526272829303132namespace TypicalDelegateExample&#123; //1.定义一个委托 public delegate int AddDelegate(int i, int j);//2.定义一个MyClass类，放置一个满足AddDelegate委托要求的方法 class MyClass &#123; public int Add(int i,int j) &#123; return i + j; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; //3.定义一个委托变量 AddDelegate del = null; //4.实例化一个MyClass对象，并将其Add方法引用传给委托变量del MyClass obj = new MyClass(); del = obj.Add; //5.通过委托变量调用MyClass对象的Add()方法 int result=del(100, 200); Console.WriteLine("&#123;0&#125;+&#123;1&#125;=&#123;2&#125;",100,200,result); Console.ReadKey(true); &#125; &#125;&#125; 委托简化 -&gt;匿名方法-&gt;Lambda表达式 委托简化代码12345678910111213141516171819202122232425262728293031323334353637namespace UseAnonymousMethod&#123; //定义一个委托 public delegate int AddDelegate(int i, int j); class Program &#123; //使用委托类型参数的方法 public static void invokeDelegate(AddDelegate del, int i, int j) &#123; Console.WriteLine(del(i, j)); &#125; static void Main(string[] args) &#123; //利用C#匿名方法特性直接给委托变量赋值 AddDelegate del = delegate(int i, int j) &#123; return i + j; &#125;; //通过委托变量调用匿名方法 Console.WriteLine(del(100, 200)); //直接将匿名方法作为函数参数 invokeDelegate(delegate(int i, int j) &#123; return i + j; &#125;, 100, 200); //可以使用Lambda表达式进一步地简化 invokeDelegate((i, j) =&gt; i + j, 100, 200); Console.ReadKey(); &#125; &#125;&#125; 使用泛型委托示例123456789101112131415161718192021222324252627namespace UseGenericDelegate&#123; //定义泛型委托 public delegate T MyGenericDelegate&lt;T&gt;(T obj); class Program &#123; static void Main(string[] args) &#123; //使用匿名方法给泛型委托变量赋值 MyGenericDelegate&lt;int&gt; del = delegate(int vlaue) &#123; return vlaue * 2; &#125;; //调用泛型委托变量引用的匿名方法 Console.WriteLine(del(100)); //使用Lambda表达式给泛型委托变量赋值 MyGenericDelegate&lt;int&gt; del2 = (value) =&gt; value * 2; //调用泛型委托变量引用的Lambda表达式 Console.WriteLine(del2(100)); Console.ReadKey(); &#125; &#125;&#125; 系统预定义委托与Lambda表达式认识.NET基类库中几种预定义委托 Func&lt;&gt;委托 Action&lt;&gt; 委托 123456789101112131415161718192021222324252627282930313233343536namespace GenericDelegateInBaseClassLibrary&#123; class Program &#123; static void Main(string[] args) &#123; UseFuncDelegate(); UseActionDelegate(); Console.ReadKey(); &#125; private static void UseFuncDelegate() &#123; //使用匿名方法 Func&lt;int, int, long&gt; add = delegate(int a, int b) &#123; return a + b; &#125;; //使用Lambda表达式 Func&lt;int, int, int&gt; subtract = (a, b) =&gt; a - b; //调用示例 Console.WriteLine(add(5, 10)); Console.WriteLine(subtract(10, 5)); &#125; private static void UseActionDelegate() &#123; Action&lt;string&gt; show = (info) =&gt; &#123; Console.WriteLine(info); &#125;; show("Hello"); &#125; &#125;&#125; Comparison&lt;&gt;委托–比较对象 Predicate&lt;&gt; 委托–查找对象 Comparison&lt;&gt; Predicate&lt;&gt; 委托代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192namespace UseComparisonDelegate&#123; class MyClass &#123; public int Value; public string Information; &#125; class Program &#123; /// &lt;summary&gt; /// 创建一个MyClass类型的对象集合 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private static List&lt;MyClass&gt; GetMyClasList() &#123; List&lt;MyClass&gt; lst = new List&lt;MyClass&gt;(); Random ran = new Random(); MyClass obj = null; for (int i = 0; i &lt; 10; i++) &#123; obj = new MyClass &#123; Value = ran.Next(1, 100), Information = "object" + i.ToString() &#125;; lst.Add(obj); &#125; return lst; &#125; /// &lt;summary&gt; /// 打印一个MyClass对象集合的所有成员 /// &lt;/summary&gt; /// &lt;param name="lst"&gt;&lt;/param&gt; private static void PrintList(List&lt;MyClass&gt; lst) &#123; if (lst == null) return; foreach (MyClass obj in lst) Console.WriteLine("Infomation=&#123;0&#125;,Value=&#123;1&#125;", obj.Information, obj.Value); &#125; static void Main(string[] args) &#123; //使用Lambda表达式创建一个 Comparison&lt;MyClass&gt;委托对象 Comparison&lt;MyClass&gt; cmp = (obj1, obj2)=&gt; &#123; if (obj1.Value &gt; obj2.Value) return 1; else if (obj1.Value &lt; obj2.Value) return -1; else return 0; &#125;; List&lt;MyClass&gt; lst = GetMyClasList(); Console.WriteLine("生成的A对象集合为："); PrintList(lst); //调用泛型委托进行排序 lst.Sort(cmp); Console.WriteLine("排序后的结果为："); PrintList(lst); Console.ReadKey(); &#125; &#125;&#125;//替换上面的main static void Main(string[] args) &#123; //定义对象查询条件 Predicate&lt;MyClass&gt; pred = (elem)=&gt; &#123; if (elem.Value &gt; 50) return true; else return false; &#125;; List&lt;MyClass&gt; lst = GetAList(); Console.WriteLine("生成的A对象集合为："); PrintList(lst); //在集合中查询对象 MyClass foundElement= lst.Find(pred); if (foundElement != null) Console.WriteLine("找到了符合条件的对象。Infomation=&#123;0&#125;,Value=&#123;1&#125;", foundElement.Information, foundElement.Value); else Console.WriteLine("未找到符合条件的对象"); Console.ReadKey(); &#125; Lambda表达式基本语法 扩展方法 扩展方法:特殊的静态方法 特点(在静态类 指明适用类型） 应用: .NET基类库提供的集合查询方法 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758namespace UseExtensionMethods&#123; /// &lt;summary&gt; /// 将被“动态”扩展的原始类型 /// &lt;/summary&gt; class Person &#123; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125; &#125; /// &lt;summary&gt; /// 存放扩展方法的类 /// &lt;/summary&gt; static class PersonExtensions &#123; public static void SayHello(this Person person) &#123; Console.WriteLine("&#123;0&#125;说：“你好！”", person.Name); &#125; public static void SayHelloTo(this Person p1, Person p2) &#123; Console.WriteLine("&#123;0&#125;对&#123;1&#125;说：“您吃了吗？”",p1.Name,p2.Name); &#125; public static bool IsOlderThan(this Person p1, Person p2) &#123; return p1.Age &gt; p2.Age; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; var person = new Person() &#123; Name = "张三", Age = 30 &#125;; var person2 = new Person() &#123; Name = "李四", Age = 40 &#125;; person.SayHello(); person.SayHelloTo(person2); if (person.IsOlderThan(person2)) &#123; Console.WriteLine("&#123;0&#125;比&#123;1&#125;年纪大",person.Name,person2.Name); &#125; else &#123; Console.WriteLine("&#123;0&#125;并不比&#123;1&#125;年纪大", person.Name, person2.Name); &#125; Console.ReadKey(); &#125; &#125;&#125; 标准集合查询扩展方法查询扩展方法与LINQ的关系 常用集合查询扩展方法筛选 数据投影 集合代数运算 各种查询代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166 //take扩展方法 从序列开头返回指定数量的连续元素//OfType&lt;int&gt;扩展方法 根据指定类型 筛选出集合元素//Concat 连接两个序列//union 并集//Except：差集。两个集合进行差集运算时，返回属于第一个集合 但不属于第二个集合的元素。//Intersect：交集。//Distinct ：从集合中移除重复值。namespace UseQueryMethods&#123; class Program &#123; static void Main(string[] args) &#123; //UseWhere(); //UseSelect(); // UseOrderBy(); UseSetAndAggregateMethods(); Console.ReadKey(); &#125; /// &lt;summary&gt; /// 使用Where扩展方法 /// &lt;/summary&gt; private static void UseWhere() &#123; //创建一个包容[1,100]内整数的数组 IEnumerable&lt;int&gt; nums = Enumerable.Range(1, 100); //使用Where扩展方法筛选出5的倍数，构成一个集合返回 var numList = nums.Where((num) =&gt; num % 5 == 0); Print("集合中5的倍数有：&#123;0&#125;", numList); &#125; /// &lt;summary&gt; /// Select方法示例 /// &lt;/summary&gt; private static void UseSelect() &#123; //fileList的类型为：string[] //路径 搜索模式 var fileList = Directory.GetFiles("c:\\", "*.*"); //files的类型为：IEnumerable&lt;FileInfo&gt; var files = fileList.Select( file =&gt; new FileInfo(file)); //infos是匿名对象的集合，此匿名对象包容两个属性：文件名和文件大小 var infos = files.Select(info =&gt; new &#123; FileName = info.Name, FileLength = info.Length &#125;); //输出结果 foreach (var info in infos) &#123; Console.WriteLine("&#123;0&#125;:&#123;1&#125;字节", info.FileName, info.FileLength); &#125; &#125; /// &lt;summary&gt; /// 数据排序示例 /// &lt;/summary&gt; private static void UseOrderBy() &#123; //先把String对象转换为FileInfo对象，之后再按文件大小降序排列 var fileInfos = Directory.GetFiles("C:\\") .Select(file =&gt; new FileInfo(file)) .OrderByDescending(fileInfo =&gt; fileInfo.Length); //输出结果 foreach (var info in fileInfos) &#123; Console.WriteLine("&#123;0&#125;:&#123;1&#125;字节", info.Name, info.Length); &#125; &#125; /// &lt;summary&gt; /// 集合与聚合操作 /// &lt;/summary&gt; private static void UseSetAndAggregateMethods() &#123; //创建一个多态对象集合 IEnumerable&lt;object&gt; stuff = new object[] &#123; new object(), 1, 3, 5, 7, 9, "\"thing\"", Guid.NewGuid() &#125;; //输出数组的内容 Print("Stuff集合的内容: &#123;0&#125;", stuff); //偶数集合 IEnumerable&lt;int&gt; even = new int[] &#123; 0, 2, 4, 6, 8 &#125;; Print("偶数集合的内容: &#123;0&#125;", even); //从多态集合stuff中筛选中整数元素（全部为奇数）组成一个新集合 IEnumerable&lt;int&gt; odd = stuff.OfType&lt;int&gt;(); Print("奇数集合的内容: &#123;0&#125;", odd); //求两个集合的并集 IEnumerable&lt;int&gt; numbers = even.Union(odd); Print("奇数与偶数集合的并集，成为一个整数集合: &#123;0&#125;", numbers); Print("整数集合与偶数集合的并集: &#123;0&#125;", numbers.Union(even)); Print("整数集合与偶数集合的差集：&#123;0&#125;", numbers.Except(even)); Print("整数集合与奇数集合相连接: &#123;0&#125;", numbers.Concat(odd)); Print("整数集合与偶数集合的交集: &#123;0&#125;", numbers.Intersect(even)); Print("整数集合与奇数集合连接，再删除重复值: &#123;0&#125;", numbers.Concat(odd).Distinct()); if (!numbers.SequenceEqual(numbers.Concat(odd).Distinct())) &#123; throw new Exception("Unexpectedly unequal"); &#125; else &#123; Print("反转整数集合: &#123;0&#125;", numbers.Reverse()); Print("求整数集合的平均值: &#123;0&#125;", numbers.Average()); Print("求整数集合的总和: &#123;0&#125;", numbers.Sum()); Print("求整数集合的最大值: &#123;0&#125;", numbers.Max()); Print("求整数集合的最小值: &#123;0&#125;", numbers.Min()); &#125; &#125; #region "辅助方法" /// &lt;summary&gt; /// 输出集合的内容 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; /// &lt;param name="format"&gt;&lt;/param&gt; /// &lt;param name="items"&gt;&lt;/param&gt; private static void Print&lt;T&gt;(string format, IEnumerable&lt;T&gt; items) &#123; StringBuilder text = new StringBuilder(); //take 从序列开头返回指定数量的连续元素 foreach (T item in items.Take(items.Count() - 1)) &#123; text.Append(item + ", "); &#125; text.Append(items.Last()); // 可更改为：string text=string.Join(",", items); Console.WriteLine(format, text); &#125; /// &lt;summary&gt; /// 按指定格式输出参数值 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; /// &lt;param name="format"&gt;&lt;/param&gt; /// &lt;param name="item"&gt;&lt;/param&gt; private static void Print&lt;T&gt;(string format, T item) &#123; Console.WriteLine(format, item); &#125; #endregion &#125;&#125; 1234567891011121314Stuff集合的内容: System.Object, 1, 3, 5, 7, 9, "thing", 1b0d433b-aade-4278-b079-6592e25ce090偶数集合的内容: 0, 2, 4, 6, 8奇数集合的内容: 1, 3, 5, 7, 9奇数与偶数集合的并集，成为一个整数集合: 0, 2, 4, 6, 8, 1, 3, 5, 7, 9整数集合与偶数集合的并集: 0, 2, 4, 6, 8, 1, 3, 5, 7, 9整数集合与偶数集合的差集：1, 3, 5, 7, 9整数集合与奇数集合相连接: 0, 2, 4, 6, 8, 1, 3, 5, 7, 9, 1, 3, 5, 7, 9整数集合与偶数集合的交集: 0, 2, 4, 6, 8整数集合与奇数集合连接，再删除重复值: 0, 2, 4, 6, 8, 1, 3, 5, 7, 9反转整数集合: 9, 7, 5, 3, 1, 8, 6, 4, 2, 0求整数集合的平均值: 4.5求整数集合的总和: 45求整数集合的最大值: 9求整数集合的最小值: 0 LINQ进化史独立数据处理功能 引入委托进行重构 引入泛型进行重构 引入扩展方法改造 使用yield属性优化性能 改写为LINQ查询语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352namespace EvolutionToLINQ&#123; class Program &#123; static void Main(string[] args) &#123; //FindOddNumbers(); //FindOddNumbers2(); //FindOddOrEvenNumbers(); //GenericFindOddOrEvenNumbers(); //GenericFindOddOrEvenNumbers2(); //FindOddOrEvenNumbersUseLambda(); //FindOddOrEvenNumbersUseExtensionMethod(); //FindOddOrEvenNumbersUseExtensionMethod2(); //FindOddNumbersUseWhere(); //FindOddNumbersUseLINQ(); Console.ReadKey(); &#125; #region "原始版本" /// &lt;summary&gt; /// 查找所有的奇数 /// &lt;/summary&gt; static void FindOddNumbers() &#123; //生成从1到10的整数集合 var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; //找出所有的奇数，放到List&lt;int&gt;集合中 var result = new List&lt;int&gt;(); foreach (var num in nums) &#123; if (IsOdd(num)) &#123; result.Add(num); &#125; &#125; //输出结果 foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; /// &lt;summary&gt; /// 判断某数是否为奇数 /// &lt;/summary&gt; /// &lt;param name="num"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; static bool IsOdd(int num) &#123; return num % 2 != 0; &#125; #endregion #region "数据处理功能独立" /// &lt;summary&gt; /// 将数据处理功能外置为独立的方法 /// &lt;/summary&gt; static void FindOddNumbers2() &#123; //生成从1到10的整数集合 var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; //找出所有满足条件的数，放到集合中 var result = FilterIntegers(nums); //输出结果 foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; static IEnumerable&lt;int&gt; FilterIntegers(IEnumerable&lt;int&gt; list) &#123; //找出所有的奇数，放到List&lt;int&gt;集合中 var result = new List&lt;int&gt;(); foreach (var num in list) &#123; if (IsOdd(num)) &#123; result.Add(num); &#125; &#125; return result; &#125; #endregion #region "引入委托" //定义一个新委托 public delegate bool PredicateDelegate(int value); /// &lt;summary&gt; /// 让外界指定数据筛选的方法 /// &lt;/summary&gt; /// &lt;param name="list"&gt;&lt;/param&gt; /// &lt;param name="predicate"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; static IEnumerable&lt;int&gt; FilterIntegers(IEnumerable&lt;int&gt; list, PredicateDelegate predicate) &#123; //找出所有的偶数，放到List&lt;int&gt;集合中 var result = new List&lt;int&gt;(); foreach (var num in list) &#123; if (predicate(num)) &#123; result.Add(num); &#125; &#125; return result; &#125; /// &lt;summary&gt; /// 新增一个“偶数”判断方法 /// &lt;/summary&gt; /// &lt;param name="num"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; static bool IsEven(int num) &#123; return num % 2 == 0; &#125; static void FindOddOrEvenNumbers() &#123; //生成从1到10的整数集合 var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; //现在在外部就可以“临时”指定到底是需要偶数还是奇数 var result = FilterIntegers(nums, IsEven); //result = FilterIntegers(nums, IsOdd); //输出结果 foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; #endregion #region "引入泛型" //定义一个新的泛型委托 public delegate bool PredicateGenericDelegate&lt;T&gt;(T value); //修改数据过滤方法 static IEnumerable&lt;T&gt; Filter&lt;T&gt;(IEnumerable&lt;T&gt; list, PredicateGenericDelegate&lt;T&gt; predicate) &#123; //找出所有的偶数，放到List&lt;int&gt;集合中 var result = new List&lt;T&gt;(); foreach (var num in list) &#123; if (predicate(num)) &#123; result.Add(num); &#125; &#125; return result; &#125; static void GenericFindOddOrEvenNumbers() &#123; //生成从1到10的整数集合 var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; //现在在外部就可以“临时”指定到底是需要偶数还是奇数 var result = Filter(nums, IsEven); //result = Filter(nums, IsOdd); //输出结果 foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; #endregion #region "使用.NET预定义委托" static IEnumerable&lt;T&gt; Filter2&lt;T&gt;(IEnumerable&lt;T&gt; list, Func&lt;T, bool&gt; predicate) &#123; //找出所有的偶数，放到List&lt;int&gt;集合中 var result = new List&lt;T&gt;(); foreach (var num in list) &#123; if (predicate(num)) &#123; result.Add(num); &#125; &#125; return result; &#125; static void GenericFindOddOrEvenNumbers2() &#123; //生成从1到10的整数集合 var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; //现在在外部就可以“临时”指定到底是需要偶数还是奇数 var result = Filter2(nums, IsEven); result = Filter2(nums, IsOdd); //输出结果 foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; #endregion #region "使用Lambda表达式" static void FindOddOrEvenNumbersUseLambda() &#123; //生成从1到10的整数集合 var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; //现在在外部就可以“临时”指定到底是需要偶数还是奇数 var result = Filter2(nums, num =&gt; num % 2 == 0); //result = Filter2(nums, num =&gt; num % 2 != 0); //输出结果 foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; #endregion #region "引入扩展方法特性" static void FindOddOrEvenNumbersUseExtensionMethod() &#123; //生成从1到10的整数集合 var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; var result = nums.Filter(num =&gt; num % 2 == 0); //result = nums.Filter(nums, num =&gt; num % 2 != 0); //输出结果 foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; #endregion #region "优化后的扩展方法" static void FindOddOrEvenNumbersUseExtensionMethod2() &#123; var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; var result = nums.AdvancedFilter(num =&gt; num % 2 != 0) .AdvancedFilter(num =&gt; num % 3 != 0); foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; #endregion #region ".NET基类库中的Where扩展方法" static void FindOddNumbersUseWhere() &#123; var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; //Where方法可以级联，完成筛选出所有不是3的倍数的奇数的功能 var result = nums.Where(num =&gt; num % 2 != 0) .Where(num =&gt; num % 3 != 0); foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; #endregion #region "使用LINQ让代码更易读" static void FindOddNumbersUseLINQ() &#123; var nums = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; //LINQ查询就象数据库的SQL命令 var result = from num in nums where num % 2 != 0 &amp;&amp; num % 3 != 0 select num; foreach (var num in result) &#123; Console.WriteLine(num); &#125; &#125; #endregion &#125; static class MyExtensions &#123; public static IEnumerable&lt;T&gt; Filter&lt;T&gt;(this IEnumerable&lt;T&gt; list, Func&lt;T, bool&gt; predicate) &#123; //找出所有的符合条件的数，放到List&lt;int&gt;集合中 var result = new List&lt;T&gt;(); foreach (var num in list) &#123; if (predicate(num)) &#123; result.Add(num); &#125; &#125; return result; &#125; public static IEnumerable&lt;T&gt; AdvancedFilter&lt;T&gt;(this IEnumerable&lt;T&gt; list, Func&lt;T, bool&gt; predicate) &#123; //找出所有的符合条件的数，返回给外界 foreach (var num in list) &#123; if (predicate(num)) &#123; yield return num; &#125; &#125; &#125; /// &lt;summary&gt; /// 自己实现的Where扩展方法，其功能与.NET基类库中所提供的类似 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; /// &lt;param name="list"&gt;&lt;/param&gt; /// &lt;param name="predicate"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static IEnumerable&lt;T&gt; Where&lt;T&gt;(this IEnumerable&lt;T&gt; list, Func&lt;T, bool&gt; predicate) &#123; //找出所有的符合条件的数，返回给外界 foreach (var num in list) &#123; if (predicate(num)) &#123; yield return num; &#125; &#125; &#125; &#125;&#125; LINQ基础LINQ是什么 LINQ技术框架 LINQ使用步骤 类型推断和延迟特性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950namespace IntroToLINQ&#123; class Program &#123; static void Main(string[] args) &#123; UseLinq(); //UseExtensionMethods(); Console.ReadKey(); &#125; private static void UseLinq() &#123; // 1. 指定数据源 var numbers = new int[] &#123; 0, 1, 2, 3, 4, 5, 6 &#125;; // 2. 创建查询表达式 var numQuery = from num in numbers where (num % 2) == 0 select num; // 3. 执行查询 foreach (int num in numQuery) &#123; Console.Write("&#123;0&#125; ", num); &#125; &#125; static void UseExtensionMethods() &#123; IEnumerable&lt;int&gt; numQuery = new int[] &#123; 0, 1, 2, 3, 4, 5, 6 &#125; .Where&lt;int&gt;( delegate(int num) &#123; return (num % 2) == 0; &#125; ); foreach (int num in numQuery) &#123; Console.Write("&#123;0&#125; ", num); &#125; &#125; &#125;&#125; LINQ编程技巧基本技巧使用逻辑运算符 混用LINQ查询和扩展方法 OrderBy字句使用多字段排序 使用匿名对象封装感兴趣的数据 引入新的变量暂存查询结果 LINQ中直接调用本地方法 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153namespace LINQExamples&#123; class Program &#123; static void Main(string[] args) &#123; //TestLogicalOperator(); //TestDistinct(); //TestOrderBy(); //TestAnonymousObject(); TestLetStatement(); // TestNativeMethod(); Console.ReadKey(); &#125; #region "使用C#的逻辑运算符" static void TestLogicalOperator() &#123; IEnumerable&lt;FileInfo&gt; files = from fileName in Directory.GetFiles("C:\\") where File.GetLastWriteTime(fileName) &lt; DateTime.Now.AddDays(-1) &amp;&amp; Path.GetExtension(fileName).ToUpper() == ".TXT" select new FileInfo(fileName); foreach (var file in files) &#123; Console.WriteLine(file); &#125; &#125; #endregion #region "Distinct示例：消除重复项" static void TestDistinct() &#123; Console.WriteLine("Enumerable类的所有公有成员："); ListMemberNamesOfEnumerable(); &#125; /// &lt;summary&gt; /// 列出Enumerable类的所有公有成员（除去重复的成员） /// &lt;/summary&gt; static void ListMemberNamesOfEnumerable() &#123; MemberInfo[] members = typeof(Enumerable).GetMembers( BindingFlags.Static | BindingFlags.Public); //var methods = (from method in members // select method.Name); var methods = (from method in members select method.Name).Distinct(); int count = 0; foreach (string method in methods) &#123; count++; Console.WriteLine(" &#123;0&#125;: &#123;1&#125;,", count, method); &#125; &#125; #endregion #region "排序" static void TestOrderBy() &#123; IEnumerable&lt;FileInfo&gt; files = from fileName in Directory.GetFiles("C:\\") orderby (new FileInfo(fileName)).Length, fileName ascending select new FileInfo(fileName); foreach (var file in files) &#123; Console.WriteLine("&#123;0&#125; &#123;1&#125;字节", file.Name, file.Length); &#125; &#125; #endregion #region"动态创建匿名对象的示例" static void TestAnonymousObject() &#123; var files = from fileName in Directory.GetFiles("C:\\") select new &#123; Name = fileName, Length = new FileInfo(fileName).Length &#125;; foreach (var file in files) &#123; Console.WriteLine("&#123;0&#125;:&#123;1&#125;字节", file.Name, file.Length); &#125; &#125; #endregion #region "引入新的范围变量暂存查询结果" static void TestLetStatement() &#123; IEnumerable&lt;FileInfo&gt; files = from fileName in Directory.GetFiles("C:\\") let file = new FileInfo(fileName) orderby file.Length, fileName select file; foreach (var file in files) &#123; Console.WriteLine("&#123;0&#125;:&#123;1&#125;字节", file.Name, file.Length); &#125; &#125; #endregion #region"使用本地方法" static void TestNativeMethod() &#123; // 数据源. int[] numbers = &#123; 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 &#125;; //查找所有偶数 var queryEvenNums = from num in numbers where IsEven(num) select num; // 执行查询 foreach (var s in queryEvenNums) &#123; Console.Write(s.ToString() + " "); &#125; &#125; /// &lt;summary&gt; /// 判断一个数是否为偶数 /// &lt;/summary&gt; /// &lt;param name="num"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static bool IsEven(int num) &#123; if (num % 2 == 0) return true; return false; &#125; #endregion &#125;&#125; 分组 分组的基本方式 分组数据的读取 使用into子句针对分组进行进一步处理 实现“非此即彼”的分组 多段分组 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210namespace LINQGroupExamples&#123; public class Student &#123; /// &lt;summary&gt; /// 姓名 /// &lt;/summary&gt; public string Name &#123; get; set; &#125; /// &lt;summary&gt; /// 籍贯 /// &lt;/summary&gt; public string City &#123; get; set; &#125; /// &lt;summary&gt; /// 考试成绩 /// &lt;/summary&gt; public List&lt;int&gt; Scores &#123; get; set; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; //IntroduceGroup(); //UseGroupInto(); //TestBooleanGroup(); TestMultiGroup(); Console.ReadKey(); &#125; #region "认识分组" static void IntroduceGroup() &#123; List&lt;Student&gt; students = new List&lt;Student&gt; &#123; new Student &#123;Name="张三", City="北京"&#125;, new Student &#123;Name="李四", City="上海"&#125;, new Student &#123;Name="王五", City="北京"&#125;, new Student &#123;Name="赵六", City="重庆"&#125;, new Student &#123;Name="马七", City="北京"&#125; , new Student &#123;Name="牛八", City="上海"&#125; &#125;; // studnetQuery类型为：IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt; var studnetQuery = from student in students group student by student.City; //studentGroup类型为：IGrouping&lt;string, Student&gt; foreach (var studentGroup in studnetQuery) &#123; Console.WriteLine("\n====================="); Console.WriteLine("在&#123;0&#125;的学生清单：", studentGroup.Key); Console.WriteLine("====================="); int count = 0; foreach (Student stu in studentGroup) &#123; count++; Console.WriteLine("&#123;0&#125;:&#123;1&#125;(&#123;2&#125;)", count, stu.Name, stu.City); &#125; &#125; &#125; #endregion #region "分组后进一步处理" static void UseGroupInto() &#123; //一个单词数组作为数据源 string[] words = &#123; "blueberry", "chimpanzee", "abacus", "banana", "apple", "cheese", "elephant", "umbrella", "anteater" &#125;; // 按5个原音字母a、e、i、o、u将单词分组 var wordGroups = from w in words group w by w[0] into grps where (grps.Key == 'a' || grps.Key == 'e' || grps.Key == 'i' || grps.Key == 'o' || grps.Key == 'u') select grps; // 执行查询 foreach (var wordGroup in wordGroups) &#123; Console.WriteLine("以原音字母“&#123;0&#125;”开头的单词有：", wordGroup.Key); foreach (var word in wordGroup) &#123; Console.WriteLine(" &#123;0&#125;", word); &#125; &#125; &#125; #endregion #region "“非此即彼”的分组" static void TestBooleanGroup() &#123; List&lt;Student&gt; students = GetStudents(); // 按true或false分组 // 查询结果类型为：IEnumerable&lt;IGrouping&lt;bool, Student&gt;&gt; var booleanGroupQuery = from student in students group student by HasFailed(student.Scores); //输出查询结果 foreach (var studentGroup in booleanGroupQuery) &#123; Console.WriteLine(); Console.WriteLine(studentGroup.Key == true ? "有不及格课程的学生" : "成绩优秀的学生"); foreach (var student in studentGroup) &#123; Console.WriteLine(" &#123;0&#125;，平均分：&#123;1&#125;", student.Name, student.Scores.Average()); &#125; &#125; &#125; /// &lt;summary&gt; /// 创建示例数据 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; static List&lt;Student&gt; GetStudents() &#123; List&lt;Student&gt; students = new List&lt;Student&gt; &#123; new Student &#123;Name="张三", Scores= new List&lt;int&gt; &#123;97, 72, 81, 60&#125;&#125;, new Student &#123;Name="李四", Scores= new List&lt;int&gt; &#123;75, 84, 91, 39&#125;&#125;, new Student &#123;Name="王五", Scores= new List&lt;int&gt; &#123;99, 89, 91, 95&#125;&#125;, new Student &#123;Name="赵六", Scores= new List&lt;int&gt; &#123;72, 81, 65, 84&#125;&#125;, new Student &#123;Name="马七", Scores= new List&lt;int&gt; &#123;97, 89, 85, 82&#125;&#125; &#125;; return students; &#125; /// &lt;summary&gt; /// 判断成绩单中是否有“挂红灯”的课程 /// &lt;/summary&gt; /// &lt;param name="Scores"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; static bool HasFailed(List&lt;int&gt; Scores) &#123; foreach (int score in Scores) &#123; if (score &lt; 60) return true; &#125; return false; &#125; #endregion #region "多段分组" static void TestMultiGroup() &#123; List&lt;Student&gt; students = GetStudents(); // 查询结果类型为：IEnumerable&lt;IGrouping&lt;string, Student&gt; var booleanGroupQuery = from student in students group student by GroupKey(student.Scores); //输出查询结果 foreach (var studentGroup in booleanGroupQuery) &#123; Console.WriteLine(); Console.WriteLine(studentGroup.Key + "："); foreach (var student in studentGroup) &#123; Console.WriteLine(" &#123;0&#125;，平均分：&#123;1&#125;", student.Name, student.Scores.Average()); &#125; &#125; &#125; public static string GroupKey(List&lt;int&gt; Scores) &#123; //计算平均分，并取整 int avg = (int)Scores.Average(); string ret = ""; switch (avg / 10) //整除以10 &#123; case 10: case 9: ret = "优"; break; case 8: ret = "良"; break; case 7: ret = "中"; break; case 6: ret = "及格"; break; default: ret = "不及格"; break; &#125; return ret; &#125; #endregion &#125;&#125;]]></content>
      <categories>
        <category>.NET Framework</category>
        <category>基础入门到进阶-金旭亮</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>LINQ</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件化开发和单元测试]]></title>
    <url>%2F2019%2F02%2F27%2F%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E5%92%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[什么叫组件化开发？ 组件化开发概述软件系统开发面临的困境 用什么来描述组件实现的功能？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778namespace UseCOMServer&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; //Word对象 private Word.Application wordapp = null; //文件名 private string DocFileName &#123; get &#123; return txtFileName.Text; &#125; set &#123; txtFileName.Text = value; &#125; &#125; private void btnChooseFile_Click(object sender, EventArgs e) &#123; ChooseFile(); &#125; private void btnPrintPreview_Click(object sender, EventArgs e) &#123; PrintPreview(DocFileName); &#125; /// &lt;summary&gt; /// 选择要打开的Word文档 /// &lt;/summary&gt; private void ChooseFile() &#123; if (openFileDialog1.ShowDialog() == DialogResult.OK) &#123; //设定文件名 DocFileName = openFileDialog1.FileName; //激活打印预览按钮 btnPrintPreview.Enabled = true; &#125; &#125; /// &lt;summary&gt; /// 打印预览 /// &lt;/summary&gt; /// &lt;param name="wordFileName"&gt;&lt;/param&gt; private void PrintPreview(String wordFileName) &#123; if (String.IsNullOrEmpty(wordFileName)) &#123; return; &#125; //创建Word对象 if (wordapp == null) wordapp = new Microsoft.Office.Interop.Word.Application(); //使用命名参数和可选参数调用Word的功能 Word.Document doc = wordapp.Documents.Open(FileName: wordFileName); //打印预览 doc.PrintPreview(); //显示Word主窗体 wordapp.Visible = true; &#125; private void btnExit_Click(object sender, EventArgs e) &#123; Close(); &#125; &#125;&#125; 设计组件的基本原则 为复用而设计 考虑组建功能集合大小 组件化开发步骤 .NET组件化开始示例天下一统版 体制改革版 诸侯割据版 借鸡生蛋版 总结 .NET组件化开发技术基础什么叫程序集 程序集内部结构 “对外接口最小化”原则 组建依赖 组件版本 Nuget管理组件 单元测试软件测试概述 理解单元测试 单元测试编程技巧 1234567891011121314151617181920212223242526272829303132333435363738namespace ClassLib&#123; public class MyClass &#123; //求一个数的倍数 public int DoubleValue(int i) &#123; return i * 2; &#125; //计算从[from,to]中所有整数的和 public int Sum(int from, int to) &#123; if (from &gt; to) &#123; throw new ArgumentException("参数from必须小于to"); &#125; int sum = 0; for (int i = from; i &lt;= to; i++) &#123; sum += i; &#125; return sum; &#125; public const String AgeErrorString = "生日必须小于当前日期"; //给定一个人的生日，计算他的年纪 public int CaculateAge(DateTime Birthday) &#123; if (DateTime.Now &lt; Birthday) &#123; throw new ArgumentOutOfRangeException(AgeErrorString); &#125; return DateTime.Now.Year - Birthday.Year; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041namespace ClassLibTestProject&#123; [TestClass] public class InitializeAndCleanUpTest &#123; [TestInitialize] public void TestInitialize() &#123; Console.WriteLine("Begin Test"); &#125; [TestCleanup] public void TestCleanup() &#123; Console.WriteLine("Test finished"); &#125; [ClassInitialize] public static void MyClassInitialize(TestContext context) &#123; Console.WriteLine("Class is Initialized"); &#125; [ClassCleanup] public static void MyClassCleanup() &#123; Console.WriteLine("Class clean up"); &#125; [TestMethod] public void TestMethod1() &#123; Console.WriteLine("Running TestMethod1"); &#125; [TestMethod] public void TestMethod2() &#123; Console.WriteLine("Running TestMethod2"); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455namespace ClassLibTestProject&#123; [TestClass] public class MyClassTest &#123; public TestContext TestContext &#123; get; set; &#125; [TestMethod] public void DoubleValueTest() &#123; //Arrange:准备 MyClass target = new MyClass(); //设定测试用例 int value = 1; int expected = 2; //Act:执行 int actual = target.DoubleValue(value); //Assert:断言 Assert.AreEqual(expected, actual); &#125; [TestMethod] [ExpectedException(typeof(ArgumentException))] public void SumExceptionTest() &#123; MyClass target = new MyClass(); target.Sum(100, 50); &#125; [TestMethod] public void CalculateAgeOutOfRangeTest() &#123; try &#123; //Arrange:准备 MyClass target = new MyClass(); target.CaculateAge(DateTime.Now.AddDays(1)); &#125; catch (ArgumentOutOfRangeException e) &#123; StringAssert.Contains(e.Message, MyClass.AgeErrorString); return; &#125; Assert.Fail("No exception was thrown."); &#125; &#125;&#125; 123456789101112131415161718192021namespace ClassLibTestProject&#123; [TestClass] public class StringUtilsTest &#123; [TestMethod] public void ReverseWordTest() &#123; var OriginalString = "This is a string"; var ActualResult = StringUtils.Reverse(OriginalString); Assert.AreEqual("string a is This", ActualResult); &#125; [TestMethod] public void ReverseWordTest2() &#123; var OriginalString = "This is a string"; var ActualResult = StringUtils.Reverse(OriginalString); Assert.AreEqual("string a is This", ActualResult); &#125; &#125;&#125; 关于单元测试 编写单元测试原则 TDD]]></content>
      <categories>
        <category>.NET Framework</category>
        <category>基础入门到进阶-金旭亮</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[委托-事件-对象协作详解]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%A7%94%E6%89%98-%E4%BA%8B%E4%BB%B6-%E5%AF%B9%E8%B1%A1%E5%8D%8F%E4%BD%9C%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[理解委托、事件、对象之间协作关系 委托委托引例 详解委托类型 委托组合与分解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273namespace MulticastDelegateInvocationList&#123; /// &lt;summary&gt; /// 定义一个委托变量 /// &lt;/summary&gt; /// &lt;param name="value"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public delegate int MyDelegate(int value); /// &lt;summary&gt; /// MyClass类中的两个方法Func1和Func2符合委托的要求 /// &lt;/summary&gt; public class MyClass &#123; public int Func1(int argument) &#123; Console.WriteLine("Func1: i=&#123;0&#125;", argument); return argument; &#125; public int Func2(int argument) &#123; argument *= 2; Console.WriteLine("Func2: i=&#123;0&#125;", argument); return argument; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; MyClass obj = new MyClass(); MyDelegate del1 = new MyDelegate(obj.Func1); del1 += new MyDelegate(obj.Func2); //上面两句可以简写为以下形式： //MyDelegate del1 = obj.Func1; //del1 += obj.Func2; //获取方法调用列表 Delegate[] ds = del1.GetInvocationList(); Console.WriteLine("del1的委托调用列表中包含&#123;0&#125;个方法", ds.GetLength(0)); del1(5); //先调用obj.Func1(),再调用obj.Func2() MyDelegate del2 = obj.Func1; del2 += obj.Func2; Console.WriteLine("del2的委托调用列表中包含&#123;0&#125;个方法", del2.GetInvocationList().GetLength(0)); del2(5); //先调用obj.Func1(),再调用obj.Func2() //组合两个委托变量 MyDelegate mul = del1 + del2; ds = mul.GetInvocationList(); Console.WriteLine("合并del1和del2之后，新的委托变量mul的委托调用列表中包含&#123;0&#125;个方法", ds.GetLength(0)); int ret = mul(10); //获取委托调用列表最后一个方法的返回值 Console.WriteLine("合并之后，新委托变量mul的返回值 = &#123;0&#125;", ret); mul -= obj.Func2; ////取消以下这句注释，观察程序运行结果你发现了什么特性？ mul -= obj.Func2; mul -= obj.Func2; Console.WriteLine("移除Func2之后，委托变量mul的委托调用列表中包含&#123;0&#125;个方法", mul.GetInvocationList().GetLength(0)); ret = mul(10); //获取委托调用列表最后一个方法的返回值 Console.WriteLine("移除Func2之后，返回值 = &#123;0&#125;", ret); Console.ReadKey(); &#125; &#125;&#125; 定时回调 1234567891011121314151617181920212223242526272829303132namespace UseTimerCallback&#123; //用于向回调函数提供参数信息 class TaskInfo &#123; public int count = 0; &#125; class Program &#123; static void Main(string[] args) &#123; System.Console.WriteLine("敲任意键结束……"); TaskInfo ti=new TaskInfo() ; //创建Timer对象，将一个回调函数传给它，每隔一秒调用一次 // callback: 将要执行的方法 // state :包含回调方法使用的信息的对象，或NULL // dueTime: 调用回调之前的延迟时间(以毫秒为单位)。 // period: Timer tm = new Timer(ShowTime, ti , 0, 1000); System.Console.ReadKey(); tm.Dispose(); &#125; //被回调的函数 static void ShowTime(Object ti) &#123; TaskInfo obj = ti as TaskInfo; obj.count++; System.Console.WriteLine("(&#123;0&#125;)&#123;1&#125;", obj.count, DateTime.Now); &#125; &#125;&#125; 事件 事件三要素 利用委托实现自定义事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657namespace UseMultiDelegateExample&#123; //定义事件委托 public delegate void MyEventDelegate(int value ); //事件发布者类 public class Publisher &#123; public Publisher() &#123; Console.WriteLine("Publisher对象&#123;0&#125;创建", this.GetHashCode()); &#125; //利用多路委托变量保存多个事件响应者方法引用 public MyEventDelegate MyEvent; &#125; //事件响应者类 public class Subscriber &#123; public Subscriber() &#123; Console.WriteLine("Subscriber对象&#123;0&#125;创建",this.GetHashCode()); &#125; //事件触发时的回调方法 public void MyMethod(int value ) &#123; Console.WriteLine("Subscriber对象&#123;0&#125;响应MyEvent事件：value=&#123;1&#125;", this.GetHashCode(), value); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; //一个事件源对象 Publisher p = new Publisher(); Console.WriteLine(); //两个事件响应者 Subscriber s1 = new Subscriber(); Subscriber s2 = new Subscriber(); //挂接事件响应方法 p.MyEvent += s1.MyMethod; p.MyEvent += s2.MyMethod; Console.WriteLine("\n直接调用委托变量触发事件MyEvent\n"); //直接调用委托变量，代表触发事件 p.MyEvent(new Random().Next(1,100)); Console.ReadKey(); &#125; &#125;&#125; 123456789Publisher对象46104728创建Subscriber对象12289376创建Subscriber对象43495525创建直接调用委托变量触发事件MyEventSubscriber对象12289376响应MyEvent事件：value=58Subscriber对象43495525响应MyEvent事件：value=58 C#引入关键字event用于自定义事件委托变量MyEvent前有一个event关键字,直接用委托的方式调用会编译错误！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667namespace UseEventExample&#123; //定义事件委托 public delegate void MyEventDelegate(int value); //事件发布者类 public class Publisher &#123; public Publisher() &#123; Console.WriteLine("Publisher对象&#123;0&#125;创建",this.GetHashCode()); &#125; //使用C#的event关键字定义一个事件 public event MyEventDelegate MyEvent; //激发事件 public void FireEvent(int EventArgu) &#123; if (MyEvent != null) &#123; Console.WriteLine("Publisher对象&#123;0&#125;触发事件，事件参数：&#123;1&#125;", this.GetHashCode(),EventArgu); MyEvent(EventArgu); &#125; &#125; &#125; //事件响应者类 public class Subscriber &#123; public Subscriber() &#123; Console.WriteLine("Subscriber对象&#123;0&#125;创建", this.GetHashCode()); &#125; //事件触发时的回调方法 public void MyMethod(int value) &#123; Console.WriteLine("MyEvent事件触发：value=&#123;0&#125;,响应者：&#123;1&#125;", value, this.GetHashCode()); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; Publisher p = new Publisher(); Console.WriteLine(); Subscriber s1 = new Subscriber(); Subscriber s2 = new Subscriber(); //挂接事件响应代码 p.MyEvent += s1.MyMethod; p.MyEvent += s2.MyMethod; //委托变量MyEvent前有一个event关键字， //所以无法直接调用Publisher类的MyEvent方法 //以下代码无法通过编译 //p.MyEvent(100); //只能通过Publisher类的公有方法间接地触发事件 Console.WriteLine("\n通过Publisher对象的公有方法触发事件\n"); p.FireEvent(new Random().Next(1, 100)); Console.ReadKey(); &#125; &#125;&#125; event关键字的功用 .NET事件揭秘 “Click”事件探秘 小结 运行时设定事件的响应函数 为事件重复追加响应方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051namespace UseEventHandler2&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; /// &lt;summary&gt; /// 借的钱 /// &lt;/summary&gt; private int LoanMoney = 0; /// &lt;summary&gt; /// 借钱的次数 /// &lt;/summary&gt; private int LoanCount = 0; /// &lt;summary&gt; /// 向黄世仁借钱 /// &lt;/summary&gt; private void LoanFromHuang() &#123; btnSum.Enabled = true; LoanMoney = 0; //追加事件响应函数 btnSum.Click += new EventHandler(btnSum_Click); lblLoanCount.Text = string.Format("&#123;0&#125; 次", ++LoanCount); &#125; /// &lt;summary&gt; /// 杨白劳看看欠了黄世仁多少钱 /// &lt;/summary&gt; private void ShowLoanState() &#123; LoanMoney += 100; lblLoanMoney.Text = string.Format("&#123;0&#125; 元", LoanMoney); lblLoanMoney.Refresh(); Thread.Sleep(300); btnSum.Enabled = false; &#125; private void btnLoanFromHuang_Click(object sender, EventArgs e) &#123; LoanFromHuang(); &#125; void btnSum_Click(object sender, EventArgs e) &#123; ShowLoanState(); &#125; &#125;&#125; 单个方法响应多个对象同样事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253namespace ResponseToEvents&#123; public partial class frmEnterToTab : Form &#123; public frmEnterToTab() &#123; InitializeComponent(); //挂接事件 foreach (Control ctl in groupBox1.Controls) &#123; if (ctl is TextBox) (ctl as TextBox).KeyDown += this.EnterToTab; &#125; &#125; //回车移动焦点 private void EnterToTab(object sender, KeyEventArgs e) &#123; TextBox txt=null; if (e.KeyCode == Keys.Enter) &#123; groupBox1.SelectNextControl(sender as Control , true, true, true, true); //拥有焦点的文本框自动全选 txt=(sender as TextBox); if(txt!=null) txt.SelectAll(); &#125; &#125; &#125;&#125; // 摘要: // Activates the next control. // // 参数: // ctl: // The System.Windows.Forms.Control at which to start the search. // // forward: // true to move forward in the tab order; false to move backward in the tab order. // // tabStopOnly: // true to ignore the controls with the System.Windows.Forms.Control.TabStop property // set to false; otherwise, false. // // nested: // true to include nested (children of child controls) child controls; otherwise, // false. // // wrap: // true to continue searching from the first control in the tab order after the // last control has been reached; otherwise, false. // // 返回结果: // true if a control was activated; otherwise, false. 动态设定事件响应方法 123456789101112131415161718192021222324252627282930313233343536373839404142namespace DynamicEventsInvoke&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; //定义两个事件响应函数 private void Event1(Object sender,EventArgs e) &#123; MessageBox.Show("事件处理程序一"); &#125; private void Event2(Object sender,EventArgs e) &#123; MessageBox.Show("事件处理程序二"); &#125; private void RadioButton1_CheckedChanged(object sender, EventArgs e) &#123; RemoveAllHandler(); Button1.Click += Event1; &#125; private void RemoveAllHandler() &#123; Button1.Click -= Event1; Button1.Click -= Event2; &#125; private void RadioButton2_CheckedChanged(object sender, EventArgs e) &#123; RemoveAllHandler(); Button1.Click += Event2; &#125; &#125;&#125; 对象间的协作与信息交换 同一对象内部的信息交换 12345678910111213141516171819202122232425namespace ButtonCounterInSingleForm&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; //被应用程序处理的信息 private int counter = 0; //当用户点击按钮时，此方法被调用，整个信息处理流程被启动 private void btnClickMe_Click(object sender, EventArgs e) &#123; //处理信息 counter++; //传输信息 ShowInfo(); &#125; private void ShowInfo() &#123; //标签对象通过其公有属性接收外界传入的信息 lblCount.Text = string.Format("你单击了&#123;0&#125;次按钮。", counter); &#125; &#125;&#125; “主-&gt;从”对象间信息的传送 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647namespace MultiFormProgram1&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); frm = new frmOther(); //创建从窗体对象 frm.Show();//显示从窗体 &#125; private frmOther frm = null; //用于引用从窗体对象 private void btnSend_Click(object sender, EventArgs e) &#123; //SendMessageViaPublicProperty(); SendMessageViaPublicMethod(); &#125; private void SendMessageViaPublicProperty() &#123; if (txtUserInput.Text == "") &#123; MessageBox.Show("请输入一条信息", "提示", MessageBoxButtons.OK, MessageBoxIcon.Asterisk); //焦点回到文本框 txtUserInput.Focus(); return; &#125; //通过向从窗体的自定义属性赋值传送信息 frm.Info = txtUserInput.Text; &#125; private void SendMessageViaPublicMethod() &#123; if (txtUserInput.Text == "") &#123; MessageBox.Show("请输入一条信息", "提示", MessageBoxButtons.OK, MessageBoxIcon.Asterisk); //焦点回到文本框 txtUserInput.Focus(); return; &#125; //直接调用从窗体对象公有方法传送信息 frm.Receive(txtUserInput.Text); &#125; &#125;&#125; 1234567891011121314151617181920212223242526namespace MultiFormProgram1&#123; public partial class frmOther : Form &#123; public frmOther() &#123; InitializeComponent(); &#125; /// &lt;summary&gt; /// 公有只写属性，用Label显示外界传入的信息 /// &lt;/summary&gt; public string Info &#123; set &#123; lblInfo.Text ="老大说："+ value; &#125; &#125; public void Receive(String Info) &#123; lblInfo.Text = Info; &#125; &#125;&#125; “从-&gt;主”对象间信息的传送主窗体“主动”查询信息 1234567891011121314151617181920namespace MultiFormProgram2&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private void btnShowDialog_Click(object sender, EventArgs e) &#123; frmOther frm = new frmOther(); //依据从窗体提供的状态信息，决定不同的处理方式 if (frm.ShowDialog() == DialogResult.OK) lblInfo.Text = frm.UserInput; else lblInfo.Text = "用户取消了输入。"; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132namespace MultiFormProgram2&#123; public partial class frmOther : Form &#123; public frmOther() &#123; InitializeComponent(); &#125; //供主窗体对象提取信息的公有属性 public string UserInput &#123; get &#123; return txtUserInput.Text; &#125; &#125; private void btnOK_Click(object sender, EventArgs e) &#123; //设置本窗体关闭的“原因”，以供主窗体进行查询 this.DialogResult = DialogResult.OK; this.Close(); &#125; private void btnCancel_Click(object sender, EventArgs e) &#123; //设置本窗体关闭的“原因”，以供主窗体进行查询 this.DialogResult = DialogResult.Cancel; this.Close(); &#125; &#125;&#125; 从窗体“主动”汇报(重点) 12345678910111213141516171819202122232425namespace OtherFormToMainForm2&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private void btnShowDialog_Click(object sender, EventArgs e) &#123; //主窗体把自己的引用传给从窗体对象 frmOther frm = new frmOther(this); frm.Show(); &#125; /// &lt;summary&gt; /// 供从窗体调用，向主窗体“汇报”工作完成情况 /// &lt;/summary&gt; /// &lt;param name="Info"&gt;&lt;/param&gt; public void Report(String Info) &#123; lblInfo.Text = Info; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334namespace OtherFormToMainForm2&#123; public partial class frmOther : Form &#123; //用于保存主窗体对象引用 private frmMain mainForm = null; //从外部将主窗体对象“注入”进来 public frmOther(frmMain main) &#123; InitializeComponent(); mainForm = main; &#125; //在事件响应方法中“回调”主窗体对象的Report()方法 private void btnOK_Click(object sender, EventArgs e) &#123; if (String.IsNullOrEmpty(txtUserInput.Text.Trim())) &#123; mainForm.Report("用户没有输入文本"); &#125; else &#123; mainForm.Report(txtUserInput.Text); &#125; Close(); &#125; private void btnCancel_Click(object sender, EventArgs e) &#123; mainForm.Report("用户取消了操作"); Close(); &#125; &#125;&#125; 理解回调概念 示例 12345678namespace CallBackExample&#123; //实现回调的类必须实现此接口 public interface ICallBack &#123; void run(); &#125;&#125; 1234567891011namespace CallBackExample&#123; class CallBackClass:ICallBack &#123; public void run() &#123; //输出当前时间 System.Console.WriteLine(DateTime.Now ); &#125; &#125;&#125; 12345678910111213141516namespace CallBackExample&#123; class CallBackClass2:ICallBack &#123; #region ICallBack 成员 private int counter = 0; public void run() &#123; counter++; System.Media.SystemSounds.Asterisk.Play(); Console.WriteLine("I'm invoked " + counter.ToString() + " times"); &#125; #endregion &#125;&#125; 123456789101112131415161718192021222324namespace CallBackExample&#123; class Controller &#123; private List&lt;ICallBack&gt; CallBackObjects = new List&lt;ICallBack&gt;();//回调对象 public void AddCallBack(ICallBack callback) &#123; CallBackObjects.Add(callback); &#125; public void Begin() &#123; Console.WriteLine("敲任意键回调方法 , ESC键退出..."); while (Console.ReadKey(true).Key != ConsoleKey.Escape) &#123; Console.WriteLine(); foreach (ICallBack obj in CallBackObjects) obj.run(); &#125; &#125; &#125;&#125; 123456789101112131415namespace CallBackExample&#123; class Program &#123; static void Main(string[] args) &#123; //创建控制器对象，将提供给它的回调对象传入 Controller controller = new Controller(); controller.AddCallBack(new CallBackClass()); controller.AddCallBack(new CallBackClass2()); //启动控制器对象运行 controller.Begin(); &#125; &#125;&#125; 为什么使用接口？ 对象间消息双向传送 12345678910111213141516171819202122232425262728namespace TwoWayCommunicationInForms&#123; public partial class frmMain : Form &#123; private frmOther frm = null; //引用从窗体 public frmMain() &#123; InitializeComponent(); frm = new frmOther(this); frm.Show(); &#125; /// &lt;summary&gt; /// 向外界公开的方法 /// &lt;/summary&gt; /// &lt;param name="value"&gt;&lt;/param&gt; public void SetValue(int value) &#123; NumericUpDown1.Value = value; &#125; private void NumericUpDown1_ValueChanged(object sender, EventArgs e) &#123; //通过从窗体的公有属性向其传送信息 frm.WorkDownPercent = (int)NumericUpDown1.Value; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869namespace TwoWayCommunicationInForms&#123; public partial class frmOther : Form &#123; public frmOther(frmMain frm) &#123; InitializeComponent(); frmMainForm = frm; &#125; //引用主窗体 private frmMain frmMainForm = null; /// &lt;summary&gt; /// 允许外界设置进度条的数值 /// &lt;/summary&gt; public int WorkDownPercent &#123; get &#123; return ProgressBar1.Value; &#125; set &#123; ProgressBar1.Value = value; //显示信息 lblInfo.Text = String.Format("&#123;0&#125;%", ProgressBar1.Value); &#125; &#125; /// &lt;summary&gt; /// 修改进度条控件的值，IsIncrease属性用于确定是增加还是减少 /// &lt;/summary&gt; /// &lt;param name="IsIncrease"&gt;&lt;/param&gt; private void ChangeProgressBarValue(bool IsIncrease) &#123; if (IsIncrease) //增值 &#123; if (ProgressBar1.Value == 100) ProgressBar1.Value = 0; //重新开始 else ProgressBar1.Value += 2; &#125; else //减值 &#123; if (ProgressBar1.Value == 0) ProgressBar1.Value = 0; //不允许再减少了 else ProgressBar1.Value -= 2; &#125; //显示信息 lblInfo.Text = String.Format("&#123;0&#125;%", ProgressBar1.Value); //向主窗体的公有方法向其传送信息 frmMainForm.SetValue(ProgressBar1.Value); &#125; private void btnIncrease_Click(object sender, EventArgs e) &#123; ChangeProgressBarValue(true); &#125; private void btnDecrease_Click(object sender, EventArgs e) &#123; ChangeProgressBarValue(false); &#125; &#125;&#125; 在对象间广播信息(一到多) 使用对象集合 123456789101112131415161718192021222324252627282930313233343536namespace UseObjectCollection&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private void btnNewForm_Click(object sender, EventArgs e) &#123; NewForm(); &#125; //窗体对象集合 private List&lt;frmOther&gt; OtherForms = new List&lt;frmOther&gt;(); private void NewForm() &#123; //每新建一个窗体，就将其加入到OtherForms对象集合中 frmOther frm = new frmOther(); OtherForms.Add(frm); frm.Show(); &#125; private int counter = 0;//计数器 private void btnClickMe_Click(object sender, EventArgs e) &#123; counter++; //遍历从窗体对象集合，逐个回调其ShowCounter方法，计数器新值成为其参数 foreach (frmOther frm in OtherForms) &#123; frm.ShowCounter(counter); &#125; &#125; &#125;&#125; 123456789101112131415namespace UseObjectCollection&#123; public partial class frmOther : Form &#123; public frmOther() &#123; InitializeComponent(); &#125; //供主窗体“回调”，显示主窗体传入的计数器值 public void ShowCounter(int counter) &#123; lblInfo.Text = counter.ToString(); &#125; &#125;&#125; 使用委托 12345678910111213141516171819202122232425262728293031323334353637namespace UseDelegate&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; //将用于引用多个从窗体对象所挂接的“回调”方法 private Action&lt;int&gt; ReceiverMethods; private void btnNewForm_Click(object sender, EventArgs e) &#123; NewForm(); &#125; private void NewForm() &#123; frmOther frm = new frmOther(); //从窗体将自己的ShowCounter方法挂接到主窗体的委托变量ReceiverMethods上 ReceiverMethods += frm.ShowCounter; frm.Show(); &#125; private int counter = 0;//计数器 private void btnClickMe_Click(object sender, EventArgs e) &#123; counter++; if (ReceiverMethods != null) &#123; //调用委托调用链中的所有方法，传入当前的计数器值 ReceiverMethods(counter); &#125; &#125; &#125;&#125; 12345678910111213141516namespace UseDelegate&#123; public partial class frmOther : Form &#123; public frmOther() &#123; InitializeComponent(); &#125; public void ShowCounter(int counter) &#123; lblInfo.Text = counter.ToString(); &#125; &#125;&#125; 使用事件 123456789101112131415161718192021222324252627282930313233343536373839namespace UseEvent&#123; public delegate void MyClickDelegate(int counter); public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; //主窗体定义一个MyClick事件 public event MyClickDelegate MyClick; private void btnNewForm_Click(object sender, EventArgs e) &#123; NewForm(); &#125; private void NewForm() &#123; frmOther frm = new frmOther(); //从窗体对象将ShowCounter方法挂接到MyClick事件上，响应这个事件 MyClick += frm.ShowCounter; frm.Show(); &#125; private int counter = 0;//计数器 private void btnClickMe_Click(object sender, EventArgs e) &#123; counter++; //触发事件 if (MyClick != null) &#123; MyClick(counter); &#125; &#125; &#125;&#125; 12345678910111213141516namespace UseEvent&#123; public partial class frmOther : Form &#123; public frmOther() &#123; InitializeComponent(); &#125; public void ShowCounter(int counter) &#123; lblInfo.Text = counter.ToString(); &#125; &#125;&#125; 对象监控(多到一) 利用对象引用回调 123456789101112131415161718192021222324252627namespace ButtonCounterForMultiFormUseReference&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; //从窗体点击计数器 private int counter = 0; /// &lt;summary&gt; /// 显示累计按钮单击次数的结果 /// &lt;/summary&gt; public void ShowCounter() &#123; counter++; lblInfo.Text = counter.ToString(); &#125; private void btnShowOtherForm_Click(object sender, EventArgs e) &#123; frmOther frm = new frmOther(this); //在屏幕上显示窗体 frm.Show(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526namespace ButtonCounterForMultiFormUseReference&#123; public partial class frmOther : Form &#123; //使用对象注入的方式，在主从对象之间建立关联 public frmOther(frmMain main) &#123; InitializeComponent(); MainForm = main; &#125; private frmMain MainForm = null; private void btnClickMe_Click(object sender, EventArgs e) &#123; //调用主窗体的公有方法，显示按钮计数 //此处无需向主窗体传送任何信息，因为我们只需要统计点击次数 //如果确实有信息想发给主窗体，可以让主窗体定义一个有参数的公有方法或属性 //在此处将信息以实参（或直接向主窗体公有属性赋值）的方式传送给主窗体 if (MainForm != null) &#123; MainForm.ShowCounter(); &#125; &#125; &#125;&#125; 利用委托回调 123456789101112131415161718192021222324252627282930namespace ButtonCounterForMultiFormUseDelegate&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private int counter = 0; /// &lt;summary&gt; /// 显示累计按钮单击次数的结果 /// &lt;/summary&gt; private void ShowCounter() &#123; counter++; lblInfo.Text = counter.ToString(); &#125; private void btnShowOtherForm_Click(object sender, EventArgs e) &#123; frmOther frm = new frmOther(); //将主窗体的方法“挂接”到从窗体对象上 frm.CallBackMethod = this.ShowCounter; //在屏幕上显示从窗体 frm.Show(); &#125; &#125;&#125; 123456789101112131415161718192021222324namespace ButtonCounterForMultiFormUseDelegate&#123; public partial class frmOther : Form &#123; public frmOther() &#123; InitializeComponent(); &#125; //用于“回调”主窗体挂接的方法 public Action CallBackMethod = null; private void btnClickMe_Click(object sender, EventArgs e) &#123; //回调主窗体的方法，显示按钮计数 if (CallBackMethod != null) &#123; CallBackMethod(); &#125; &#125; &#125;&#125; 自定义事件 12345678910111213141516171819202122232425262728293031namespace ButtonCounterForMultiFormUseEvent&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private int counter = 0; /// &lt;summary&gt; /// 主窗体响应从窗体的MyClick事件 /// &lt;/summary&gt; private void ResponseToOtherFormMyClickEvent() &#123; counter++; lblCount.Text = counter.ToString(); &#125; private void btnNewOtherForm_Click(object sender, EventArgs e) &#123; frmOther frm = new frmOther(); //挂接从窗体事件响应函数 frm.MyClick += this.ResponseToOtherFormMyClickEvent; frm.Show(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728namespace ButtonCounterForMultiFormUseEvent&#123; /// &lt;summary&gt; /// 定义事件委托 /// &lt;/summary&gt; /// &lt;param name="?"&gt;&lt;/param&gt; public delegate void MyClickDelegate(); public partial class frmOther : Form &#123; public frmOther() &#123; InitializeComponent(); &#125; //自定义一个事件 public event MyClickDelegate MyClick; //在按钮单击事件中激发MyClick事件 private void btnClickMe_Click(object sender, EventArgs e) &#123; if (MyClick != null) &#123; MyClick(); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122namespace ButtonCounterForMultiFormUseStaticMethod&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; public void ShowCounter(int counter) &#123; lblCount.Text = counter.ToString(); &#125; private void btnNewOtherForm_Click(object sender, EventArgs e) &#123; frmOther frm = new frmOther(); frm.Show(); &#125; &#125;&#125; 12345678910111213141516namespace ButtonCounterForMultiFormUseStaticMethod&#123; public partial class frmOther : Form &#123; public frmOther() &#123; InitializeComponent(); &#125; private void btnClickMe_Click(object sender, EventArgs e) &#123; Program.NotifyClicked(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>.NET Framework</category>
        <category>基础入门到进阶-金旭亮</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象基础进阶]]></title>
    <url>%2F2019%2F02%2F24%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[理解对象组合、复制、序列化、比较 对象组合 一对一对象组合 一对一对象组合实现 对象间的”关联”理解 一对一对象组合应用实例 一对多对象组合 一对多编程实例 认识列表框控件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869namespace OneToManyWinForm&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private void btnAdd_Click(object sender, EventArgs e) &#123; AddItem(); &#125; private void btnClear_Click(object sender, EventArgs e) &#123; listBox1.Items.Clear(); &#125; private void btnDelete_Click(object sender, EventArgs e) &#123; DeleteItem(); &#125; /// &lt;summary&gt; /// 添加选项 /// &lt;/summary&gt; private void AddItem() &#123; //不允许加空项 if (txtUserInput.Text.Trim() != "") &#123; listBox1.Items.Add(txtUserInput.Text); txtUserInput.Text = ""; &#125; &#125; /// &lt;summary&gt; /// 删除选项 /// &lt;/summary&gt; private void DeleteItem() &#123; if (listBox1.SelectedIndex != -1) &#123; listBox1.Items.RemoveAt(listBox1.SelectedIndex); &#125; &#125; /// &lt;summary&gt; /// 显示列表框中的当前选中项 /// &lt;/summary&gt; private void ShowSelectedItem() &#123; String SelectedItem = listBox1.SelectedItem == null ? "无" : listBox1.SelectedItem.ToString(); lblInfo.Text = String.Format("当前选中项为：&#123;0&#125;", SelectedItem); &#125; private void listBox1_SelectedIndexChanged(object sender, EventArgs e) &#123; ShowSelectedItem(); &#125; private void txtUserInput_KeyDown(object sender, KeyEventArgs e) &#123; //回车时直接加入列表 if (e.KeyCode == Keys.Enter) &#123; AddItem(); &#125; &#125; &#125;&#125; 建模实例分析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061namespace CarFactory&#123; class Program &#123; static void Main(string[] args) &#123; Car car = new Car(); Console.WriteLine("\n敲任意键启动汽车……\n"); Console.ReadKey(true); car.Start(); Console.WriteLine("\n敲任意键刹车……\n"); Console.ReadKey(true); car.Brake(); Console.WriteLine("\n敲任意键退出程序……\n"); Console.ReadKey(true); &#125; &#125; //代表发动机 class Engine &#123; public void Start() &#123; Console.WriteLine("发动机启动"); &#125; public void Stop() &#123; Console.WriteLine("发动机停止"); &#125; &#125; //汽车轮 class Wheel &#123; &#125; class Car &#123; private Engine _engine = new Engine(); private Wheel[] wheels = new Wheel[4]; public void Start() &#123; Console.WriteLine("插入钥匙，打火，启动……"); _engine.Start(); Console.WriteLine("启动成功，开始行驶"); &#125; public void Brake() &#123; Console.WriteLine("刹车！"); Stop(); &#125; public void Stop() &#123; _engine.Stop(); Console.WriteLine("汽车停车"); &#125; &#125; &#125; 自引用类 1234567891011namespace LinkListExample&#123; //链表节点 class LinkNode &#123; //保存数据 public object Data; //引用下一个链接节点 public LinkNode Next = null; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334namespace LinkListExample&#123; class Program &#123; static void Main(string[] args) &#123; //生成链表节点 LinkNode Head = new LinkNode()&#123; Data="Head"&#125;; LinkNode First = new LinkNode() &#123; Data = "First" &#125;; LinkNode Second = new LinkNode() &#123; Data = "Second" &#125;; LinkNode Tail = new LinkNode() &#123; Data = "Tail" &#125;; //建立链表 Head.Next = First; First.Next = Second; Second.Next = Tail; Console.WriteLine("链表己创建，其内容为："); //访问链表的全部节点 LinkNode node; node = Head; while (node != null) &#123; //从node.Data中取出节点数据，干一些事 if(node.Next!=null) Console.Write("&#123;0&#125;--&gt;", node.Data); else Console.Write("&#123;0&#125;", node.Data); node = node.Next;//移往下一个节点 &#125; Console.ReadKey(); &#125; &#125;&#125; 对象复制 对象的“浅复制” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091namespace ObjectCloneDemo&#123; #region "支持内容比对的简单对象" class MyClass &#123; private int MyClassValue = 100; public override string ToString() &#123; return "MyClassValue:" + MyClassValue; &#125; public override bool Equals(object obj) &#123; if (obj == null || obj is MyClass == false) &#123; return false; &#125; return MyClassValue == (obj as MyClass).MyClassValue; &#125; public override int GetHashCode() &#123; return MyClassValue; &#125; public static MyClass CloneObject(MyClass obj) &#123; MyClass newObj = new MyClass(); newObj.MyClassValue = obj.MyClassValue; //字段复制 return newObj; &#125; &#125; #endregion #region "组合的对象" class ClassB &#123; public int BValue = 200; &#125; class ClassA &#123; public int AValue = 100; public ClassB EmbedObject; //ClassA包容一个ClassB的对象 public ClassA() &#123; EmbedObject = new ClassB(); //创建被包容对象 &#125; public static ClassA CloneObject(ClassA obj) &#123; ClassA newObj = new ClassA(); newObj.AValue = obj.AValue; //字段复制 newObj.EmbedObject = obj.EmbedObject; //引用复制 return newObj; &#125; &#125; #endregion class Program &#123; static void Main(string[] args) &#123; //ObjectCopyViaFieldCopy(); ObjectCopyViaFieldCopy2(); Console.ReadKey(); &#125; /// &lt;summary&gt; /// 基于字段值拷贝的简单对象复制 /// &lt;/summary&gt; static void ObjectCopyViaFieldCopy() &#123; MyClass obj = new MyClass(); MyClass other = MyClass.CloneObject(obj); Console.WriteLine("原对象：&#123;0&#125;,新对象：&#123;1&#125;", obj, other); Console.WriteLine(obj == other); //false Console.WriteLine(obj.Equals(other));// true &#125; /// &lt;summary&gt; /// 基于字段值拷贝的组合对象复制 /// &lt;/summary&gt; static void ObjectCopyViaFieldCopy2() &#123; ClassA obj = new ClassA(); ClassA other = ClassA.CloneObject(obj); Console.WriteLine(obj == other); //false Console.WriteLine(obj.AValue == other.AValue); // true Console.WriteLine(obj.EmbedObject == other.EmbedObject);// true Console.WriteLine(obj.EmbedObject.BValue == other.EmbedObject.BValue); //true &#125; &#125;&#125; 对象的深复制 ICloneable接口 1234567891011121314151617181920212223242526272829303132333435363738394041namespace DeepCopy&#123; class ClassA : ICloneable &#123; public int AValue = 100; public ClassB EmbedObject; //ClassA包容一个ClassB的对象 public Object Clone() &#123; ClassA ObjA = new ClassA(); ObjA.AValue = this.AValue; ObjA.EmbedObject = (this.EmbedObject as ICloneable).Clone() as ClassB; return ObjA; &#125; &#125; class ClassB : ICloneable &#123; public int BValue = 200; public Object Clone() &#123; ClassB ObjB = new ClassB(); ObjB.BValue = this.BValue; return ObjB; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; ClassA ObjA = new ClassA(); ObjA.EmbedObject = new ClassB(); //开始克隆 ClassA other = (ObjA as ICloneable).Clone() as ClassA; Console.WriteLine(other.EmbedObject == ObjA.EmbedObject); //false Console.ReadKey(); &#125; &#125;&#125; 对象序列化(保存对象状态) 什么是流？(一连串有顺序的二进制数据) 使用流实现序列化 .NET基类库中提供的几种流对象 两种对象序列化方式 XML格式序列化实例 123456789101112131415161718192021222324namespace UseXmlSerializer&#123; public class MyClass &#123; public int IntField ; public string StringField ; &#125; class Program &#123; static void Main(string[] args) &#123; var Serializer = new XmlSerializer(typeof(MyClass)); MyClass obj = new MyClass() &#123; IntField = 100, StringField = "Hello" &#125;; //输出流:控制台窗口 Serializer.Serialize(Console.Out, obj); Console.ReadKey(); &#125; &#125;&#125; 12345&lt;?xml version="1.0" encoding="gb2312"?&gt;&lt;MyClass xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt; &lt;IntField&gt;100&lt;/IntField&gt; &lt;StringField&gt;Hello&lt;/StringField&gt;&lt;/MyClass&gt; 二进制格式序列化实例 1234567891011121314namespace SingleObjectSerialization&#123; //学生信息 [Serializable] class CollegeStudent &#123; //姓名 public String Name = "空"; //性别 public bool IsMale = true; //入学考试成绩 public int ScoreForEntranceExamination = 0; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111namespace SingleObjectSerialization&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); stu = new CollegeStudent(); //将学生默认信息显示在窗体上 this.ClearInputControls(); &#125; //学生对象 private CollegeStudent stu ; //将学生信息显示在窗体上 private void ShowStudentInfo(CollegeStudent obj) &#123; if (obj == null) return; this.txtName.Text = obj.Name; this.txtScore.Text = Convert.ToString(obj.ScoreForEntranceExamination); this.rdoMale.Checked = obj.IsMale ; this.rdoFemale.Checked = !obj.IsMale; &#125; //清除所有的输入控件到初始状态 private void ClearInputControls() &#123; this.txtName.Text = "空"; this.txtScore.Text ="0"; this.rdoMale.Checked = true; &#125; //更新对象信息 private void UpdateStudentObj(CollegeStudent stu) &#123; if (stu == null) return; stu.IsMale = rdoMale.Checked; stu.Name = txtName.Text; stu.ScoreForEntranceExamination = Convert.ToInt32(txtScore.Text); &#125; //保存对象到文件中 private void SaveToFile() &#123; String FileName = ""; this.saveFileDialog1.FileName = "Student"; this.UpdateStudentObj(stu); if (this.saveFileDialog1.ShowDialog() == DialogResult.OK) &#123; FileName = saveFileDialog1.FileName; SerializeObj(FileName,stu); &#125; &#125; //将CollegeStudent对象序列化到文件中 private void SerializeObj(String FileName,CollegeStudent stu) &#123; //创建FileStream对象 using (FileStream writer = new FileStream(FileName, FileMode.Create)) &#123; //创建格式化器对象 using System.Runtime.Serialization; IFormatter formatter = new BinaryFormatter(); //格式化器对象使用FileStream对象序列化对象 formatter.Serialize(writer, stu); MessageBox.Show("对象成功保存到文件:" + FileName); &#125; &#125; //从文件中装入对象 private void LoadFromFile() &#123; String FileName = ""; if (this.openFileDialog1.ShowDialog() == DialogResult.OK) &#123; FileName = openFileDialog1.FileName; this.ShowStudentInfo(DeserializeObj(FileName)); &#125; &#125; //从文件中反序列化对象 private CollegeStudent DeserializeObj(String FileName) &#123; using (FileStream reader = new FileStream(FileName, FileMode.Open)) &#123; //using System.Runtime.Serialization.Formatters.Binary IFormatter formatter = new BinaryFormatter(); return (CollegeStudent)formatter.Deserialize(reader); &#125; &#125; private void btnClear_Click(object sender, EventArgs e) &#123; this.ClearInputControls(); &#125; private void btnSaveObject_Click(object sender, EventArgs e) &#123; this.SaveToFile(); &#125; private void btnLoadObject_Click(object sender, EventArgs e) &#123; this.LoadFromFile(); &#125; &#125;&#125; 反序列化 使用内存流快速大批的复制对象 12345678910111213141516171819202122232425262728293031323334namespace ObjectCloneViaSerialization&#123; [Serializable] class MyClass &#123; public int Index = 1; &#125; class Program &#123; static void Main(string[] args) &#123; MyClass obj = new MyClass(); //创建一个内存流对象 using (MemoryStream ms = new MemoryStream()) &#123; IFormatter formator = new BinaryFormatter(); //将对象序列化到内存流中 formator.Serialize(ms, obj); //克隆100个对象 for (int i = 0; i &lt; 100; i++) &#123; //回到流的开头 偏移是0 枚举 开始 当前 结束 ms.Seek(0, SeekOrigin.Begin); //反序列化对象 obj = (formator.Deserialize(ms) as MyClass); obj.Index += i; //设置对象字段 Console.WriteLine("对象&#123;0&#125;已创建。", obj.Index); &#125; &#125; Console.ReadKey(); &#125; &#125;&#125; 程序退出保存状态 123456789101112namespace SaveFormStatus&#123; [Serializable] public class FormStatus &#123; public Color BackgroundColor &#123; get; set; &#125; public int Left &#123; get; set; &#125; public int Top &#123; get; set; &#125; public int Width &#123; get; set; &#125; public int Height &#123; get; set; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980namespace SaveFormStatus&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); LoadStatus(); &#125; private void btnChooseColor_Click(object sender, EventArgs e) &#123; if (colorDialog1.ShowDialog() == DialogResult.OK) &#123; BackColor = colorDialog1.Color; &#125; &#125; private FormStatus status = null; private void SaveStatus() &#123; status=new FormStatus(); status.BackgroundColor=this.BackColor; status.Left=this.Left; status.Top=this.Top; status.Width=this.Width; status.Height = this.Height; using(FileStream fs=new FileStream("FormStatus.cfg",FileMode.Create)) &#123; IFormatter formatter = new BinaryFormatter(); formatter.Serialize(fs, status); &#125; &#125; private void LoadStatus() &#123; try &#123; if (File.Exists("FormStatus.cfg")) &#123; using (FileStream fs = new FileStream("FormStatus.cfg", FileMode.Open)) &#123; IFormatter formatter = new BinaryFormatter(); status = formatter.Deserialize(fs) as FormStatus; if (status != null) &#123; this.BackColor = status.BackgroundColor; this.Left = status.Left; this.Top = status.Top; this.Width = status.Width; this.Height = status.Height; &#125; &#125; &#125; &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); &#125; &#125; private void frmMain_FormClosing(object sender, FormClosingEventArgs e) &#123; SaveStatus(); &#125; private void frmMain_Load(object sender, EventArgs e) &#123; &#125; &#125;&#125; 对象比较 实现IComparable接口 仅判断是否相等(重写Equals方法) 重写GetHashCode方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899namespace ObjectCompare&#123; /// &lt;summary&gt; /// 圆心 /// &lt;/summary&gt; public struct CircleCenter &#123; public double x; public double y; &#125; class Circle : IComparable, IComparable&lt;Circle&gt;, IEquatable&lt;Circle&gt; &#123; public double Radius = 0; //半径 public CircleCenter Center &#123; get; set; &#125; //圆心 //实现IComparable接口定义的方法 public int CompareTo(object obj) &#123; if (!(obj is Circle)) throw new ArgumentException("只能比对Cirlce对象"); return CompareTo(obj as Circle); &#125; //实现IComparable&lt;T&gt;接口定义的方法 public int CompareTo(Circle other) &#123; double ret = Math.Abs(other.Radius - this.Radius); if (ret &lt; 1e-3) return 0; if (other.Radius &lt; this.Radius) return 1; return -1; &#125; //覆盖Object类的GetHashCode方法 public override int GetHashCode() &#123; //整数部分与小数点后3位相同的对象生成相同的哈希值 return (int)(Radius * 1000); &#125; //重写Object类的Equals方法 public override bool Equals(object obj) &#123; if (this.CompareTo(obj) == 0) return true; return false; &#125; //实现IEquatable&lt;Circle&gt;接口定义的方法 public bool Equals(Circle other) &#123; return this.CompareTo(other) == 0; &#125; //---------------------------------------- //重载相关的运算符 //---------------------------------------- public static bool operator ==(Circle obj1, Circle obj2) &#123; return obj1.Equals(obj2); &#125; public static bool operator !=(Circle obj1, Circle obj2) &#123; return !(obj1.Equals(obj2)); &#125; public static bool operator &gt;(Circle obj1, Circle obj2) &#123; if (obj1.CompareTo(obj2) &gt; 0) return true; return false; &#125; public static bool operator &lt;(Circle obj1, Circle obj2) &#123; if (obj1.CompareTo(obj2) &lt; 0) return true; return false; &#125; public static bool operator &lt;=(Circle obj1, Circle obj2) &#123; if ((obj1.CompareTo(obj2) &lt; 0) || (obj1.CompareTo(obj2) == 0)) return true; return false; &#125; public static bool operator &gt;=(Circle obj1, Circle obj2) &#123; if ((obj1.CompareTo(obj2) &gt; 0) || (obj1.CompareTo(obj2) == 0)) return true; return false; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435namespace ObjectCompare&#123; class Program &#123; static void Main(string[] args) &#123; Circle obj1 = new Circle &#123; Radius = 100.1 &#125;; Circle obj2 = new Circle &#123; Radius = 100.9 &#125;; //测试覆盖的方法 Console.WriteLine(obj1.GetHashCode());//100100 Console.WriteLine(obj2.GetHashCode());//100900 Console.WriteLine(obj1.CompareTo(obj2)); //-1 Console.WriteLine(obj1.Equals(obj2));//false //测试重载的运算符 Console.WriteLine(obj1 == obj2); //false Console.WriteLine(obj1 != obj2); //true Console.WriteLine(obj1 &gt;= obj2); //false //以下测试Circle对象数组的排序功能 Circle[] circles = new Circle[10]; //创建Circle对象数组 Random ran = new Random(); for (int i = 0; i &lt; 10; i++) &#123; circles[i] = new Circle &#123; Radius = ran.Next(1, 1000)/100.0 &#125;; &#125; Console.WriteLine("原始数组："); Array.ForEach&lt;Circle&gt;(circles, (circle) =&gt; &#123; Console.WriteLine("圆对象的哈希代码：&#123;0&#125;，半径：&#123;1&#125;", circle.GetHashCode(), circle.Radius); &#125;); Console.WriteLine("\n排序之后："); Array.Sort(circles); Array.ForEach&lt;Circle&gt;(circles, (circle) =&gt; &#123; Console.WriteLine("圆对象的哈希代码：&#123;0&#125;，半径：&#123;1&#125;", circle.GetHashCode(), circle.Radius); &#125;); Console.ReadKey(); &#125; &#125;&#125; 对象排序实例(实现接口，直接使用排序和查找)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091namespace ObjectSort&#123; class MyClass : IComparable&lt;MyClass&gt; &#123; public int Value &#123; get; set; &#125; public String Information &#123; get; set; &#125; /// &lt;summary&gt; /// 先按照Value字段值比较，如果Value值一样， /// 就按照Information字段值比较, /// 只有两个字段值都一样，才认为这两个对象相等 /// &lt;/summary&gt; /// &lt;param name="other"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public int CompareTo(MyClass other) &#123; if (other == null) &#123; return -1; &#125; int result=this.Value.CompareTo(other.Value); if (result == 0) &#123; return this.Information.CompareTo(other.Information); &#125; return result; &#125; public override bool Equals(object obj) &#123; if (obj == null || obj is MyClass == false) &#123; return false; &#125; return this.CompareTo(obj as MyClass)==0; &#125; public override int GetHashCode() &#123; return Value ; &#125; public override string ToString() &#123; return String.Format("Value:&#123;0&#125;\t Information:&#123;1&#125;\n", Value, Information) ; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; var MyClasses = GenerateExampleCollection(); Console.WriteLine("原始集合："); MyClasses.ForEach((obj) =&gt; &#123; Console.WriteLine(obj); &#125;); MyClasses.Sort(); Console.WriteLine("\n排序之后："); MyClasses.ForEach((obj) =&gt; &#123; Console.WriteLine(obj); &#125;); MyClass objToFind = new MyClass() &#123; Value = 2,Information = "ABC" &#125;; Console.WriteLine("\n查找对象：&#123;0&#125;", objToFind); int index = MyClasses.IndexOf(objToFind); Console.WriteLine("对象&#123;0&#125;在集合中的索引：&#123;1&#125;",objToFind,index); Console.ReadKey(); &#125; static List&lt;MyClass&gt; GenerateExampleCollection() &#123; var collection = new List&lt;MyClass&gt;(); collection.Add(new MyClass() &#123; Value=1, Information="Hello" &#125;); collection.Add(new MyClass() &#123; Value = 2, Information = "World" &#125;); collection.Add(new MyClass() &#123; Value = 2, Information = "ABC" &#125;); return collection; &#125; &#125;&#125; 对象比较器(类是别人写好的，不好修改实现IComparable接口) 1234567namespace ObjectComparer&#123; public class MyClass &#123; public int Value; &#125;&#125; 12345678910namespace ObjectComparer&#123; class MyClassComparer : IComparer&lt;MyClass&gt; &#123; public int Compare(MyClass x, MyClass y) &#123; return x.Value.CompareTo(y.Value); &#125; &#125;&#125; 12345678910111213141516171819202122232425namespace ObjectComparer&#123; class Program &#123; static void Main(string[] args) &#123; MyClass[] objs = new MyClass[] &#123; new MyClass&#123;Value=124&#125;, new MyClass&#123;Value=100&#125;, new MyClass&#123;Value=1&#125;, new MyClass&#123;Value=75&#125; &#125;; Console.WriteLine("原始数组："); Array.ForEach&lt;MyClass&gt;(objs, obj =&gt; &#123; Console.Write("Value=&#123;0&#125; ,", obj.Value); &#125;); //使用比较器对象 在sort集合中排序 Array.Sort&lt;MyClass&gt;(objs, new MyClassComparer()); Console.WriteLine("\n排序之后："); Array.ForEach&lt;MyClass&gt;(objs, obj =&gt; &#123; Console.Write("Value=&#123;0&#125; ,", obj.Value); &#125;); Console.ReadKey(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>.NET Framework</category>
        <category>基础入门到进阶-金旭亮</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象基础入门]]></title>
    <url>%2F2019%2F02%2F22%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[熟悉C# 类、对象、数组、继承、多态、异常处理、泛型编程 认识类和对象面向对象的方式看世界 认识类 创建对象 类和对象的之间的关系 编写类 类的定义方法 小结 属性什么是属性 属性之经典实现方法 C#3.0改进-自动实现的属性 相比字段可以添加业务逻辑 属性的其他玩法 构造方法调用时机 形式（无返回值） 重载 存在意义 字段与属性的初始化问题点 使用构造函数 使用对象初始化器 初始化集合类型的对象 分部类与分部方法基本概念 具体使用场景 命名空间 管理类 创建和使用 程序集(组件化开发)什么是程序集 如何创建程序集 使用程序集 程序集和命名空间之间的关系 基于程序集开发程序 对象和对象变量对象变量与内存模型对象变量和对象之间的关系 线程堆栈VS托管堆 引用类型VS值类型 对象变量赋值的真实含义 对象判等 值类型都为true 引用类型都为false(都是比较对象变量的引用) 按照对象“内容”比较，需要重写基类equals方法 都为true 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465namespace EqualsDemo&#123; class Program &#123; static void Main(string[] args) &#123; //int i = 100; //int j = 100; //Console.WriteLine(i==j); ////int类型居然有equals方法？ //Console.WriteLine(i.Equals(j)); //Console.WriteLine(); //MyClass obj1 = new MyClass(); //MyClass obj2 = new MyClass(); //Console.WriteLine(obj1 == obj2); //Console.WriteLine(obj1.Equals(obj2)); Console.WriteLine(); //String类型是引用类型还是值类型？ String str1 = "Hello"; String str2 = "Hello"; Console.WriteLine(str1 == str2); Console.WriteLine(str1.Equals(str2)); Console.ReadKey(); &#125; &#125; class MyClass &#123; private int value = 100; #region "比较对象" /// &lt;summary&gt; /// 如何比较两个对象的“内容” /// &lt;/summary&gt; /// &lt;param name="obj"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public override bool Equals(object obj) &#123; if (obj == null) &#123; return false; &#125; else &#123; if (obj is MyClass) &#123; return this.value == (obj as MyClass).value; &#125; &#125; return false; &#125; public override int GetHashCode() &#123; return value; &#125; #endregion &#125;&#125; this引用是一个对象变量 访问字段隐藏了this this小结 装箱和拆箱 方法参数两种类型 不同作用 只读类 只读类实例 只读类存在意义 如何设计 类的静态成员 const和Static的应用 Static定义类的静态成员 两种类型的类成员 静态字段VS实例字段 类成员访问规则 多窗体编程初步添加新窗体 设定启动窗体 窗体的显示方式 数组数组基础 对象数组对象数组的定义 对象数组内存模型 作为方法参数 继承继承VS分类 C#中继承的实现方式 字段访问规则 方法的重载与覆盖 继承与代码重用 抽象类与接口抽象类与抽象方法 抽象类的定义 抽象类的使用 接口场景引出 解决方法 接口的特点 类与接口关系 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364namespace Duck&#123; class Program &#123; static void Main(string[] args) &#123; Duck d = new Duck(); //Duck对象d可以使用3种方法： //1.自身定义的； //2.父类定义的 //3.接口定义的 d.Fly(); d.Cook(); d.Swim(); //将子类（Duck）对象赋给基类变量 Bird b = d; //现在只能使用基类定义的Fly()方法 b.Fly(); //将Duck对象赋给ISwin接口变量 ISwim s = d; //现在只能使用接口定义的Swim()方法 s.Swim(); //将Duck对象赋给另一个实现的接口IFood接口变量 IFood f = d; //现在只能使用接口定义的Cook()方法 f.Cook(); Console.ReadKey(true); &#125; &#125; //定义两个接口 public interface ISwim &#123; void Swim(); &#125; public interface IFood &#123; void Cook(); &#125; //定义一个抽象类 public abstract class Bird &#123; public abstract void Fly(); &#125; //继承自一个抽象类，实现两个接口 public class Duck : Bird, IFood, ISwim &#123; //实现ISwim接口 public void Swim() &#123; Console.WriteLine("是鸭子就会游泳"); &#125; //实现IFood接口 public void Cook() &#123; Console.WriteLine("鸭子经常被烧烤，北京烤鸭就很有名"); &#125; //实现抽象类Bird中的抽象方法 public override void Fly() &#123; Console.WriteLine("只有野鸭才会飞"); &#125; &#125;&#125; 接口小结 多态继承多态现实世界中的多态 面向对象中的多态 真正的多态代码-针对基类编程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960namespace Fruit&#123; class Program &#123; static void Main(string[] args) &#123; //ShowPolymorphism(); CallPolymorphismMethod(); Console.ReadKey(); &#125; static void ShowPolymorphism() &#123; Fruit f; f = new Apple(); //这句输出什么？ f.GrowInArea(); f = new Pineapple(); //与前面相同的代码，输出什么？ f.GrowInArea(); &#125; /// &lt;summary&gt; /// 使用了“多态”特性的方法，其代码具有稳定性，与具体子类无关 /// 此方法用于显示特定水果的“适宜种植区域”信息 /// &lt;/summary&gt; /// &lt;param name="fruit"&gt;&lt;/param&gt; static void ShowFruitGrowInAreaInfo(Fruit fruit) &#123; fruit.GrowInArea(); &#125; /// &lt;summary&gt; /// 多态代码的典型用法： /// 在运行时动态地传递对象给它 /// &lt;/summary&gt; static void CallPolymorphismMethod() &#123; ShowFruitGrowInAreaInfo(new Apple()); ShowFruitGrowInAreaInfo(new Pineapple()); &#125; &#125; abstract class Fruit //抽象类 &#123; public abstract void GrowInArea(); //抽象方法 &#125; class Apple : Fruit //苹果 &#123; public override void GrowInArea() &#123; Console.WriteLine("我是苹果，南方北方都可以种植我。"); &#125; &#125; class Pineapple : Fruit //菠萝 &#123; public override void GrowInArea() &#123; Console.WriteLine("我是菠萝，喜欢温暖，只能在南方看到我。"); &#125; &#125;&#125; 多态示例-动物园 面向对象建模 引入继承重构 再次重构 1234567891011121314151617181920212223242526272829303132namespace Zoo3&#123; abstract class Animal &#123; public abstract void eat(); &#125; //狮子 class Lion : Animal &#123; public override void eat() &#123; Console.WriteLine("我是狮子，我不吃肉谁敢吃肉！"); &#125; &#125; //猴子 class Monkey : Animal &#123; public override void eat() &#123; Console.WriteLine("我是猴子，我喜欢偷吃香蕉！"); &#125; &#125; //鸽子 class Pigeon : Animal &#123; public override void eat() &#123; Console.WriteLine("我是一只漂亮的鸽子，为了维持优美的体形，我每餐只吃几粒大米！"); &#125; &#125;&#125; 12345678910111213141516namespace Zoo3&#123; //动物园饲养员 class Feeder &#123; public String Name; //喂养一群动物 public void FeedAnimals(IEnumerable&lt;Animal&gt; ans) &#123; foreach (Animal an in ans) &#123; an.eat(); &#125; &#125; &#125;&#125; 12345678910111213141516171819namespace Zoo3&#123; class Program &#123; static void Main(string[] args) &#123; //动物数组 var ans = new List&lt;Animal&gt; &#123; new Monkey(), new Pigeon(), new Lion() &#125;; Feeder f = new Feeder(); f.Name = "小李"; //喂养一群动物 f.FeedAnimals(ans); &#125; &#125;&#125; 多态的好处 多态的实现方式 异常处理机制什么是异常 异常基础 异常处理 Exception是最顶层的异常基类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051namespace ExceptionDemo&#123; class Program &#123; static void Main(string[] args) &#123; //WhatIsException(); InputNumber(); Console.ReadKey(); &#125; static void WhatIsException() &#123; int i = 100, j = 0; Console.WriteLine(i / j); &#125; private static void InputNumber() &#123; Console.Write("请输入一个正整数："); try &#123; //尝试着将用户输入的字符串转换为整数 int value = Convert.ToInt32(Console.ReadLine()); if (value &lt;= 0) &#123; //发现非法的数据，“主动”抛出一个异常 throw new InvalidOperationException("你输入的不是正整数！"); &#125; Console.WriteLine("您输入的数字是：&#123;0&#125;", value); &#125; catch (FormatException) &#123; Console.WriteLine("输入的字符串无法转换为数字"); &#125; catch (OverflowException) &#123; Console.WriteLine("你输入的数字太大了！"); &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); &#125; finally &#123; Console.WriteLine("敲任意键退出……"); &#125; &#125; &#125;&#125; 异常基类的重要属性和方法 123456789101112131415161718192021222324namespace ExceptionInfo&#123; class Program &#123; static void Main(string[] args) &#123; try &#123; int[] values = new int[10]; for (int i = 1; i &lt;= 10; i++) Console.WriteLine(values[i]); &#125; catch (Exception e) &#123; Console.WriteLine("在输出values数组值时发生数组越界错误"); Console.WriteLine("异常种类:" + e.GetType().Name); Console.WriteLine("系统给出的出错信息：" + e.Message); Console.WriteLine("系统调用堆栈信息:" + e.StackTrace); Console.WriteLine("引发此错误的方法：" + e.TargetSite); &#125; Console.ReadKey(); &#125; &#125;&#125; 基类库常用异常类型 创建自己的异常类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091namespace ExceptionLinkInRealWorld&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine("程序从Main()方法开始运行……\n"); try &#123; throwExceptionMethod(); //有可能抛出异常的方法调用 &#125; catch (MyException e) &#123; Console.WriteLine("在Main()方法中捕获到MyException异常，其Message属性值为：&#123;0&#125;",e.Message); &#125; catch (Exception e) &#123; Console.WriteLine("在Main()方法中捕获到Exception异常，其Message属性值为：&#123;0&#125;", e.Message); &#125; doesNotThrowException(); //不抛出异常的方法调用 Console.WriteLine("\nMain()方法运行结束，敲任意键退出……"); Console.ReadKey(); &#125; /// &lt;summary&gt; /// 自己虽然捕获了异常，但仍然希望外部进一步地处理，因此在简单地 /// 捕获并处理老异常之后，再抛出一个新的异常供本方法的调用者进行捕获。 /// &lt;/summary&gt; public static void throwExceptionMethod() &#123; try &#123; Console.WriteLine("throwExceptionMethod()方法开始执行"); Console.WriteLine("throwExceptionMethod()方法抛出了一个异常"); // 模拟产生一个异常 throw new Exception("系统运行时引发的Exception异常"); &#125; catch (Exception e) &#123; Console.WriteLine("throwExceptionMethod方法捕获并处理了抛出的Exception异常，并将其转换为一个自定义MyException异常再抛出", e); //转换为一个自定义异常，再抛出 throw new MyException("在throwExceptionMethod()方法执行时出现MyException异常",e); &#125; finally &#123; Console.WriteLine("throwExceptionMethod()方法中的finally语句块执行结束\n"); &#125; &#125; /// &lt;summary&gt; /// 自己能完全处理异常，不需要外界参与 /// &lt;/summary&gt; public static void doesNotThrowException() &#123; try &#123; Console.WriteLine("\ndoesNotThrowException()方法开始执行"); Console.WriteLine("doesNotThrowException()方法虽然包容try/catch/finally，但不会抛出任何异常"); &#125; catch (Exception e) &#123; Console.WriteLine(e.Message); &#125; finally &#123; Console.WriteLine("执行doesNotThrowException()方法中的finally语句块"); &#125; Console.WriteLine("doesNotThrowException()方法运行结束。\n"); &#125; &#125; class MyException : Exception &#123; //重载的构造函数--调用基类构造函数 public MyException(String Message) : base(Message) &#123; &#125; public MyException(string Message, Exception InnerException) : base(Message, InnerException) &#123; &#125; &#125;&#125; 异常处理链 嵌套的异常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192namespace EmbedException&#123; #region "自定义异常类型" class ExceptionA : Exception &#123; &#125; class ExceptionB : Exception &#123; &#125; class ExceptionC : Exception &#123; &#125; #endregion class Program &#123; static void Main(string[] args) &#123; try //Level1 &#123; Console.WriteLine("进入Level1的try语句块"); try //Level2 &#123; Console.WriteLine("进入Level2的try语句块"); //如果在Level3代码执行之前（和之后）出现异常，Level3的finally语句块还会执行吗？ //throw new ExceptionB(); try //Level3 &#123; Console.WriteLine("进入Level3的try语句块"); //to do:每次抛出一种异常，注释掉其余的语句，然后观察输出结果 //throw new ExceptionA(); //throw new ExceptionB(); //throw new ExceptionC(); //throw new InvalidOperationException(); Console.WriteLine("退出Level3的try语句块"); &#125; catch (ExceptionA) //Level3 &#123; Console.WriteLine("在Level3中处理ExceptionA。"); &#125; finally //Level3 &#123; Console.WriteLine("Level3中的finally语句块"); WriteMessageToFile("Level3.txt", "Level3中的finally语句块"); &#125; //throw new ExceptionB(); Console.WriteLine("退出Level2的try语句块"); &#125; catch (ExceptionB) &#123; Console.WriteLine("在Level2中处理ExceptionB"); &#125; finally &#123; Console.WriteLine("Level2中的finally语句块"); WriteMessageToFile("Level2.txt", "Level2中的finally语句块"); &#125; Console.WriteLine("退出Level1的try语句块"); &#125; catch (ExceptionC) &#123; Console.WriteLine("在Level1中处理ExceptionC "); &#125; //当示例抛出注释InvalidOperationException时，注释掉此块，查看CLR的异常处理策略 catch (Exception) &#123; Console.WriteLine("在Level1中处理Exception "); &#125; finally &#123; Console.WriteLine("Level1中的finally语句块"); WriteMessageToFile("Level1.txt", "Level1中的finally语句块"); &#125; Console.ReadKey();//程序暂停 &#125; /// &lt;summary&gt; /// 将异常信息写入到文件中，以备日后查询 /// &lt;/summary&gt; /// &lt;param name="FileName"&gt;&lt;/param&gt; /// &lt;param name="Message"&gt;&lt;/param&gt; private static void WriteMessageToFile(string FileName,string Message) &#123; FileStream fs = new FileStream(FileName, FileMode.Create); StreamWriter sw = new StreamWriter(fs); sw.Write(Message); sw.Close(); fs.Close(); &#125; &#125; &#125; 异常处理与捕获基本策略 异常处理的建议 泛型编程为什么使用泛型 泛型定义方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154namespace frmGPExample1&#123; public partial class frmGPExample1 : Form &#123; public frmGPExample1() &#123; InitializeComponent(); &#125;#region "变量区" //两个将要被排序的数组 char[] CharArray=new Char[10]; int[] IntArray=new int[10]; //整数数组元素中的最大最小值 private int MaxInt, MinInt; //字符数组元素中的最大最小值 private char MaxChar, MinChar;#endregion //用随机数据填充数组,并显示在列表框中 private void FillArray() &#123; int i = 0; Random ran = new Random(); lstData.Items.Clear(); if (rdoInteger.Checked) &#123; //获取指定维数最后一个元素的索引 for (i = 0; i &lt;= IntArray.GetUpperBound(0); i++) &#123; IntArray[i] = ran.Next(0, 100); lstData.Items.Add(IntArray[i]); &#125; &#125; if (rdoChar.Checked) &#123; for (i = 0; i &lt;= CharArray.GetUpperBound(0); i++) &#123; int charCode = ran.Next(0, 26); CharArray[i] = (char)(charCode + 'A'); lstData.Items.Add(CharArray[i] + " :ASC码值＝" + Convert.ToString((int)(CharArray[i]))); &#125; &#125; &#125; //显示结果： private void ShowResult() &#123; if (rdoInteger.Checked ) &#123; lblMax.Text = "最大值：" + MaxInt; lblMin.Text = "最小值：" + MinInt; &#125; if (rdoChar.Checked ) &#123; lblMax.Text = "最大值：" + MaxChar; lblMin.Text = "最小值：" + MinChar; &#125; &#125;#region "普通方法" //在整数数组中查找最大最小值 private void GetMaxMinValueFromIntArray(int[] datas) &#123; MaxInt = datas[0]; MinInt = datas[0]; for (int i= 1 ;i&lt;= IntArray.GetUpperBound(0);i++) &#123; if (MaxInt &lt; datas[i]) MaxInt = datas[i]; if( MinInt &gt; datas[i]) MinInt = datas[i]; &#125; &#125; //在字符数组中查找最大最小值 private void GetMaxMinValueFromCharArray(char [] datas ) &#123; MaxChar = datas[0]; MinChar = datas[0]; for (int i = 1;i&lt;= IntArray.GetUpperBound(0);i++) &#123; if (MaxChar &lt; datas[i] ) MaxChar = datas[i]; if (MinChar &gt; datas[i] ) MinChar = datas[i]; &#125; &#125; private void OnButtonClick1()&#123; //填充数组 FillArray(); if (rdoInteger.Checked ) GetMaxMinValueFromIntArray(IntArray); if (rdoChar.Checked ) GetMaxMinValueFromCharArray(CharArray); //显示数据处理结果 ShowResult(); &#125;#endregion#region "泛型方法版本" private void GetMaxMinVauleFromArray&lt;T&gt;(T[] datas , ref T Max ,ref T Min) where T:IComparable &#123; Max = datas[0]; Min = datas[0]; for(int i = 1 ;i&lt;=IntArray.GetUpperBound(0);i++) &#123; if( Max.CompareTo(datas[i])&lt;0) Max = datas[i]; if (Min.CompareTo(datas[i])&gt;0) Min = datas[i]; &#125; &#125; private void OnButtonClick2() &#123; //填充数组 FillArray(); //根据用户选项填充对应的数组 if( rdoInteger.Checked ) GetMaxMinVauleFromArray&lt;int&gt;(IntArray, ref MaxInt,ref MinInt); if (rdoChar.Checked ) GetMaxMinVauleFromArray&lt;char&gt;(CharArray,ref MaxChar, ref MinChar); //显示数据处理结果 ShowResult(); &#125;#endregion private void btnExit_Click(object sender, EventArgs e) &#123; Application.Exit(); &#125; private void btnFillArray_Click(object sender, EventArgs e) &#123; OnButtonClick1();//普通版本 //OnButtonClick2();//泛型方法版本 &#125; &#125;&#125; 泛型编程基础泛型类编写方法 设定参数约束 常用参数约束 编写泛型方法 泛型类和方法实例 12345678910111213141516171819202122232425262728293031323334namespace MaxMinValueForGP2&#123; class ComplexNum:IComparable&lt;ComplexNum&gt; &#123; public double a;//实部 public double b ;//虚部 public ComplexNum(double aValue , double bValue ) &#123; a = aValue; b = bValue; &#125; //按复数标准形式返回a+bi形式的字串 public override String ToString() &#123; return (a.ToString() + "+" + b.ToString() + "i"); &#125; //求复数的模 public double GetMod() &#123; return Math.Sqrt(a * a + b * b); &#125; //按模比较两个复数的大小 int IComparable&lt;ComplexNum&gt;.CompareTo(ComplexNum other ) &#123; if (Math.Abs(GetMod() - other.GetMod()) &lt; 0.000001 ) return 0; if( GetMod() &gt; other.GetMod() ) return 1; else return -1; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738namespace MaxMinValueForGP2&#123; /// &lt;summary&gt; /// 使用泛型类封装算法 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; public class MaxMin&lt;T&gt; where T : IComparable&lt;T&gt; &#123; //处理数据，获取最大值最小值 public static Pair&lt;T&gt; GetMaxMinVauleFromArray(T[] arr) &#123; Pair&lt;T&gt; ret; ret.Max = arr[0]; ret.Min = arr[0]; for (int i = 1; i &lt;= arr.GetUpperBound(0); i++) &#123; if (ret.Max.CompareTo(arr[i]) &lt; 0) ret.Max = arr[i]; if (ret.Min.CompareTo(arr[i]) &gt; 0) ret.Min = arr[i]; &#125; return ret; &#125; &#125; /// &lt;summary&gt; /// 使用泛型struct封装数据处理结果 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; public struct Pair&lt;T&gt; &#123; public T Max; public T Min; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788namespace MaxMinValueForGP2&#123; public partial class frmGPExample2 : Form &#123; public frmGPExample2() &#123; InitializeComponent(); &#125; /// &lt;summary&gt; /// 三个字段，引用被处理的三种类型的数组 /// &lt;/summary&gt; private char[] CharArray = new char[10]; private int[] IntArray = new int[10]; private ComplexNum[] ComplexArray = new ComplexNum[10]; private void OnButtonClick() &#123; //填充数组 FillArray(); if (rdoInteger.Checked) ShowResult&lt;int&gt;(MaxMin&lt;int&gt;.GetMaxMinVauleFromArray(IntArray)); if (rdoChar.Checked) ShowResult&lt;char&gt;(MaxMin&lt;char&gt;.GetMaxMinVauleFromArray(CharArray)); if (rdoComplex.Checked) ShowResult&lt;ComplexNum&gt;(MaxMin&lt;ComplexNum&gt;.GetMaxMinVauleFromArray(ComplexArray)); &#125; /// &lt;summary&gt; /// 使用泛型方法显示数据处理结果 /// &lt;/summary&gt; /// &lt;typeparam name="T"&gt;&lt;/typeparam&gt; /// &lt;param name="ret"&gt;&lt;/param&gt; private void ShowResult&lt;T&gt;(Pair&lt;T&gt; ret) &#123; lblMax.Text = "最大值：" + ret.Max.ToString(); lblMin.Text = "最小值：" + ret.Min.ToString(); &#125; //用随机数据填充数组,并显示在列表框中 private void FillArray() &#123; int i; Random ran = new Random(); lstData.Items.Clear(); if (rdoInteger.Checked) for (i = 0; i &lt;= IntArray.GetUpperBound(0); i++) &#123; IntArray[i] = ran.Next(0, 100); lstData.Items.Add(IntArray[i]); &#125; if (rdoChar.Checked) for (i = 0; i &lt;= CharArray.GetUpperBound(0); i++) &#123; int charCode; charCode = ran.Next(0, 26); CharArray[i] = (char)('A' + charCode); lstData.Items.Add(CharArray[i].ToString() + " :ASC码值＝" + ((int)CharArray[i]).ToString()); &#125; int a, b; if (rdoComplex.Checked) for (i = 0; i &lt;= ComplexArray.GetUpperBound(0); i++) &#123; a = ran.Next(0, 10); b = ran.Next(0, 10); ComplexArray[i] = new ComplexNum(a, b); lstData.Items.Add(ComplexArray[i].ToString() + " 模＝" + ComplexArray[i].GetMod().ToString()); &#125; &#125; private void btnFillArray_Click(object sender, EventArgs e) &#123; OnButtonClick();//泛型类版本 &#125; private void btnExit_Click(object sender, EventArgs e) &#123; Application.Exit(); &#125; &#125;&#125; 泛型接口 泛型接口的使用 使用泛型的好处 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394namespace UseGenericExampleForCS&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; long beginTime, endTime, usedTime;//代码运行时间 //用于测试的集合 ArrayList arr1 = new ArrayList(); List&lt;long&gt; arr2 = new List&lt;long&gt;(); //加入集合的元素个数 private const int ElementCounters = 5000000; //提示信息 String strInfo = "&#123;0&#125;,运行时间：&#123;1&#125; ticks" + Environment.NewLine; private void AddElement() &#123; //起始时间 beginTime = Environment.TickCount; //清除原有数据 arr1.Clear(); arr2.Clear(); //向集合中加入元素 for (int i = 0; i &lt; ElementCounters; i++) if (rdoArrayList.Checked) arr1.Add(i); //非泛型版本 else arr2.Add(i); endTime = Environment.TickCount; usedTime = endTime - beginTime; if (rdoArrayList.Checked) txtInfo.Text += String.Format(strInfo, "向集合中加入元素：" + ElementCounters + "个" , usedTime); else txtInfo.Text += String.Format(strInfo, "向泛型集合中加入元素：" + ElementCounters + "个", usedTime); &#125; private void SumElement() &#123; //起始时间 beginTime = Environment.TickCount; //清除原有数据 arr1.Clear(); arr2.Clear(); //向集合中加入元素 int i ; for (i = 0 ;i&lt; ElementCounters;i++) if (rdoArrayList.Checked ) arr1.Add(i); //非泛型版本 else arr2.Add(i); //求和 long ret=0; for (i = 0;i&lt; ElementCounters;i++) if (rdoArrayList.Checked ) ret += Convert.ToInt64( arr1[i]); //非泛型版本 else ret += arr2[i]; endTime =Environment.TickCount; usedTime = endTime - beginTime; if (rdoArrayList.Checked) txtInfo.Text += String.Format(strInfo, "对集合" + ElementCounters.ToString() + "个元素求和：" + ret , usedTime); else txtInfo.Text += String.Format(strInfo, "对泛型集合" + ElementCounters.ToString() + "个元素求和：" + ret , usedTime); &#125; private void btnAddElement_Click(object sender, EventArgs e) &#123; AddElement(); &#125; private void btnSumElement_Click(object sender, EventArgs e) &#123; SumElement(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>.NET Framework</category>
        <category>基础入门到进阶-金旭亮</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Winform软件开发技术基础]]></title>
    <url>%2F2019%2F02%2F21%2FWinform%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[掌握桌面程序开发、熟悉常用的控件 使用VisualStudio 编写GUI程序本博客内容由金旭亮老师网上上传的文档制作，在此特地感谢！ GUI应用程序简介 使用VisualStudio设计可视化桌面应用 快速应用开发模式 常用Winform控件使用 按钮控件 设计带图标的按钮 资源的使用 使用资源后需要注意的属性 标签控件 文本控件 进度条和小闹钟控件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071namespace ProgressBarAndTimer&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); ShowProgressBarValue(AutoProgressBar.Value); &#125; private void ShowProgressBarValue(int value) &#123; lblInfo.Text = string.Format("&#123;0&#125;%", value); &#125; #region "事件响应" private void btnIncrease_Click(object sender, EventArgs e) &#123; if (ManualProgressBar.Value + 2 &gt; ManualProgressBar.Maximum) &#123; ManualProgressBar.Value = ManualProgressBar.Maximum; &#125; else &#123; ManualProgressBar.Value += 2; &#125; &#125; private void btnDecrease_Click(object sender, EventArgs e) &#123; if (ManualProgressBar.Value - 2 &lt; ManualProgressBar.Minimum) &#123; ManualProgressBar.Value = ManualProgressBar.Minimum; &#125; else &#123; ManualProgressBar.Value -= 2; &#125; &#125; private void timer1_Tick(object sender, EventArgs e) &#123; if (AutoProgressBar.Value + 2 &gt; AutoProgressBar.Maximum) &#123; //自动回头 AutoProgressBar.Value = 0; &#125; else &#123; AutoProgressBar.Value += 2; &#125; ShowProgressBarValue(AutoProgressBar.Value); &#125; private void btnTimer_Click(object sender, EventArgs e) &#123; timer1.Enabled = !timer1.Enabled; if (timer1.Enabled == true) &#123; btnTimer.Image = Resources.DisableClock; &#125; else &#123; btnTimer.Image = Resources.EnableClock; &#125; &#125; #endregion &#125;&#125; 控件学习指导 通用属性学会学习 控件Anchor属性 控件Dock属性 12345678910111213141516171819202122232425262728293031323334353637383940namespace FormCtrlProperty&#123; public partial class frmDock : Form &#123; public frmDock() &#123; InitializeComponent(); &#125; private void rdoNone_CheckedChanged(object sender, EventArgs e) &#123; button1.Dock = DockStyle.None; &#125; private void rdoLeft_CheckedChanged(object sender, EventArgs e) &#123; button1.Dock = DockStyle.Left; &#125; private void rdoRight_CheckedChanged(object sender, EventArgs e) &#123; button1.Dock = DockStyle.Right; &#125; private void rdoTop_CheckedChanged(object sender, EventArgs e) &#123; button1.Dock = DockStyle.Top; &#125; private void rdoBottom_CheckedChanged(object sender, EventArgs e) &#123; button1.Dock = DockStyle.Bottom; &#125; private void rdoFill_CheckedChanged(object sender, EventArgs e) &#123; button1.Dock = DockStyle.Fill; &#125; &#125;&#125; 控件容器 面板Panel 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374namespace ContainerDemo&#123; public partial class frmPanel : Form &#123; public frmPanel() &#123; InitializeComponent(); &#125; private void btnShowOrHide_Click(object sender, EventArgs e) &#123; if (rdoOuter.Checked) &#123; pnlOuter.Visible = !pnlOuter.Visible; &#125; else &#123; pnlInner.Visible = !pnlInner.Visible; &#125; ChangebtnShowOrHideText(); &#125; private void btnEnableOrDisable_Click(object sender, EventArgs e) &#123; if (rdoOuter.Checked) &#123; pnlOuter.Enabled = !pnlOuter.Enabled; &#125; else &#123; pnlInner.Enabled = !pnlInner.Enabled; &#125; ChangebtnEnableOrDisableText(); &#125; private void ChangebtnShowOrHideText() &#123; if (rdoOuter.Checked) &#123; btnShowOrHide.Text = pnlOuter.Visible ? "隐藏" : "显示"; &#125; else &#123; btnShowOrHide.Text = pnlInner.Visible ? "隐藏" : "显示"; &#125; &#125; private void ChangebtnEnableOrDisableText() &#123; if (rdoOuter.Checked) &#123; btnEnableOrDisable.Text = pnlOuter.Enabled ? "禁用" : "激活"; &#125; else &#123; btnEnableOrDisable.Text = pnlInner.Enabled ? "禁用" : "激活"; &#125; &#125; private void rdoOuter_CheckedChanged(object sender, EventArgs e) &#123; ChangebtnEnableOrDisableText(); ChangebtnShowOrHideText(); &#125; private void rdoInner_CheckedChanged(object sender, EventArgs e) &#123; ChangebtnEnableOrDisableText(); ChangebtnShowOrHideText(); &#125; &#125;&#125; 组合框GropBox 选项卡TabControl 1234567891011121314151617181920212223242526272829303132333435363738394041namespace ContainerDemo&#123; public partial class frmTabControl : Form &#123; public frmTabControl() &#123; InitializeComponent(); tabCount = tabControl1.TabPages.Count; &#125; private int tabCount = 0; private Random ran = new Random(); private void btnAddTab_Click(object sender, EventArgs e) &#123; tabCount++; TabPage newPage = new TabPage("tabPage" + tabCount); newPage.BackColor = Color.FromArgb( ran.Next(0,255), ran.Next(0,255), ran.Next(0,255)); tabControl1.TabPages.Add(newPage); &#125; private void btnActiveLeft_Click(object sender, EventArgs e) &#123; if (tabControl1.SelectedIndex != 0) &#123; tabControl1.SelectTab(tabControl1.SelectedIndex - 1); &#125; &#125; private void btnActiveRight_Click(object sender, EventArgs e) &#123; if (tabControl1.SelectedIndex != tabControl1.TabPages.Count - 1) &#123; tabControl1.SelectTab(tabControl1.SelectedIndex + 1); &#125; &#125; &#125;&#125; 容器控件布局窗体分割条面板SplitContainer FlowLayout控件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253namespace LayoutDemos&#123; public partial class frmFlowLayout : Form &#123; public frmFlowLayout() &#123; InitializeComponent(); &#125; private int counter = 0; private void btnAddButton_Click(object sender, EventArgs e) &#123; counter++; Button btn = new Button(); btn.Text = "按钮" + counter; flowLayoutPanel1.Controls.Add(btn); &#125; private void chkWrapContents_CheckedChanged(object sender, EventArgs e) &#123; flowLayoutPanel1.WrapContents = chkWrapContents.Checked; &#125; private void chkAutoScroll_CheckedChanged(object sender, EventArgs e) &#123; flowLayoutPanel1.AutoScroll = chkAutoScroll.Checked; &#125; private void cboFlowDirection_SelectedIndexChanged(object sender, EventArgs e) &#123; switch (cboFlowDirection.Text) &#123; case "BottomUp": flowLayoutPanel1.FlowDirection = FlowDirection.BottomUp; break; case "LeftToRight": flowLayoutPanel1.FlowDirection = FlowDirection.LeftToRight; break; case "RightToLeft": flowLayoutPanel1.FlowDirection = FlowDirection.RightToLeft; break; case "TopDown": flowLayoutPanel1.FlowDirection = FlowDirection.TopDown; break; default: break; &#125; &#125; &#125;&#125; TabelLayoutPanel 复杂一些的控件对话框 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071namespace DialogDemo&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private void btnOpenFile_Click(object sender, EventArgs e) &#123; openFileDialog1.Title = "选择一张图片"; openFileDialog1.Filter = "所有支持的图片文件|*.jpg;*.gif;*.png;*.bmp|任意文件（*.*）|*.*"; openFileDialog1.FileName = ""; openFileDialog1.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures); openFileDialog1.CheckFileExists = true; openFileDialog1.CheckPathExists = true; //是否允许选择多个文件 //openFileDialog1.Multiselect = false; openFileDialog1.Multiselect = true; if (openFileDialog1.ShowDialog() == DialogResult.OK) &#123; if (openFileDialog1.Multiselect == false) &#123; lblInfo.Text = openFileDialog1.FileName; &#125; else &#123; StringBuilder sb = new StringBuilder(); foreach (var file in openFileDialog1.FileNames) &#123; sb.Append(file); sb.Append("\n"); &#125; lblInfo.Text = sb.ToString(); &#125; &#125; &#125; private void btnSaveFile_Click(object sender, EventArgs e) &#123; //设置默认文件扩展名 saveFileDialog1.DefaultExt = ".txt"; //指定文件名存在，是否提示警告 saveFileDialog1.OverwritePrompt = true; saveFileDialog1.Title = "保存文件"; if (saveFileDialog1.ShowDialog() == DialogResult.OK) &#123; lblInfo.Text = "文件己保存到：" + saveFileDialog1.FileName; &#125; &#125; private void btnFontDialog_Click(object sender, EventArgs e) &#123; if (fontDialog1.ShowDialog() == DialogResult.OK) &#123; lblInfo.Font = fontDialog1.Font; &#125; &#125; private void btnColor_Click(object sender, EventArgs e) &#123; if (colorDialog1.ShowDialog() == DialogResult.OK) &#123; lblInfo.ForeColor = colorDialog1.Color; &#125; &#125; &#125;&#125; 下拉菜单 弹出式菜单：例如鼠标点右键 弹出式菜单 1234567891011121314151617181920212223242526272829303132333435363738394041424344namespace MenuDemo&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private void mnuExit_Click(object sender, EventArgs e) &#123; Close(); &#125; private void menuOpen_Click(object sender, EventArgs e) &#123; openFileDialog1.ShowDialog(); &#125; private void btnEnable_Click(object sender, EventArgs e) &#123; FileMenuItem.Enabled = !FileMenuItem.Enabled; &#125; private int SaveCount = 0; private void mnuSave_Click(object sender, EventArgs e) &#123; SaveCount++; mnuSave.Text = string.Format("保存(&#123;0&#125;)", SaveCount); &#125; private void btnExchange_Click(object sender, EventArgs e) &#123; menuStripEdit.Visible = !menuStripEdit.Visible; menuStripFile.Visible = !menuStripFile.Visible; &#125; private void buttonShowContextMenu_Click(object sender, EventArgs e) &#123; //相对于指定控件定位 contextMenuStripExample.Show(sender as Control,20,25); &#125; &#125;&#125; 状态条 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556namespace StatusStripDemo&#123; public partial class frmStatusStrip : Form &#123; public frmStatusStrip() &#123; InitializeComponent(); &#125; private void btnShowTime_Click(object sender, EventArgs e) &#123; timerForCurrentTime.Enabled = !timerForCurrentTime.Enabled; &#125; private void timer1_Tick(object sender, EventArgs e) &#123; toolStripStatusLabel1.Text = DateTime.Now.ToLongTimeString(); &#125; private void ToolStripMenuItem1_Click(object sender, EventArgs e) &#123; MessageBox.Show("菜单项一"); &#125; private void ToolStripMenuItem2_Click(object sender, EventArgs e) &#123; MessageBox.Show("菜单项二"); &#125; private void ToolStripMenuItem3_Click(object sender, EventArgs e) &#123; MessageBox.Show("菜单项三"); &#125; private void btnShowProgress_Click(object sender, EventArgs e) &#123; toolStripProgressBar1.Visible = true; toolStripProgressBar1.Value = 0; timerForProgress.Enabled = true; btnShowProgressBar.Enabled = false; &#125; private void timerForProgress_Tick(object sender, EventArgs e) &#123; if (toolStripProgressBar1.Value &lt; 100) toolStripProgressBar1.Value += 5; else &#123; toolStripProgressBar1.Visible = false; timerForProgress.Enabled = false; btnShowProgressBar.Enabled = true; &#125; &#125; &#125;&#125; 树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109namespace TreeDemo&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private void btnNewTopNode_Click(object sender, EventArgs e) &#123; string NodeText = ""; if (!string.IsNullOrEmpty(txtNewNodeText.Text.Trim())) &#123; NodeText = txtNewNodeText.Text; &#125; else &#123; NodeText = "新根节点" + (treeView1.GetNodeCount(true) + 1); &#125; treeView1.Nodes.Add(NodeText); &#125; private void btnAddBrotherNode_Click(object sender, EventArgs e) &#123; string NodeText = ""; if (treeView1.SelectedNode != null &amp;&amp; treeView1.SelectedNode.Parent!=null) &#123; if (!string.IsNullOrEmpty(txtNewNodeText.Text.Trim())) &#123; NodeText = txtNewNodeText.Text; &#125; else &#123; NodeText = "新兄弟节点" + (treeView1.GetNodeCount(true) + 1); &#125; treeView1.SelectedNode.Parent.Nodes.Add(NodeText); &#125; &#125; private void btnAddChildNode_Click(object sender, EventArgs e) &#123; string NodeText = ""; if (treeView1.SelectedNode != null) &#123; if (!string.IsNullOrEmpty(txtNewNodeText.Text.Trim())) &#123; NodeText = txtNewNodeText.Text; &#125; else &#123; NodeText = "新子节点" + (treeView1.GetNodeCount(true) + 1); &#125; treeView1.SelectedNode.Nodes.Add(NodeText); treeView1.SelectedNode.Expand(); &#125; &#125; private void btnDeleteNode_Click(object sender, EventArgs e) &#123; if (treeView1.SelectedNode != null) &#123; if (treeView1.SelectedNode.Parent != null) &#123; treeView1.SelectedNode.Parent.Nodes.Remove(treeView1.SelectedNode); &#125; else &#123; treeView1.Nodes.Remove(treeView1.SelectedNode); &#125; &#125; &#125; private void btnClearTreeNodes_Click(object sender, EventArgs e) &#123; treeView1.Nodes.Clear(); &#125; private void btnExpandCollapseNode_Click(object sender, EventArgs e) &#123; if (treeView1.SelectedNode != null) &#123; if (treeView1.SelectedNode.IsExpanded) &#123; treeView1.SelectedNode.Collapse(true); &#125; else &#123; treeView1.SelectedNode.Expand(); &#125; &#125; &#125; private void treeView1_AfterSelect(object sender, TreeViewEventArgs e) &#123; txtNodeText.Text = e.Node.Text; &#125; private void btnNodeRename_Click(object sender, EventArgs e) &#123; if (txtNodeText.Text.Trim().Length &gt; 0) &#123; treeView1.SelectedNode.Text = txtNodeText.Text.Trim(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>.NET Framework</category>
        <category>基础入门到进阶-金旭亮</category>
      </categories>
      <tags>
        <tag>Winform编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#面向对象程序设计概述和基础知识]]></title>
    <url>%2F2019%2F02%2F20%2FCSharp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0%E5%92%8C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[了解C#语言历史、编程工具、运行原理、基础语法…… 本节细节点概述本博客内容由金旭亮老师网上上传的文档制作，在此特地感谢！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//了解变量的特定类型变量名.GetType()int intvalue=100;Console.Writeline(intvalue.GetType()==typeof(int))//C#语言内置类型和CLR支持的基础类型的对应关系int---System.Int32......var 关键字根据右边的具体值推断类型//数据类型占用大小"占用字节少"的可以直接赋值给"占用字节多的""占用字节多的"赋值给"占用字节少" 必须要强制转换占用相同大小内存，因为解析方式不一样，也要进行"类型转换"//表达式的概念表达式会有一个结果 没有分号 语句才有分号表达式使用场景：如 条件选择和循环语句//构建逻辑表达式的运算符&lt; &gt; == &gt;= &lt;= !=//逻辑表达式的组合&amp;&amp; || ！//多值选择结构switch (intvalue)&#123; case 0: CaseZero(); break; case 1: CaseOne(); break; default : CaseOther(); break;&#125;//break Continuebreak ：直接跳出循环continue ：跳过本次循环//foreach 循环 遍历数据集合时，不能向里面增删数据项//Console.ReadKey()方法 返回一个ConsoleKeyInfo结构可用于 检测用户输入的按键 详细下面代码//静态方法 --方法前面加 static关键字可以通过类名直接调用 而实例方法依附于具体的对象//方法的重载返回值类型不作为重载的依据//.net类库中的类生成随机数Random ran = new Random (System.Environment.TickCount);Console.Write(ran.Next(1,100));//1-100之间的随机整数 不能取到上界值//递归"自己调用自己" 开头一定时判断递归结束的条件是否满足有一个控制递归可以终结的变量(递归函数中变化)特点： 先从大到小 再从小到大//浮点数的判等问题//处理大的整数 .NET 4.0 提供了BigInteger 类 需要引用 System.Numerics C#与.NET来世今生C#语言编程史 Windows与.NET技术发展的历程及趋势 什么是.NET 使用VisualStudio编程工具认识Visual Studio Console的重要属性 控制台窗口的输入与输出 ReadKey和Beep 程序调试基本技巧 C#与Visual Studio编程须知基本编程规则 文件组织方式 行号、颜色、字体大小 面向对象概述与.NET运行原理面向对象编程概述 程序是如何被计算机执行的？ 如何编写计算机可以执行的程序？ 怎样构造求解问题的算法？ 日期计算结构化编程的实现 日期计算面向对象编程的实现 变量、数据类型与表达式理解变量 数据类型 String和Var 变量与内存 数据类型转换 运算符与表达式 选择结构与逻辑表达式 if/else 选择结构 选择结构的嵌套 逻辑表达式的组合 多分支结构 循环结构 while/do 循环 12345678910111213141516static void InputQuitToStop() &#123; string userInput = ""; while (userInput.ToLower() != "quit") &#123; Console.WriteLine("\n不断输入字符串，回车结束一次输入。不想再运行程序时，输入quit。"); userInput = Console.ReadLine(); if (string.IsNullOrEmpty(userInput) == false) &#123; Console.WriteLine("您输入了：&#123;0&#125;", userInput); &#125; &#125; Console.WriteLine("\n---------------------------------------------"); Console.WriteLine("\n检测到quit命令，循环中止，敲任意键退出……"); &#125; for循环 Break和Continue 1234567891011121314151617/// &lt;summary&gt;/// 理解Break和Continue的不同作用/// &lt;/summary&gt;static void BreakAndContinue()&#123; for (int i = 1; i &lt;= 10; i++) &#123; if (i == 5) &#123; //切换以下两句的注释，体会它们的不同作用 //continue; break; &#125; Console.WriteLine("第&#123;0&#125;轮循环", i); &#125;&#125; foreach循环 控制台程序编程小技巧 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//测试如何检测按键 static void testKey() &#123; Console.WriteLine("随意敲任意键查看其键值，压ESC退出"); ConsoleKeyInfo key; do &#123; //用户敲了按键了吗？ while (!Console.KeyAvailable) &#123; //啥也不干，等待…… &#125; //等待用户击键 key = Console.ReadKey(true); Console.WriteLine();//输出一个空行 Console.WriteLine("Modifiers值=&#123;0&#125;", key.Modifiers); Console.WriteLine("KeyChar值=&#123;0&#125;", (int)(key.KeyChar)); Console.WriteLine("Key值=&#123;0&#125;", key.Key); //CapsLock这个键是不能被捕获的，但我们可以检测出键盘的状态 if (Console.CapsLock) &#123; Console.WriteLine("处于大写状态"); &#125; //NumberLock这个键是不能被捕获的，但我们可以检测出键盘的状态 if (Console.NumberLock) &#123; Console.WriteLine("小键盘上的Num Lock键被按下"); &#125; //检测控制键 if (key.Modifiers != 0) &#123; if ((key.Modifiers &amp; ConsoleModifiers.Alt) != 0) &#123; Console.WriteLine("Alt键被按下"); &#125; if ((key.Modifiers &amp; ConsoleModifiers.Control) != 0) &#123; Console.WriteLine("Ctrl键被按下"); &#125; if ((key.Modifiers &amp; ConsoleModifiers.Shift) != 0) &#123; Console.WriteLine("Shift键被按下"); &#125; &#125; &#125; while (key.Key != ConsoleKey.Escape); Console.WriteLine("\n检测到ESC键，敲任意键退出……\n"); &#125; 123456789101112131415161718192021222324252627282930313233/// &lt;summary&gt;/// 展示系统内置的强制中止控制台程序的功能/// &lt;/summary&gt;static void QuitConsoleApp()&#123; Console.WriteLine("死循环：请使用Ctrl+C或Ctrl+Break强制中止本程序"); while (true) &#123; Console.WriteLine("当前时间：" + DateTime.Now.ToLocalTime()); Thread.Sleep(2000); &#125;&#125;/// &lt;summary&gt;/// 禁用Ctrl+C/// &lt;/summary&gt;static void DisableControlC()&#123; Console.WriteLine("本程序只能通过ESC键结束，无法通过Ctrl+C而中止"); Console.TreatControlCAsInput = true; do &#123; var key = Console.ReadKey(true); if (key.Key == ConsoleKey.Escape) &#123; Console.WriteLine("检测到ESC键，敲任意键退出……"); break; &#125; &#125; while (true);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445/// &lt;summary&gt; /// 响应UseCancelKeyPress事件，屏蔽掉Ctrl+C和Ctrl+Break /// &lt;/summary&gt; static void UseCancelKeyPress() &#123; Console.WriteLine("本程序只能通过ESC键结束"); //响应CancelKeyPress事件（即Ctrl+C和Ctrl+Break被按下） Console.CancelKeyPress += Console_CancelKeyPress; do &#123; var key = Console.ReadKey(true); if (key.Key == ConsoleKey.Escape) &#123; Console.WriteLine("\n检测到ESC键，敲任意键退出……"); break; &#125; if (key.KeyChar != '\0') &#123; if (key.Key == ConsoleKey.Enter) &#123; Console.WriteLine(); &#125; else &#123; Console.Write(key.KeyChar); &#125; &#125; &#125; while (true); &#125; private static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e) &#123; var isCtrlC = e.SpecialKey == ConsoleSpecialKey.ControlC; var isCtrlBreak = e.SpecialKey == ConsoleSpecialKey.ControlBreak; //如果是Ctrl+C和Ctrl+Break if (isCtrlC || isCtrlBreak) &#123; //屏蔽掉它们，让它们不起作用 e.Cancel = true; //通知用户，Ctrl+C和Ctrl+Break已经不起作用了…… Console.WriteLine(isCtrlC ? "Ctrl+C已被屏蔽" : "Ctrl+Break已被屏蔽"); &#125; &#125; 方法 方法定义与调用 方法重载 方法应用实例 123456789101112131415161718192021222324namespace ShowPicInForm&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private void LoadPicture() &#123; if (openFileDialog1.ShowDialog() == DialogResult.OK) &#123; string FileName = openFileDialog1.FileName; picImage.ImageLocation = FileName; &#125; &#125; private void btnLoadPic_Click(object sender, EventArgs e) &#123; LoadPicture(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344namespace Pseudorandom&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private float a = 3; //乘数,注意，a&gt;=2 and a&lt;m private int m = 100; //模 private float c = 4; //增量，注意，c&gt;=0 and c&lt;m //依据公式计算出下一个随机数 private float GetNextRanNumber(int m, float a, float c, float prevNum) &#123; return (a * prevNum + c) % m; &#125; //按指定的种子Seed生成nums个随机数 private void GenerateRandomSequence(int nums, float seed) &#123; float lastNum, nextNum; lastNum = seed; //清空富文本框 RichTextBox1.Clear(); //追加字符串到富文本框中 RichTextBox1.AppendText(seed.ToString()); for (int i = 0; i &lt; nums; i++) &#123; nextNum = GetNextRanNumber(m, a, c, lastNum); RichTextBox1.AppendText(" ," + nextNum); lastNum = nextNum; &#125; &#125; private void btnGenerate_Click(object sender, EventArgs e) &#123; int nums = Convert.ToInt32(txtNumbers.Text); float seed = Convert.ToSingle(txtSeed.Text); GenerateRandomSequence(nums, seed); &#125; &#125;&#125; 递归递归概述 递归编程技巧 1234567891011121314151617181920212223242526272829303132333435363738namespace CalculateN&#123; public partial class frmCalculate : Form &#123; public frmCalculate() &#123; InitializeComponent(); &#125; private void btnCalculate_Click(object sender, EventArgs e) &#123; int n = Convert.ToInt32(txtN.Text); lblResult.Text = n.ToString()+"!="+Factorial(n).ToString(); //lblResult.Text = n.ToString() + "!=" + Factorial2(n).ToString(); &#125; //计算n!，用递归实现 private long Factorial(int n) &#123; if (n == 1) return 1; long ret; ret = Factorial(n - 1) * n; return ret; &#125; //计算n!，用递推实现 private long Factorial2(int n) &#123; long result = 1; for(int i = 1; i &lt;= n; i++) &#123; result *= i; &#125; return result; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253namespace Recursion&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); &#125; private string Story = ""; //故事主体： private void WriteStory() &#123; Story = "从前有座山，山里有座庙。\n"; Story += "庙里有两个和尚，在讲故事。\n"; Story += "讲什么故事呢？……\n"; &#125; private void btnExecute_Click(object sender, EventArgs e) &#123; //清空文本 RichTextBox1.Text = ""; //老和尚开始没完没了地讲故事 DoRecursion((int)updnTimes.Value); &#125; //用于实现递归调用 private void DoRecursion(int times) &#123; //结束条件 if (times == 0) return; //每次递归调用时要完成的工作 //to do: 如果将以下这两句移到DoRecursion()一句之后， // 会发生什么？ //RichTextBox1.AppendText("第 " + times + " 次\n"); //RichTextBox1.AppendText(Story); //递归调用，参数减一 DoRecursion(times - 1); //////每次递归调用时要完成的工作 RichTextBox1.AppendText("第 " + times + " 次\n"); RichTextBox1.AppendText(Story); &#125; private void Form1_Load(object sender, EventArgs e) &#123; //把故事主体写好 WriteStory(); &#125; &#125;&#125; 处理大整数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475namespace GetFibonacciNumber&#123; public partial class frmMain : Form &#123; public frmMain() &#123; InitializeComponent(); ShowCalculateResult(); &#125; private long FibonacciUseLong(int NumberIndex) &#123; long previousValue = -1; long currentResult = 1; for (var i = 0; i &lt;= NumberIndex; ++i) &#123; if (long.MaxValue - currentResult &lt; previousValue) &#123; throw new OverflowException("超过了本计算机能计算的最大整数！"); &#125; long sum = currentResult + previousValue; previousValue = currentResult; currentResult = sum; &#125; return currentResult; &#125; private BigInteger FibonacciUseBigInteger(int NumberIndex) &#123; BigInteger previousValue = -1; BigInteger currentResult = 1; for (var i = 0; i &lt;= NumberIndex; ++i) &#123; BigInteger sum = currentResult + previousValue; previousValue = currentResult; currentResult = sum; &#125; return currentResult; &#125; /// &lt;summary&gt; /// 显示计算结果 /// &lt;/summary&gt; private void ShowCalculateResult() &#123; try &#123; if (rdoLong.Checked) lblResult.Text = FibonacciUseLong((int)numericUpDown1.Value).ToString(); else lblResult.Text = FibonacciUseBigInteger((int)numericUpDown1.Value).ToString(); &#125; catch (Exception ex) &#123; lblResult.Text = ex.Message; &#125; &#125; private void numericUpDown1_ValueChanged(object sender, EventArgs e) &#123; ShowCalculateResult(); &#125; private void radioButton1_CheckedChanged(object sender, EventArgs e) &#123; ShowCalculateResult(); &#125; private void rdoLong_CheckedChanged(object sender, EventArgs e) &#123; ShowCalculateResult(); &#125; &#125;&#125; 浮点数的处理技巧]]></content>
      <categories>
        <category>.NET Framework</category>
        <category>基础入门到进阶-金旭亮</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascrpit-正则表达式]]></title>
    <url>%2F2019%2F02%2F18%2Fjavascrpit-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[学会创建javascrip正则表达式对象，然后用于匹配、提取、替换 创建正则对象方式1： 12var reg = new RegExp('\d', 'i');var reg = new RegExp('\d', 'gi'); 方式2： 12var reg = /\d/i;var reg = /\d/gi; 参数 标志 说明 i 忽略大小写 g 全局匹配 gi 全局匹配+忽略大小写 正则匹配1234// 匹配日期var dateStr = '2015-10-10';var reg = /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/console.log(reg.test(dateStr)); 正则提取1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 &lt;script&gt; // 跟正则表达式相关的方法 // 1 RegExp对象 // test() 匹配 // exec() 提取 提取一个内容 // 2 String对象 // match() 提取 可以提取多个内容 // replace() 替换 // split() 切割 // search() var str = '张三：2500，李四：3000，王五：50000'; // var reg = /\d+/gi; // gi 全局匹配并且忽略大小写 var reg = /\d+/g; // exec() 只返回一个匹配到的结果 如果没有匹配的内容返回null--返回一个结果数组或 null。 // var content = reg.exec(str); // console.log(content); //2500 匹配完后正则表达对象会记录下一次匹配开始位置 //参考链接：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec // content = reg.exec(str); // console.log(content); //3000 // content = reg.exec(str); // console.log(content); //50000 // content = reg.exec(str); // console.log(content); //null do &#123; var content = reg.exec(str); if (content) &#123; console.log(content[0]); &#125; &#125; while(content); &lt;/script&gt;// 1. 提取工资var str = "张三：1000，李四：5000，王五：8000。";var array = str.match(/\d+/g);console.log(array);// 2. 提取email地址- . 是匹配除换行符以外的任意单个字符，所以需要加转义var str = "123123@xx.com,fangfang@valuedopinions.cn 286669312@qq.com 2、emailenglish@emailenglish.englishtown.com 286669312@qq.com...";var array = str.match(/\w+@\w+\.\w+(\.\w+)?/g);console.log(array);// 3. 分组提取 // 3. 提取日期中的年部分 2015-5-10var dateStr = '2016-1-5';// 正则表达式中的()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取var reg = /(\d&#123;4&#125;)-\d&#123;1,2&#125;-\d&#123;1,2&#125;/;if (reg.test(dateStr)) &#123; console.log(RegExp.$1);&#125;// 4. 提取邮件中的每一部分var reg = /(\w+)@(\w+)\.(\w+)(\.\w+)?/;var str = "123123@xx.com";if (reg.test(str)) &#123; console.log(RegExp.$1); console.log(RegExp.$2); console.log(RegExp.$3);&#125;// 1. 提取日期中的年部分 2015-5-10// var dateStr = '2015-1-5';// console.log(dateStr.split('-'));// var dateStr = '2015/1-5';// console.log(dateStr.split(/[/-]/));// 2. 提取邮件中的每一部分var str = 'xxxx@itcast.com';console.log(str.split(/[@\.]/)); 正则替换12345678910111213141516171819202122232425262728293031// 1. 替换所有空白var str = " 123AD asadf asadfasf adf ";str = str.replace(/\s/g,"xx");console.log(str); //xxxxxx123ADxxxxasadfxxxxxxasadfasfxxxxadfxx// 2. 替换所有,|，var str = "abc,efg,123，abc,123，a";str = str.replace(/,|，/g, ".");console.log(str); // 1. 替换所有空白// var str = " 123AD asadf asadfasf adf ";// trim() 去除前后的空格// console.log( str.trim());// replace() 只能替换掉第一个查找到的内容// console.log(str.replace(' ', 'x'));// console.log(str.replace(/\s/g, ''));//console.log(str.split(' '));//["", "", "", "123AD", "", "asadf", "", "", "", "", "asadfasf", "", "adf", ""]// console.log(str.split(' ').join(''));// 2. 把所有,和，替换为.var str = "abc,efg,123，abc,123，a";console.log(str.replace(/,|，/g, '.')); 案例：表单验证12345QQ号：&lt;input type="text" id="txtQQ"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;邮箱：&lt;input type="text" id="txtEMail"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;手机：&lt;input type="text" id="txtPhone"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;生日：&lt;input type="text" id="txtBirthday"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;姓名：&lt;input type="text" id="txtName"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 12345678910111213141516171819202122232425262728293031323334353637383940//获取文本框var txtQQ = document.getElementById("txtQQ");var txtEMail = document.getElementById("txtEMail");var txtPhone = document.getElementById("txtPhone");var txtBirthday = document.getElementById("txtBirthday");var txtName = document.getElementById("txtName");//txtQQ.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; var reg = /^\d&#123;5,12&#125;$/; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = "请输入正确的QQ号"; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125;&#125;;//txtEMailtxtEMail.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; var reg = /^\w+@\w+\.\w+(\.\w+)?$/; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = "请输入正确的EMail地址"; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125;&#125;; 表单验证部分，封装成函数： 12345678910111213141516171819var regBirthday = /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/;addCheck(txtBirthday, regBirthday, "请输入正确的出生日期");//给文本框添加验证function addCheck(element, reg, tip) &#123; element.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = tip; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125; &#125;;&#125; 通过给元素增加自定义验证属性对表单进行验证： 1234567&lt;form id="frm"&gt; QQ号：&lt;input type="text" name="txtQQ" data-rule="qq"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 邮箱：&lt;input type="text" name="txtEMail" data-rule="email"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 手机：&lt;input type="text" name="txtPhone" data-rule="phone"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 生日：&lt;input type="text" name="txtBirthday" data-rule="date"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 姓名：&lt;input type="text" name="txtName" data-rule="cn"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;&lt;/form&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 所有的验证规则var rules = [ &#123; name: 'qq', reg: /^\d&#123;5,12&#125;$/, tip: "请输入正确的QQ" &#125;, &#123; name: 'email', reg: /^\w+@\w+\.\w+(\.\w+)?$/, tip: "请输入正确的邮箱地址" &#125;, &#123; name: 'phone', reg: /^\d&#123;11&#125;$/, tip: "请输入正确的手机号码" &#125;, &#123; name: 'date', reg: /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/, tip: "请输入正确的出生日期" &#125;, &#123; name: 'cn', reg: /^[\u4e00-\u9fa5]&#123;2,4&#125;$/, tip: "请输入正确的姓名" &#125;];addCheck('frm');//给文本框添加验证function addCheck(formId) &#123; var i = 0, len = 0, frm =document.getElementById(formId); len = frm.children.length; for (; i &lt; len; i++) &#123; var element = frm.children[i]; // 表单元素中有name属性的元素添加验证 if (element.name) &#123; element.onblur = function () &#123; // 使用dataset获取data-自定义属性的值 var ruleName = this.dataset.rule; var rule =getRuleByRuleName(rules, ruleName); var span = this.nextElementSibling; //判断验证是否成功 if(!rule.reg.test(this.value) )&#123; //验证不成功 span.innerText = rule.tip; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125; &#125; &#125; &#125;&#125;// 根据规则的名称获取规则对象function getRuleByRuleName(rules, ruleName) &#123; var i = 0, len = rules.length; var rule = null; for (; i &lt; len; i++) &#123; if (rules[i].name == ruleName) &#123; rule = rules[i]; break; &#125; &#125; return rule;&#125;]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式初识及简单使用]]></title>
    <url>%2F2019%2F02%2F17%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9D%E8%AF%86%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[学会用正则表达式做字符串提取和简单的匹配，如手机号、邮箱、日期…… 了解正则表达式基本语法 什么是正则表达式正则表达式：用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 正则表达式的作用 给定的字符串是否符合正则表达式的过滤逻辑(匹配) 可以通过正则表达式，从字符串中获取我们想要的特定部分(提取) 强大的字符串替换能力(替换) 正则表达式的特点 灵活性、逻辑性和功能性非常的强 可以迅速地用极简单的方式达到字符串的复杂控制 对于刚接触的人来说，比较晦涩难懂 正则表达式的测试 在线测试正则 工具中使用正则表达式 sublime/vscode/word 演示替换所有的数字 正则表达式的组成 普通字符abc 123 特殊字符(元字符)：正则表达式中有特殊意义的字符\d \w 示例演示： \d 匹配数字 ab\d 匹配 ab1、ab2 元字符通过测试工具演示下面元字符的使用 常用元字符串 元字符 说明 \d 匹配数字 \D 匹配任意非数字的字符 \w 匹配字母或数字或下划线 \W 匹配任意不是字母，数字，下划线 \s 匹配任意的空白符 \S 匹配任意不是空白符的字符 . 匹配除换行符以外的任意单个字符 ^ 表示匹配行首的文本(以谁开始) $ 表示匹配行尾的文本(以谁结束) 限定符 限定符 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 其它1234567[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思[^] 匹配除中括号以内的内容\ 转义符| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱() 从两个直接量中选择一个，分组 eg：gr(a|e)y匹配gray和grey[\u4e00-\u9fa5] 匹配汉字 案例验证手机号： 1^\d&#123;11&#125;$ ^[1-9]\d&#123;10&#125;$ 验证邮编： 1^\d&#123;6&#125;$ ^[1-9]\d&#123;5&#125;$ 验证日期 2012-5-01 1^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$ 验证邮箱 xxx@itcast.cn：sina.com.cn 1^\w+@\w+(\.\w+)+$ 验证IP地址 192.168.1.10 1^\d&#123;1,3&#125;(.\d&#123;1,3&#125;)&#123;3&#125;$]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VsCode 快捷键]]></title>
    <url>%2F2019%2F02%2F16%2Fvscode-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[提高自己的效率，基本快捷键的必须得了解一下啊 注释快捷键 注释： 先CTRL+K，然后CTRL+C 取消注释： 先CTRL+K，然后CTRL+U 代码块整体移动 右移： Tab 左移： Shift+tab 格式化代码 格式化选定内容： Ctrl +K Ctrl+F]]></content>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产线员工离岗管理小软件]]></title>
    <url>%2F2019%2F02%2F15%2F%E4%BA%A7%E7%BA%BF%E5%91%98%E5%B7%A5%E7%A6%BB%E5%B2%97%E7%AE%A1%E7%90%86%E5%B0%8F%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[生产线员工离岗记录小软件 需求 记录于2019.2.15上午生产线 为了便于管理公司生产线员工在生产时间是否外出超时和旷工，产线老大今天叫我写一个简单的小软件，丢弃以前手动填写excel的方式并且对表格加密（记录的时间不准确，手工可以改）另外软件展示离岗超时名单，可以给其他离岗员工提醒，便于约束产线员工行为。 分析一、 数据准备： 需要一个简单工号和姓名数据对应表，因为产线员工也有流动性，也得时常增加员工和编号—–在此，我选择用一个文本保存，一条信息一行 如：张三*1001 软件初始化时，读取，封装成对象集合，用于判断员工工号的正确性. 对象的查找，使用Linq查询实现 二、类的分析： 操作写Excel类、员工实体类(记录基本信息，封装对象)、窗体界面类里实现基本简单业务逻辑 Excel操作类，做一个写操作接口（传入要写的对象） 员工实体类-记录姓名，ID，日期、离开时间，回来时间、离岗次数、是否超时 涉及到的基本知识点 LINQ查询 对象的封装 微软官方的Microsoft.Office.Interop.Excel基础操作 文件IO读操作 函数的命名参数的使用(Excel操作类，保存，打开用到密码) 集合的深拷贝(因为对集合遍历操作时不能改变集合元素个数的，一旦操作涉及到，需要深拷贝一份) 控件的绑定技术 winform消息框实现定时自动关闭–不会阻塞线程执行（非要人点一下子） 具体实现软件界面设计 软件初始化操作建立软件文件夹、员工信息txt、员工信息的基本excel的创建 12345678910111213141516171819202122//软件启动初始化工作---建立文件夹和员工信息文本private void initConfig()&#123; if (!Directory.Exists(@"D:\离岗记录软件配置文件夹")) &#123; Directory.CreateDirectory(@"D:\离岗记录软件配置文件夹"); &#125; if (!File.Exists(@"D:\离岗记录软件配置文件夹\员工信息.txt")) &#123; using (FileStream fs = new FileStream(@"D:\离岗记录软件配置文件夹\员工信 息.txt", FileMode.Create)) &#123; StreamWriter sw = new StreamWriter(fs, Encoding.Default); sw.WriteLine("请从下一行开始按照示例规范填写员工信息,如：张三*120"); sw.WriteLine("张三*100"); sw.WriteLine("李四*110"); sw.WriteLine("王五*120"); sw.Flush(); sw.Close(); &#125; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435//软件启动初始化工作---读取员工姓名和编号 封装到集合中private void ReadEmployeeInfo()&#123; using (FileStream fs = new FileStream(@"D:\离岗记录软件配置文件夹\员工信息.txt", FileMode.Open)) &#123; //Encoding.Default 防止中文乱码 StreamReader sr = new StreamReader(fs, Encoding.Default); //第一行是提示信息，读取作废 string employee = sr.ReadLine(); while (true) &#123; employee = sr.ReadLine(); if (employee != "" &amp;&amp; employee != null) &#123; //切割成数组 string[] employeeArray = employee.Split('*'); //封装对象，添加到集合中---该集合是窗体对象属性 employeeInfos.Add(new EmployeeInfo() &#123; Name = employeeArray[0], ID = employeeArray[1] &#125;); &#125; else &#123; break; &#125; &#125; sr.Close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344//创建Excel文件，初始化表头private void initExcel()&#123; if (!File.Exists(@"D:\离岗记录软件配置文件夹\员工离岗信息记录.xlsx")) &#123; //创建Excel Excel.Application excelApp= new Excel.Application(); excelApp.Visible = false; //将此属性设置为False ，如果您不想被打扰提示和通知消息 excelApp.DisplayAlerts = false; //创建一个新的工作簿。 新工作簿成为活动工作簿。 返回Workbook对象。 Excel.Workbook workBook = excelApp.Workbooks.Add(true); //在活动工作簿或工作簿的指定的窗口中，则返回一个对象，表示活动工作表 Excel.Worksheet workSheet = excelApp.ActiveSheet as Excel.Worksheet; workSheet.Cells[1, "A"] = "姓名"; workSheet.Cells[1, "B"] = "ID"; workSheet.Cells[1, "C"] = "日期"; workSheet.Cells[1, "D"] = "离开时间"; workSheet.Cells[1, "E"] = "回来时间"; workSheet.Cells[1, "F"] = "离岗次数"; workSheet.Cells[1, "G"] = "是否超时"; workSheet.Cells[1, "H"] = "是否超次数"; workSheet.Cells[1, "I"] = "是否旷工"; workSheet.Cells[1, "J"] = "是否漏打卡"; workBook.SaveAs(Filename:@"D:\离岗记录软件配置文件夹\员工离岗信息记录.xlsx", Password:"654321"); workBook.Close(); excelApp.Quit(); //设置为null 方便垃圾回收机制回收资源 workSheet = null; workBook = null; excelApp = null; GC.Collect(); &#125;// excel文件存在了，可以创建操作excel对象了 excelOperationObj = new ExcelOperation(@"D:\离岗记录软件配置文件夹\员工离岗信息记录.xlsx");&#125; 实体类设计12345678910111213141516171819202122232425262728293031323334353637[Serializable]public class EmployeeInfo&#123; public string Name &#123; get; set; &#125; public string ID &#123; get; set; &#125; //离开时间 public List&lt;DateTime&gt; DepatureTime &#123; get; set; &#125; = new List&lt;DateTime&gt;(); //回来时间 public List&lt;DateTime&gt; ComeBackTime &#123; get; set; &#125; = new List&lt;DateTime&gt;(); //用于判定是否是重复错误输入或者是漏打卡判定 public DateTime Nowtime &#123; get; set; &#125; //员工离岗次数 public int LeaveCount &#123; get; set; &#125; = 0; //离岗信息 姓名+超出的规定次数 一条信息展示 public string Leaveinfo1 &#123; get; set; &#125; //离岗超时信息 姓名+超时时间--- 多条信息展示 public List&lt;string&gt; Leaveinfo2 &#123; get; set; &#125; = new List&lt;string&gt;(); //是否超时 便于excel查看 public string IsOverTime &#123; get; set; &#125; //是否超次数 便于excel查看 public string IsOverOut &#123; get; set; &#125; //是否离岗 便于Excel查看 public string ISAbsent &#123; get; set; &#125; //是否忘打开 便于Excel查看 public string Isforget &#123; get; set; &#125;&#125; LINQ查询判断123456789101112131415//通过员工编号，找到员工对象private EmployeeInfo FindEmployeeById(string id)&#123; IEnumerable&lt;EmployeeInfo&gt; employeeList = from mployeeInfo in employeeInfos where mployeeInfo.ID == id select mployeeInfo; if (employeeList.Count() != 0) &#123; return employeeList.First(); &#125; else &#123; return null; &#125;&#125; 员工离开打卡实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private void txtDepatureNumber_KeyDown(object sender, KeyEventArgs e)&#123; if (e.KeyCode == Keys.Enter) &#123; string id = this.txtDepatureNumber.Text.Trim(); //判断输入的是否是存档的员工编号 EmployeeInfo employeeInfo = FindEmployeeById(id); if (employeeInfo!=null) &#123; // 人员离岗---确定离岗集合中无此人 if (!depatureList.Contains(employeeInfo)) &#123; //记录此离岗人员 depatureList.Add(employeeInfo); //记录离岗时间 employeeInfo.DepatureTime.Add(System.DateTime.Now); &#125; else //人员离岗返回 包含重复输入和漏打卡两种情况 &#123; employeeInfo.Nowtime = DateTime.Now; TimeSpan interval = employeeInfo.Nowtime - employeeInfo.DepatureTime.Last(); if (interval.Seconds &lt;5) //判断是重复输入--5s &#123; this.txtDepatureNumber.Text = ""; return; &#125; else if(interval.Minutes&gt; 30)//大于30分钟判定是漏打卡 &#123; employeeInfo.Isforget = "是"; //此时写一条忘打卡记录 EmployeeDealLogic(employeeInfo); //此时的打卡，算再次出去 txtDepatureNumber_KeyDown(null, new KeyEventArgs(Keys.Enter)); &#125; else //30分钟内回来，正常 &#123; //30min内 出去返回 正常记录一条出去记录 EmployeeDealLogic(employeeInfo); &#125; &#125; &#125; else &#123; MessageBox.Show("不存在此员工编号" + id); &#125; this.txtDepatureNumber.Text = ""; &#125;&#125; 员工回来打卡实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879private void EmployeeDealLogic(EmployeeInfo employeeInfo)&#123; //离开集合存在 说明确实出去了，否则输入应为无效 if (depatureList.Contains(employeeInfo)) &#123; // 员工回来，从集合移除该对象 depatureList.Remove(employeeInfo); //记录回来时的时间 employeeInfo.ComeBackTime.Add(System.DateTime.Now); //离岗次数记录 int count = employeeInfo.DepatureTime.Count; if (employeeInfo.Isforget != "是") &#123; //超过10分钟没回，记录到离开超时集合中 if (employeeInfo.DepatureTime[count - 1].AddSeconds(5) &lt; employeeInfo.ComeBackTime[count - 1]) &#123; //得到员工姓名+超时时间信息 string info = employeeInfo.Name + " " + (employeeInfo.ComeBackTime[count - 1] - employeeInfo.DepatureTime[count - 1].AddSeconds(5)); //设置写excel中 是否超时标题头下 写 是 employeeInfo.IsOverTime = "是"; //在对象集合属性中，增加这条超时信息 employeeInfo.Leaveinfo2.Add(info); //加入到 离岗超时展示集合中 界面上展示 this.ListdepatureTimeOut.Items.Add(info); &#125; &#125; else //是漏打卡 &#123; string info = employeeInfo.Name + " 漏打卡"; //加入到 离岗超时展示集合中 界面上展示 this.ListdepatureTimeOut.Items.Add(info); &#125; //员工离岗次数加1 employeeInfo.LeaveCount++; //离岗次数超过3次 if (employeeInfo.LeaveCount &gt; 3) &#123; //修改对象 离岗超次数信息，方便界面显示 employeeInfo.Leaveinfo1 = employeeInfo.Name + "超 " + (employeeInfo.LeaveCount - 3) + " 次"; employeeInfo.IsOverOut = "是"; //防止一个对象多次加入 界面离岗超次数 一个人只展示一次 if (LeaveOverCountList.Contains(employeeInfo)) &#123; LeaveOverCountList.Remove(employeeInfo); LeaveOverCountList.Add(employeeInfo); &#125; else &#123; LeaveOverCountList.Add(employeeInfo); &#125; &#125; excelOperationObj.writeEmployeeInfo(employeeInfo); //记录写入excel后 ，为了 人工看excel好直接定位 employeeInfo.IsOverTime = ""; employeeInfo.Isforget = ""; &#125; else &#123; return; &#125;&#125; Excel操作类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class ExcelOperation&#123; //系统进程操作 [DllImport("User32.dll")] public static extern int GetWindowThreadProcessId(IntPtr hWnd, out int Processid); //存放Excel所在路径 public string Path &#123; get; set; &#125; public Excel.Application excelApp = null; public Excel.Workbook workbook = null; public Excel.Worksheet worksheet = null; //Process 需要 using System.Diagnostics; 静态成员，方便进程的销毁 static List&lt;Process&gt; processes = new List&lt;Process&gt;(); //通过构造函数传入路径 public ExcelOperation(string path) &#123; this.Path = path; //创建Excel操作对象 excelApp = new Excel.Application(); excelApp.Visible = false; excelApp.DisplayAlerts = false; //获取工作薄----使用命名参数 workbook = excelApp.Workbooks.Open(Filename:Path,Password:"654321"); //加入到进程集合中 processes.Add(GetExcelProcess(excelApp)); worksheet = excelApp.ActiveSheet as Excel.Worksheet; &#125; Process GetExcelProcess(Excel.Application excelApp) &#123; int id; IntPtr intptr = new IntPtr(excelApp.Hwnd); GetWindowThreadProcessId(intptr, out id); return Process.GetProcessById(id); &#125; public void writeEmployeeInfo(EmployeeInfo employeeInfo) &#123; try &#123; //获取数据行数 int ExcelRowNumber = worksheet.UsedRange.Cells.Rows.Count; int writeRow = ExcelRowNumber + 1; worksheet.Cells[writeRow, "A"] = employeeInfo.Name; worksheet.Cells[writeRow, "B"] = employeeInfo.ID; worksheet.Cells[writeRow, "C"] = DateTime.Now.ToString("yyyy/MM/dd"); worksheet.Cells[writeRow, "D"] = employeeInfo.DepatureTime.Count==0? DateTime.Now : employeeInfo.DepatureTime.Last(); worksheet.Cells[writeRow, "E"] = employeeInfo.ComeBackTime.Count == 0 ? DateTime.Now : employeeInfo.ComeBackTime.Last(); worksheet.Cells[writeRow, "F"] = employeeInfo.LeaveCount; worksheet.Cells[writeRow, "G"] = employeeInfo.IsOverTime; worksheet.Cells[writeRow, "H"] = employeeInfo.IsOverOut; worksheet.Cells[writeRow, "I"] = employeeInfo.ISAbsent; worksheet.Cells[writeRow, "J"] = employeeInfo.Isforget; worksheet.Columns.EntireColumn.AutoFit();//列宽自适应。 workbook.Save(); &#125; catch (Exception ex) &#123; throw ex; &#125; &#125; public void excelClose() &#123; workbook.Close(); excelApp.Quit(); worksheet = null; workbook = null; excelApp = null; GC.Collect(); //可以这里直接杀进程，有时不会回收资源 // KillProcess(); &#125; public void KillProcess() &#123; for (int i = 0; i &lt; processes.Count; i++) &#123; if (processes[i] != null) &#123; processes[i].Kill(); processes[i].Dispose(); &#125; &#125; &#125;&#125; 窗体关闭优化工作 窗体关闭，还有员工未打开回来，此时记录一条信息漏打卡 软件实现漏打卡，涉及到从集合中移出元素,而遍历写漏打卡信息需要用到集合，所以需要深拷贝 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void MainForm_FormClosing(object sender, FormClosingEventArgs e)&#123; //窗体关闭确认 DialogResult result = MessageBox.Show("确认退出吗?", "操作提示", MessageBoxButtons.OKCancel, MessageBoxIcon.Information); if (result != DialogResult.OK) &#123; e.Cancel = true; &#125; else &#123; //关闭软件前，有还未返回打卡的员工，记录为忘打卡 foreach (var item in depatureList) &#123; item.Isforget = "是"; &#125; BindingList&lt;EmployeeInfo&gt; list = (BindingList&lt;EmployeeInfo&gt;)DeepClone(depatureList); foreach (var item in list) &#123; this.txtDepatureNumber.Text = item.ID; txtDepatureNumber_KeyDown(null, new KeyEventArgs(Keys.Enter)); &#125; excelOperationObj.excelClose(); &#125;&#125;public static object DeepClone(object obj)&#123; object objResult = null; using (MemoryStream ms = new MemoryStream()) &#123; BinaryFormatter bf = new BinaryFormatter(); bf.Serialize(ms, obj); ms.Position = 0; objResult = bf.Deserialize(ms); &#125; return objResult;&#125; 集合控件绑定数据源展示123456789101112131415161718192021222324252627282930313233343536public MainForm()&#123; InitializeComponent(); //为窗体控件 初始化数据绑定源 this.listAbsent.DataSource = absentList; this.listAbsent.DisplayMember = "Name"; this.listAbsent.ValueMember = "ID"; this.listDepature.DataSource = depatureList; this.listDepature.DisplayMember = "Name"; this.listDepature.ValueMember = "ID"; this.ListLeaveOverCount.DataSource = LeaveOverCountList; this.ListLeaveOverCount.DisplayMember = "Leaveinfo1"; this.ListLeaveOverCount.ValueMember = "ID"; initConfig(); ReadEmployeeInfo(); initExcel(); this.txtDepatureNumber.Select();&#125;//员工信息集合--读取配置文件获取，用来判断输入的准确性private List&lt;EmployeeInfo&gt; employeeInfos = new List&lt;EmployeeInfo&gt;();// 旷工集合private BindingList&lt;EmployeeInfo&gt; absentList = new BindingList&lt;EmployeeInfo&gt;();//离岗未回集合private BindingList&lt;EmployeeInfo&gt; depatureList = new BindingList&lt;EmployeeInfo&gt;();//员工离岗超次数集合private BindingList&lt;EmployeeInfo&gt; LeaveOverCountList = new BindingList&lt;EmployeeInfo&gt;(); 消息框自动计时关闭功能1234[DllImport("user32.dll")]public static extern int MessageBoxTimeoutA(IntPtr hWnd, string msg, string Caps, int type, int Id, int time);//引用DLLMessageBoxTimeoutA((IntPtr)0, "不存在该员工编号！", "消息框", 0, 0, 1000);// 直接调用 1秒后自动关闭 父窗口句柄没有直接用0代替]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>工作小软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基本知识小结]]></title>
    <url>%2F2019%2F02%2F14%2FHTML%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[了解WEB标准、网页的基本组成、基本网页排版标签、图像、链接、列表、表单、表格标签 认识网页网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及Flash等。 1思考： 网页是如何形成的呢? 常见浏览器介绍浏览器是网页运行的平台，常用的浏览器有IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera等。我们平时称为五大浏览器。 查看浏览器占有的市场份额（知晓）查看网站： http://tongji.baidu.com/data/browser 浏览器内核（理解）12345浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。渲染引擎 它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。JS 引擎 则是解析 Javascript 语言，执行 javascript语言来实现网页的动态效果。最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了一个 ACID 来测试引擎的兼容性和性能。内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有10多种，但是常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit。 （1）Trident(IE内核) 国内很多的双核浏览器的其中一核便是 Trident，美其名曰 “兼容模式”。 代表： IE、傲游、世界之窗浏览器、Avant、腾讯TT、猎豹安全浏览器、360极速浏览器、百度浏览器等。 Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。 （2）Gecko(firefox) Gecko(Firefox 内核)： Mozilla FireFox(火狐浏览器) 采用该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。 可惜这几年已经没落了， 比如 打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。 （3） webkit(Safari) Safari 是苹果公司开发的浏览器，所用浏览器内核的名称是大名鼎鼎的 WebKit。 现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了），苹果感觉像被别人抢了媳妇，都哭晕再厕所里面了。 代表浏览器：傲游浏览器3、 Apple Safari (Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器， （4） Chromium/Bink(chrome) 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。 ​ 大部分国产浏览器最新版都采用Blink内核。 （5） Presto(Opera) Presto 是挪威产浏览器 opera 的 “前任” 内核，为何说是 “前任”，因为最新的 opera 浏览器早已将之抛弃从而投入到了谷歌怀抱了。 1了解一点： 移动端的浏览器内核主要说的是系统内置浏览器的内核。 目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。 Web标准（重点）通过以上浏览器的内核不同，我们知道他们工作原理、解析肯定不同，显示就会有差别。 1问： 哪个语言再全国基本都可以听得懂？ Web 标准的好处1、让Web的发展前景更广阔2、内容能被更广泛的设备访问3、更容易被搜寻引擎搜索4、降低网站流量费用5、使网站更易于维护6、提高页面浏览速度 Web 标准构成 Web标准不是某一个标准，而是由W3C和其他标准化组织制定的一系列标准的集合。主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。 123结构标准：结构用于对网页元素进行整理和分类，主要包括XML和XHTML两个部分。样式标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。行为标准：行为是指网页模型的定义及交互的编写，主要包括DOM和ECMAScript两个部分 理想状态我们的源码： .HTML .css .js 1专业的人，写专业的代码 直观感受： 总结WEB标准： 结构标准： 决定你是否有个好天然身体 样式标准： 决定你是否打扮的美丽外观 行为标准： 决定你是否有吸引人的行为 HTML 初识一般先学习HTML+CSS， 这里我们先定一个小目标，先学HTML,后学习CSS。 HTML（英文Hyper Text Markup Language的缩写）中文译为“超文本标签语言”，主要是通过HTML标签对网页中的文本、图片、声音等内容进行描述。 1&lt;strong&gt; 我是加粗的字体 &lt;/strong&gt; 注意： 体会 文本 标签 语言 几个词语 HTML骨架格式日常生活的书信，我们要遵循共同的约定。 同理：HTML 有自己的语言语法骨架格式： 1234567&lt;HTML&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/HTML&gt; 课堂练习1： 书写我们的第一个HTML 页面！ 新建一个demo 的 TXT 文件。 里面写入刚才的HTML 骨架。 把后缀名改为 .HTML。 右击–谷歌浏览器打开。 1234567891011121314151617181920211 HTML标签：作用所有HTML中标签的一个根节点。2 head标签：作用：用于存放：title,meta,base,style,script,link注意在head标签中我们必须要设置的标签是title3.title标签：作用：让页面拥有一个属于自己的标题。4.body标签：作用：页面在的主体部分，用于存放所有的HTML标签：p,h,a,b,u,i,s,em,del,ins,strong,img 为了便于记忆，我们请出刚才要辞职回家养猪的二师兄来帮忙， 我称之为 猪八戒记忆法 HTML标签分类 在HTML页面中，带有“&lt; &gt;”符号的元素被称为HTML标签，如上面提到的 &lt;HTML&gt;、&lt;head&gt;、&lt;body&gt;都是HTML标签。所谓标签就是放在“&lt; &gt;” 标签符中表示某个功能的编码命令，也称为HTML标签或 HTML元素 1.双标签 1&lt;标签名&gt; 内容 &lt;/标签名&gt; 该语法中“&lt;标签名&gt;”表示该标签的作用开始，一般称为“开始标签（start tag）”，“&lt;/标签名&gt;” 表示该标签的作用结束，一般称为“结束标签（end tag）”。和开始标签相比，结束标签只是在前面加了一个关闭符“/”。 1比如 &lt;body&gt;我是文字 &lt;/body&gt; 2.单标签 1&lt;标签名 /&gt; 单标签也称空标签，是指用一个标签符号即可完整地描述某个功能的标签。 12&gt; 比如 &lt;br /&gt;&gt; HTML标签关系标签的相互关系就分为两种： 1.嵌套关系 1&lt;head&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; 2.并列关系 12&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 测试题： 1请问下列哪个标签是错误的？ 1A &lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 1B &lt;strong&gt;&lt;div&gt;&lt;/div&gt;&lt;/strong&gt; 1C &lt;head&gt;&lt;title&gt;&lt;/head&gt;&lt;/title&gt; 1D &lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt; 倡议： 如果两个标签之间的关系是嵌套关系，子元素最好缩进一个tab键的身位。如果是并列关系，最好上下对齐。 开发工具 这些工具你认识几个？ 普通青年 Dreamweaver 文艺青年 sublime 高手和傻子 用记事本 其实。。。。 sublime 一些常用快捷键 点我查看 1234再页面中输入 以下2个单词1. html: 5 2. ! 在sublime里面然后按下tab键盘即可生成HTML骨架 文档类型&lt;!DOCTYPE&gt;1&lt;!DOCTYPE html&gt; 这句话就是告诉我们使用哪个html版本？ 我们使用的是 html 5 的版本。 html有很多版本，那我们应该告诉用户和浏览器我们使用的版本号。 &lt;!DOCTYPE&gt; 标签位于文档的最前面，用于向浏览器说明当前文档使用哪种 HTML 或 XHTML 标准规范，必需在开头处使用&lt;!DOCTYPE&gt;标签为所有的XHTML文档指定XHTML版本和类型，只有这样浏览器才能按指定的文档类型进行解析。 注意： 一些老网站可能用的还是老版本的文档类型比如 XHTML之类的，但是我们学的是HTML5,而且HTML5的文档类型兼容很好(向下兼容的原则)，所以大家放心的使用HTML5的文档类型就好了。 字符集 utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。 gb2312 简单中文 包括6763个汉字 BIG5 繁体中文 港澳台等用 GBK包含全部中文字符 是GB2312的扩展，加入对繁体字的支持，兼容GB2312 UTF-8则包含全世界所有国家需要用到的字符 1记住一点，以后我们统统使用UTF-8 字符集, 这样就避免出现字符集不统一而引起乱码的情况了。 HTML标签的语义化白话： 所谓标签语义化，就是指标签的含义。 为什么要有语义化标签 方便代码的阅读和维护 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容 使用语义化标签会具有更好地搜索引擎优化 核心：合适的地方给一个最为合理的标签。 语义是否良好： 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。 不管是谁都能看懂这块内容是什么。 遵循的原则：先确定语义的HTML ，再选合适的CSS。 HTML标签 首先 HTML和CSS是两种完全不同的语言，我们学的是结构，就只写HTML标签，认识标签就可以了。 不会再给结构标签指定样式了。 HTML标签有很多，这里我们学习最为常用的，后面有些较少用的，我们可以查下手册就可以了。 排版标签排版标签主要和css搭配使用，显示网页结构的标签，是网页布局最常用的标签。 标题标签 (熟记) 单词缩写： head 头部. 标题 为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即 &lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;和&lt;h6&gt; 1标题标签语义： 作为标题使用，并且依据重要性递减 其基本语法格式如下： 1&lt;hn&gt; 标题文本 &lt;/hn&gt; 注意： h1 标签因为重要，尽量少用，不要动不动就向你扔了一个h1。 一般h1 都是给logo使用。 段落标签( 熟记)单词缩写： paragraph 段落 在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是 1&lt;p&gt; 文本内容 &lt;/p&gt; 是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 水平线标签(认识)单词缩写： horizontal 横线 在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，就是创建横跨网页水平线的标签。其基本语法格式如下： 1&lt;hr /&gt;是单标签 在网页中显示默认样式的水平线。 课堂练习2： 新闻页面 换行标签(熟记)单词缩写： break 打断 ,换行 在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 1&lt;br /&gt; 这时如果还像在word中直接敲回车键换行就不起作用了。 div span标签(重点)div span 是没有语义的 是我们网页布局主要的2个盒子 div 就是 division 的缩写 分割， 分区的意思 其实有很多div 来组合网页。 span, 跨度，跨距；范围 语法格式： 1&lt;div&gt; 这是头部 &lt;/div&gt; &lt;span&gt;今日价格&lt;/span&gt; 文本格式化标签(熟记)在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。 b i s u 只有使用 没有 强调的意思 strong em del ins 语义更强烈 标签属性 属性就是特性 比如 手机的颜色 手机的尺寸 ，总结就是手机的。。 使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本语法格式如下： 1&lt;标签名 属性1="属性值1" 属性2="属性值2" …&gt; 内容 &lt;/标签名&gt; 在上面的语法中， 1.标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。 2.属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。 3.任何标签的属性都有默认值，省略该属性则取默认值。 采取 键值对 的格式 key=”value” 的格式 比如: 1&lt;hr width="400" /&gt; 属性 是 宽度 值 是 400 提倡： 尽量不使用 样式属性。 图像标签img (重点)单词缩写： image 图像 HTML网页中任何元素的实现都要依靠HTML标签，要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签&lt;img /&gt;以及和他相关的属性。其基本语法格式如下： 该语法中src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。 1&lt;img src="图像URL" /&gt; 链接标签(重点)单词缩写： anchor 的缩写 。基本解释 锚, 铁锚 的 在HTML中创建超链接非常简单，只需用标签环绕需要被链接的对象即可，其基本语法格式如下： 1&lt;a href="跳转目标" target="目标窗口的弹出方式"&gt;文本或图像&lt;/a&gt; href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接的功能。 Hypertext Reference的缩写。意思是超文本引用 target：用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，_blank为在新窗口中打开方式。 注意： 1.外部链接 需要添加 http:// www.baidu.com 2.内部链接 直接链接内部页面名称即可 比如 &lt; a href=”index.html”&gt; 首页 3.如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=”#”)，表示该链接暂时为一个空链接。 4.不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。 锚点定位 （难点）通过创建锚点链接，用户能够快速定位到目标内容。创建锚点链接分为两步： 1231.使用“a href=”#id名&gt;“链接文本"&lt;/a&gt;创建链接文本。2.使用相应的id名标注跳转目标的位置。 base 标签base 可以设置整体链接的打开状态 base 写到 之间 特殊字符标签 （理解） 注释标签在HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。其基本语法格式如下：​ 1&lt;!-- 注释语句 --&gt; 注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。 注释重要性： 路径(重点、难点) 实际工作中，通常新建一个文件夹专门用于存放图像文件，这时再插入图像，就需要采用“路径”的方式来指定图像文件的位置。 路径可以分为： 相对路径和绝对路径 相对路径 图像文件和HTML文件位于同一文件夹：只需输入图像文件的名称即可，如&lt;img src=”logo.gif” /&gt;。 图像文件位于HTML文件的下一级文件夹：输入文件夹名和文件名，之间用“/”隔开，如&lt;img src=”img/img01/logo.gif” /&gt;。 图像文件位于HTML文件的上一级文件夹：在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推，如&lt;img src=”../logo.gif” /&gt;。 绝对路径绝对路径 “D:\web\img\logo.gif”，或完整的网络地址，例如“http://www.itcast.cn/images/logo.gif”。 列表标签什么是列表？ 把…制成表,以表显示 容器里面装载着文字或图表的一种形式，叫列表。 列表最大的特点就是 整齐 、整洁、 有序 无序列表 ul （重点）无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下： 123456&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ul&gt; 比如下面这些，新闻是没有顺序的，不用排队，先到先得，后发布先显示。 脚下留心： 1231. &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。2. &lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。3. 无序列表会带有自己样式属性，放下那个样式，一会让CSS来！ 有序列表 ol （了解） 有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下： 123456&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ol&gt; 所有特性基本与ul 一致。 但是实际工作中， 较少用 ol ，因此我们用一句话来总结下 ol： 自定义列表（理解）定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下： 12345678910&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ... &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ...&lt;/dl&gt; 用的还可以： 总结 每一天都有一个主题 我们HTML第一天的主题就是 &lt;认识标签&gt; 学HTML 之前 觉得 很神秘 等你学完之后忽然发现 总结今天的思路贯穿线： 表格 table(会使用)存在即是合理的。 表格的现在还是较为常用的一种标签，但不是用来布局，常见处理、显示表格式数据。 ps: 这些地方用表格，你会觉得生活还是那么美好。。。。忍不住想说 PPAP i hava a pen 创建表格在HTML网页中，要想创建表格，就需要使用表格相关的标签。创建表格的基本语法格式如下： 1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ...&lt;/table&gt; 在上面的语法中包含三对HTML标签，分别为 &lt;table&gt;&lt;/table&gt;、&lt;tr&gt;&lt;/tr&gt;、&lt;td&gt;&lt;/td&gt;，他们是创建表格的基本标签，缺一不可，下面对他们进行具体地解释 123451.table用于定义一个表格。2.tr 用于定义表格中的一行，必须嵌套在 table标签中，在 table中包含几对 tr，就有几行表格。3.td /td：用于定义表格中的单元格，必须嵌套在&lt;tr&gt;&lt;/tr&gt;标签中，一对 &lt;tr&gt; &lt;/tr&gt;中包含几对&lt;td&gt;&lt;/td&gt;，就表示该行中有多少列（或多少个单元格）。 注意： 11. &lt;tr&gt;&lt;/tr&gt;中只能嵌套&lt;td&gt;&lt;/td&gt; 12. &lt;td&gt;&lt;/td&gt;标签，他就像一个容器，可以容纳所有的元素 表格属性 表头标签表头一般位于表格的第一行或第一列，其文本加粗居中，如下图所示，即为设置了表头的表格。设置表头非常简单，只需用表头标签&lt;th&gt;&lt;/th&gt;替代相应的单元格标签&lt;td&gt;&lt;/td&gt;即可。 表格结构（了解）12345678910在使用表格进行布局时，可以将表格划分为头部、主体和页脚（页脚因为有兼容性问题，我们不在赘述），具体 如下所示：&lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部。必须位于&lt;table&gt;&lt;/table&gt; 标签中，一般包含网页的logo和导航等头部信息。&lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体。位于&lt;table&gt;&lt;/table&gt;标签中，一般包含网页中除头部和底部之外的其他内容。 表格标题表格的标题： caption 定义和用法 caption 元素定义表格标题。 123&lt;table&gt; &lt;caption&gt;我是表格标题&lt;/caption&gt;&lt;/table&gt; caption 标签必须紧随 table 标签之后。您只能对每个表格定义一个标题。通常这个标题会被居中于表格之上。 合并单元格(难点)跨行合并：rowspan 跨列合并：colspan 合并单元格的思想： ​ 将多个内容合并的时候，就会有多余的东西，把它删除。 例如 把 3个 td 合并成一个， 那就多余了2个，需要删除。 ​ 公式： 删除的个数 = 合并的个数 - 1 合并的顺序 先上 先左 总结表格 表格提供了HTML 中定义表格式数据的方法。 表格中由行中的单元格组成。 表格中没有列元素，列的个数取决于行的单元格个数。 表格不要纠结于外观，那是CSS 的作用。 ​ 表格的学习要求： 能手写表格结构，并且能合并单元格。 表单标签(掌握)现实中的表单，类似我们去银行办理信用卡填写的单子。 如下图 目的是为了收集用户信息。 在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时也需要表单。 在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。 表单控件： ​ 包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息： ​ 一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。 表单域： ​ 他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 input 控件(重点)在上面的语法中，&lt;input /&gt;标签为单标签，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。除了type属性之外，&lt;input /&gt;标签还可以定义很多其他的属性，其常用属性如下表所示。 label标签(理解)label 标签为 input 元素定义标注（标签）。 作用： 用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点 如何绑定元素呢？ for 属性规定 label 与哪个表单元素绑定。 12&lt;label for="male"&gt;Male&lt;/label&gt;&lt;input type="radio" name="sex" id="male" value="male"&gt; textarea控件(文本域)如果需要输入大量的信息，就需要用到&lt;textarea&gt;&lt;/textarea&gt;标签。通过textarea控件可以轻松地创建多行文本输入框，其基本语法格式如下： 123&lt;textarea cols="每行中的字符数" rows="显示的行数"&gt; 文本内容&lt;/textarea&gt; 下拉菜单使用select控件定义下拉菜单的基本语法格式如下 123456&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ...&lt;/select&gt; 注意： &lt;select&gt;&lt;/select&gt;中至少应包含一对&lt;option&gt;&lt;/option&gt;。 在option 中定义selected =” selected “时，当前项即为默认选中项。 表单域在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。创建表单的基本语法格式如下： 123&lt;form action="url地址" method="提交方式" name="表单名称"&gt; 各种表单控件&lt;/form&gt; 常用属性： Action在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。 method用于设置表单数据的提交方式，其取值为get或post。 name用于指定表单的名称，以区分同一个页面中的多个表单。 注意： 每个表单都应该有自己表单域。 HTML5新标签与特性 文档类型设定 document HTML: sublime 输入 html:4s XHTML: sublime 输入 html:xt HTML5 sublime 输入 html:5 &lt;!DOCTYPE html&gt; 字符设定 ：HTML与XHTML中建议这样去写 ：HTML5的标签中建议这样去写 常用新标签 w3c 手册中文官网 : http://w3school.com.cn/ header：定义文档的页眉 头部 nav：定义导航链接的部分 footer：定义文档或节的页脚 底部 article：定义文章。 section：定义文档中的节（section、区段） aside：定义其所处内容之外的内容 侧边 123456&lt;header&gt; 语义 :定义页面的头部 页眉&lt;/header&gt;&lt;nav&gt; 语义 :定义导航栏 &lt;/nav&gt; &lt;footer&gt; 语义: 定义 页面底部 页脚&lt;/footer&gt;&lt;article&gt; 语义: 定义文章&lt;/article&gt;&lt;section&gt; 语义： 定义区域&lt;/section&gt;&lt;aside&gt; 语义： 定义其所处内容之外的内容 侧边&lt;/aside&gt; ​ datalist 标签定义选项列表。请与 input 元素配合使用该元素 123456789&lt;input type="text" value="输入明星" list="star"/&gt; &lt;!-- input里面用 list --&gt;&lt;datalist id="star"&gt; &lt;!-- datalist 里面用 id 来实现和 input 链接 --&gt; &lt;option&gt;刘德华&lt;/option&gt; &lt;option&gt;刘若英&lt;/option&gt; &lt;option&gt;刘晓庆&lt;/option&gt; &lt;option&gt;郭富城&lt;/option&gt; &lt;option&gt;张学友&lt;/option&gt; &lt;option&gt;郭郭&lt;/option&gt;&lt;/datalist&gt; ​ fieldset 元素可将表单内的相关元素分组，打包 legend 搭配使用 12345&lt;fieldset&gt; &lt;legend&gt;用户登录&lt;/legend&gt; 标题 用户名: &lt;input type="text"&gt;&lt;br /&gt;&lt;br /&gt; 密 码: &lt;input type="password"&gt;&lt;/fieldset&gt; ​ 新增的input type属性值： 类型** 使用示例** 含义** email** 输入邮箱格式 tel** 输入手机号码格式 url** 输入url格式 number** 输入数字格式 search** 搜索框（体现语义化） range** 自由拖动滑块 time** 小时分钟 date** 年月日 datetime** 时间 month** 月年 week** 星期 年 ## 常用新属性 属性** 用法** 含义** placeholder** 占位符 当用户输入的时候 里面的文字消失 删除所有文字，自动返回 autofocus** 规定当页面加载时 input 元素应该自动获得焦点 multiple** 多文件上传 autocomplete** 规定表单是否应该启用自动完成功能 有2个值，一个是on 一个是off on 代表记录已经输入的值 1.autocomplete 首先需要提交按钮 2.这个表单您必须给他名字 required** 必填项 内容不能为空 accesskey** 规定激活（使元素获得焦点）元素的快捷键 采用 alt + s的形式 综合案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;form action=""&gt; &lt;fieldset&gt; &lt;legend&gt;学生档案&lt;/legend&gt; &lt;label for="userName"&gt;姓名:&lt;/label&gt; &lt;input type="text" name="userName" id="userName" placeholder="请输入用户名"&gt; &lt;br&gt; &lt;label for="userPhone"&gt;手机号码:&lt;/label&gt; &lt;input type="tel" name="userPhone" id="userPhone" pattern="^1\d&#123;10&#125;$"&gt;&lt;br&gt; &lt;label for="email"&gt;邮箱地址:&lt;/label&gt; &lt;input type="email" required name="email" id="email"&gt;&lt;br&gt; &lt;label for="collage"&gt;所属学院:&lt;/label&gt; &lt;input type="text" name="collage" id="collage" list="cList" placeholder="请选择"&gt;&lt;br&gt; &lt;datalist id="cList"&gt; &lt;option value="前端与移动开发学院"&gt;&lt;/option&gt; &lt;option value="java学院"&gt;&lt;/option&gt; &lt;option value="c++学院"&gt;&lt;/option&gt; &lt;/datalist&gt;&lt;br&gt; &lt;label for="score"&gt;入学成绩:&lt;/label&gt; &lt;input type="number" max="100" min="0" value="0" id="score"&gt;&lt;br&gt; &lt;form action=""&gt; &lt;fieldset&gt; &lt;legend&gt;学生档案思密达&lt;/legend&gt; &lt;label&gt;姓名: &lt;input type="text" placeholder="请输入学生名字"/&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;手机号: &lt;input type="tel" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;邮箱: &lt;input type="email" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;所属学院: &lt;input type="text" placeholder="请选择学院" list="xueyuan"/&gt; &lt;datalist id="xueyuan"&gt; &lt;option&gt;java学院&lt;/option&gt; &lt;option&gt;前端学院&lt;/option&gt; &lt;option&gt;php学院&lt;/option&gt; &lt;option&gt;设计学院&lt;/option&gt; &lt;/datalist&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;出生日期: &lt;input type="date" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;成绩: &lt;input type="number" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;label&gt;毕业时间: &lt;input type="date" /&gt;&lt;/label&gt; &lt;br /&gt;&lt;br /&gt; &lt;input type="submit" /&gt; &lt;input type="reset" /&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;label for="inTime"&gt;入学日期:&lt;/label&gt; &lt;input type="date" id="inTime" name="inTime"&gt;&lt;br&gt; &lt;label for="leaveTime"&gt;毕业日期:&lt;/label&gt; &lt;input type="date" id="leaveTime" name="leaveTime"&gt;&lt;br&gt; &lt;input type="submit"&gt; &lt;/fieldset&gt;&lt;/form&gt; 多媒体标签 embed：标签定义嵌入的内容 audio：播放音频 video：播放视频 多媒体 embed（会使用）embed可以用来插入各种多媒体，格式可以是 Midi、Wav、AIFF、AU、MP3等等。url为音频或视频文件及其路径，可以是相对路径或绝对路径。 因为兼容性问题，我们这里只讲解 插入网络视频， 后面H5会讲解 audio 和video 视频多媒体。 1&lt;embed src="http://player.youku.com/player.php/sid/XMTI4MzM2MDIwOA==/v.swf" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"&gt;&lt;/embed&gt; ​ 优酷，土豆，爱奇艺，腾讯、乐视等等 先上传 在分享 多媒体 audioHTML5通过标签来解决音频播放的问题。 使用相当简单，如下图所示 并且可以通过附加属性可以更友好控制音频的播放，如： autoplay 自动播放 controls 是否显不默认播放控件 loop 循环播放 loop = 2 就是循环2次 loop 或者 loop = “-1” 无限循环 由于版权等原因，不同的浏览器可支持播放的格式是不一样的，如下图供参考 多浏览器支持的方案，如下图 多媒体 videoHTML5通过&lt;audio&gt;标签来解决音频播放的问题。 同音频播放一样，&lt;video&gt;使用也相当简单，如下图 同样，通过附加属性可以更友好的控制视频的播放 autoplay 自动播放 controls 是否显示默认播放控件 loop 循环播放 width 设置播放窗口宽度 height 设置播放窗口的高度 由于版权等原因，不同的浏览器可支持播放的格式是不一样的，如下图供参考 多浏览器支持的方案，如下图** 总结 HTML 第二天的主题： 熟悉列表— 会使用表格 — 掌握常用表单]]></content>
      <categories>
        <category>前端框架</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多台电脑使用hexo写博客]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8hexo%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[任意电脑都可以写自己的博客~ 场景需求工作以后大部分时间都是在用办公室里的电脑，现在想在笔记本和办公室的电脑上都能用hexo写博客。 思路 hexo生成的静态博客文件都是上传到GitHub上的, 且默认放在master分支上, 而一些相关的配置文件都在本地 hexo的源文件（部署环境文件）可以都放在hexo分支上（可以新创建一个hexo分支） 换新电脑时，直接git clone hexo分支 分析本地博客目录展示 新建一个 hexo 分支，把 hexo 的源文件都放到这个分支上。但是源文件有70多M，并不需要把所有文件都放在分支上。 node_modules目录可以用 npm install 命令生成 public目录可以使用 hexo g 命令生成（部署到master分支的内容） .deploy_git目录是hexo d命令生成，所以可以把这三个目录放在 .gitignore 里忽略提交。 实现步骤 建立hexo分支 将其设置为默认分支 将分支内容clone到本地 ​ git clone 仓库地址 hexo_branch 命令执行完毕 会创建hexo_branch文件夹（如果先前有写博客发布到master分支,那么目录下的内容就为hexo生成的静态资源–对应原本博客目录下的pulic文件下的内容) 将clone下来的静态文件全部删除 然后将自己博客目录下的文件夹内容拷贝到hexo_branch 目录里 git add . git commit -m “上传部署环境文件” git push 执行完毕后目录结构如下–至此部署环境文件放在了hexo分支 在新电脑上依次安装git node.js 然后安装hexo 1npm install -g hexo-cli 新电脑clone刚才的分支 然后执行 1npm install 安装所有依赖（生成 node_modules 目录）。 执行 1hexo g 生成博客的静态文件（即 public 目录） 执行 1hexo s //hexo server 运行 hexo 服务器，在浏览器中打开 http://localhost:4000 查看博客是否已经可以运行。 hexo new 文章名称 自己编辑好 重启服务可直接查看已编辑内容展示 执行 $ hexo g -d 或者 $ hexo d -g 将静态资源发布到master分支 然后访问自己的github查看 将更改提交到hexo分支 日常操作换到不同电脑上时，首先拉下 github 上的 hexo分支的更新]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客进阶配置]]></title>
    <url>%2F2019%2F02%2F13%2Fhexo%E8%BF%9B%E9%98%B6%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[为自己的hexo博客添加评论系统、统计阅读量、二维码、本地搜索….. Next 主题github上使用人比较多试了几种评论系统 Valine最好用（来必力加载太慢） hexo主题推荐Next 官方链接:clik me 按照官方指导 clone 下来 放在本地博客主题文件夹中 然后修改全局_config.yml文件 主题里面配置选项非常多，在官网里查看 Leancloud统计文章阅读量参考博文: clik me Hexo加上评论系统-Valine参考博文: clik me 文章末尾添加二维码利用 NexT 主题自带的wechat_subscriber功能在文章末尾添加网站二维码。首先生成你网站的二维码，放到网站根目录下的images文件夹中，然后修改主题配置文件 _config.yml，添加如下内容： 12345# Wechat Subscriberwechat_subscriber: enabled: true qcode: /images/wuxubj.png description: 扫一扫，用手机访问本站 写博客时添加图片参考博文: clik me 1npm install hexo-asset-image --save 博客添加本地搜索1npm install hexo-generator-searchdb --save 修改主题配置文件_config.yml (一定要先执行上面命令，否则链接会一直转圈) 12local_search: enable: true Hexo博客搭建之引用站内文章1&#123;% post_link 文章文件名（不要后缀） 文章标题（可选） %&#125; 如何设置「阅读全文」？1在文章中使用 &lt;!-- more --&gt; 手动进行截断，Hexo 提供的方式 推荐 内置标签设置：click me 取消“文章目录”对标题的自动编号？打开next主题下的配置文件 修改 toc：下配置 1234567891011toc: enable: true \# Automatically add list number to toc. number: false \# If true, all words will placed on next lines if header width longer then sidebar width. wrap: false 博客添加点击爱心效果参考博客 hexo next 配置 DaoVoice 实现在线聊天功能参考博客 网站底部字数统计 安装hexo插件，切换到根目录： 1npm install hexo-wordcount --save 在Blog/themes/next/layout/_partials/footer.swig末尾添加代码： 1234&lt;div class="theme-info"&gt; &lt;div class="powered-by"&gt;&lt;/div&gt; &lt;span class="post-count"&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 坑点1–全局语言配置全局配置文件 中关于站点语言配置 language: zh-Hans（我的配置为zh-CN会出问题） 坑点2 –百度分享功能实现123baidushare:type: slidebaidushare: true 解决百度分享https无法使用 NexT Pisces主题内容区宽度更改直接在source/css/_variables/custom.styl中使用Scheme Gemini 的参数即可 12$main-desktop = 75%$content-desktop = calc(100% - 252px) hexo页脚添加访客人数和总访问量参考博客 不蒜子访问统计官网 hexo 代码高亮问题在站点的配置文件中，搜索hightlight: 12345highlight: enable: true line_number: true auto_detect: true tab_replace: 文字自动检测默认不启动，所以改成true使其起作用。 再到主题的配置文件： highlight_theme: normal，注释显示有五种显示主题可用，分别是： normal night night eighties night blue night bright 包裹代码块方式 ```java 代码块 ``` 注意C# 是无效的的 一定要 csharp 代码拷贝功能实现代码块复制功能 #增加宠物 配置需要丢到站点配置文件中，不然不能切换图像项目地址]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客]]></title>
    <url>%2F2019%2F02%2F13%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[开始搭建属于自己的博客吧！ 背景​ 网上有很多github hexo搭建个人博客的教程，翻阅好多篇博客，简单熟悉以后发现官网教程带视频手把手更详细，更容易理解，不过对于初学者，很晕，不知从哪里看起，从上往下看，肯定是不可取的，在此留下官网资料学习步骤。 hexo官网1https://hexo.io/zh-cn/ 学习步骤 进入文档页面 概述 —了解hexo 建站 —个人博客的安装与本地查看 写作 —学习新建一篇博文、草稿、page页面(网页页面) Front-matter —-文件开头的一个YAML或JSON块，用于为您的文章配置设置 配置 —-在 _config.yml 中修改自己站点的配置 后期注意点 更换主题 写博客的本地图片资源文件夹 命令 —- 了解基本的建站 写作 生成静态资源 部署到类似github的网站命令 部署 —安装自动部署插件 设置部署地点 至此基本写作和部署完成 后续学习 更换博客主题 搭建多台电脑写博客 博客里面插入图片 Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake hexo博客进阶配置 hexo博客进阶配置]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 基本使用]]></title>
    <url>%2F2019%2F02%2F12%2FMarkdown-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[程序员怎么能不会Markdown基本用法 Markdown是什么？Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。 为什么要使用它？ 它是易读（看起来舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子。 兼容HTML，可以转换为HTML格式发布。 跨平台使用。 越来越多的网站支持Markdown。 更方便清晰地组织你的电子邮件。（Markdown-here, Airmail） 摆脱Word（我不是认真的）。 怎么使用？Markdown语法主要分为如下几大部分： 标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \，符号’`’。 标题Markdown支持6种级别的标题，对应html标签 h1 ~ h6 123456# h1## h2### h3#### h4##### h5###### h6 段落需要记住的是，Markdown其实就是一种易于编写的普通文本，只不过加入了部分渲染文本的标签而已。其最终依然会转换为html标签，因此使用Markdown分段非常简单，前后至少保留一个空行即可。 区块引用而另外一个比较常见的需求就是，我们可能希望对某段文字进行强调处理。Markdown提供了一个特殊符号&gt;用于段首进行强调，被强调的文字部分将会高亮显示 &gt; 这段文字将被高亮显示... 以上标记显示效果如下： 这段文字将被高亮显示… 在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如： > 区块引用>&gt; 嵌套引用 效果： 区块引用 嵌套引用 代码区块代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如普通段落： void main(){printf(“Hello, Markdown.”);} 代码区块： 1234void main()&#123; printf("Hello, Markdown.");&#125; 注意: 需要和普通段落之间存在空行。 强调在强调内容两侧分别加上*或者_，如： *斜体*，_斜体_**粗体**，__粗体__ 效果： 斜体，斜体粗体，粗体 列表Markdown支持有序列表和无序列表两种形式： 无序列表使用*或+或-标识 有序列表使用数字加.标识，例如：1. 123456789101112131415* 黄瓜* 玉米* 茄子+ 黄瓜+ 玉米+ 茄子- 黄瓜- 玉米- 茄子1. 黄瓜2. 玉米3. 茄子 以上标记显示效果如下： 黄瓜 玉米 茄子 黄瓜 玉米 茄子 黄瓜 玉米 茄子 黄瓜 玉米 茄子 分割线分割线最常使用就是三个或以上*，还可以使用-和_。 链接和图片Markdown针对链接和图片的处理也比较简单，可以使用下面的语法进行标记 12[点击跳转至百度](http://www.baidu.com)![图片](https://upload-images.jianshu.io/upload_images/703764-605e3cc2ecb664f6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 以上标记显示效果如下： 点击跳转至百度 注： 引用图片和链接的唯一区别就是在最前方添加一个感叹号。 反斜杠\相当于反转义作用。使符号成为普通符号。 符号 `起到标记作用。如： `ctrl+a` 效果： ctrl+a Markdown软件推荐手动去敲，有时还是挺麻烦的，推荐使用markdown软件编写文章，省去一些繁琐的工作 windows 推荐 typora typora官网mac 推荐 Macdown]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[右键-git bash here 还原！]]></title>
    <url>%2F2019%2F02%2F12%2F%E5%8F%B3%E9%94%AE%20git%20bash%20here%20%E8%BF%98%E5%8E%9F%EF%BC%81%2F</url>
    <content type="text"><![CDATA[召唤右键菜单git bash here ​问题场景​ 有时由于安装操作不当，或者后期一些优化软件，导致安装了git 然而鼠标右键菜单中没有git bash here ，每次都需要手动切入到相应的目录再进行操作，很不方便。 解决思路手动编辑注册表，添加到右键菜单 具体步骤具体注册表操作: 点击我查看链接 其他说明 建议安装Everything.exe 软件 方便查找到底安装在那个盘的那个位置]]></content>
      <categories>
        <category>注册表操作</category>
      </categories>
      <tags>
        <tag>注册表操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[右键-以VsCode打开]]></title>
    <url>%2F2019%2F02%2F11%2F%E5%8F%B3%E9%94%AE-%E4%BB%A5VsCode%E6%89%93%E5%BC%80%2F</url>
    <content type="text"><![CDATA[召唤右键菜单 用VsCode打开~ 操作说明 新建文本文件 将下面内容拷贝到文本中 改后缀名为xxx.reg形式 点击运行，同意写注册表 1234567891011121314151617181920212223242526Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\*\shell\VSCode]@="Open with Code""Icon"="C:\\Program Files\\Microsoft VS Code\\Code.exe"[HKEY_CLASSES_ROOT\*\shell\VSCode\command]@="\"C:\\Program Files\\Microsoft VS Code\\Code.exe\" \"%1\""Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\shell\VSCode]@="Open with Code""Icon"="C:\\Program Files\\Microsoft VS Code\\Code.exe"[HKEY_CLASSES_ROOT\Directory\shell\VSCode\command]@="\"C:\\Program Files\\Microsoft VS Code\\Code.exe\" \"%V\""Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\Background\shell\VSCode]@="Open with Code""Icon"="C:\\Program Files\\Microsoft VS Code\\Code.exe"[HKEY_CLASSES_ROOT\Directory\Background\shell\VSCode\command]@="\"C:\\Program Files\\Microsoft VS Code\\Code.exe\" \"%V\""]]></content>
      <categories>
        <category>注册表操作</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>右键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[右键-在此处打开CMD]]></title>
    <url>%2F2019%2F02%2F11%2F%E5%8F%B3%E9%94%AE-%E5%9C%A8%E6%AD%A4%E5%A4%84%E6%89%93%E5%BC%80CMD%2F</url>
    <content type="text"><![CDATA[召唤右键菜单 Open CMD in Here~ 操作说明新建文本文件，将后缀改为reg 然后点击运行 确认修改注册表 1234567891011121314151617181920212223242526272829Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\shell\OpenCmdHere]@="Open CMD in Here""Icon"="cmd.exe"[HKEY_CLASSES_ROOT\Directory\shell\OpenCmdHere\command]@="cmd.exe /s /k pushd "%V""[HKEY_CLASSES_ROOT\Directory\Background\shell\OpenCmdHere]@="Open CMD in Here""Icon"="cmd.exe"[HKEY_CLASSES_ROOT\Directory\Background\shell\OpenCmdHere\command]@="cmd.exe /s /k pushd \"%V\""[HKEY_CLASSES_ROOT\Drive\shell\OpenCmdHere]@="Open CMD in Here""Icon"="cmd.exe"[HKEY_CLASSES_ROOT\Drive\shell\OpenCmdHere\command]@="cmd.exe /s /k pushd \"%V\""[HKEY_CLASSES_ROOT\LibraryFolder\background\shell\OpenCmdHere]@="Open CMD in Here""Icon"="cmd.exe"[HKEY_CLASSES_ROOT\LibraryFolder\background\shell\OpenCmdHere\command]@="cmd.exe /s /k pushd \"%V\""]]></content>
      <categories>
        <category>注册表操作</category>
      </categories>
      <tags>
        <tag>右键</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[我来的第一天~ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Create a new post1hexo new "My New Post" More info: Writing Run server1hexo server More info: Server Generate static files1hexo generate More info: Generating Deploy to remote sites1hexo deploy More info: Deployment]]></content>
  </entry>
</search>
