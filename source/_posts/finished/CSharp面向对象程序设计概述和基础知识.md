---
title: 'C#面向对象程序设计概述和基础知识'
date: 2019-02-20 15:43:02
tags:
---
{% centerquote %}了解C#语言历史、编程工具、运行原理、基础语法...... {% endcenterquote %}
<!-- more -->

# C#与.NET来世今生

## C#语言编程史

![1546389559869](CSharp面向对象程序设计概述和基础知识/1546389559869.png)

![1546389592746](CSharp面向对象程序设计概述和基础知识/1546389592746.png)

## Windows与.NET技术发展的历程及趋势

![1546389619546](CSharp面向对象程序设计概述和基础知识/1546389619546.png)

![1546389660112](CSharp面向对象程序设计概述和基础知识/1546389660112.png)

## 什么是.NET

![1546389722280](CSharp面向对象程序设计概述和基础知识/1546389722280.png)

![1546389773167](CSharp面向对象程序设计概述和基础知识/1546389773167.png)

![1546389812808](CSharp面向对象程序设计概述和基础知识/1546389812808.png)

![1546389835536](CSharp面向对象程序设计概述和基础知识/1546389835536.png)

![1546389857713](CSharp面向对象程序设计概述和基础知识/1546389857713.png)

![1546389876625](CSharp面向对象程序设计概述和基础知识/1546389876625.png)

![1546389909745](CSharp面向对象程序设计概述和基础知识/1546389909745.png)

![1546389954416](CSharp面向对象程序设计概述和基础知识/1546389954416.png)

![1546389975257](CSharp面向对象程序设计概述和基础知识/1546389975257.png)

![1546389999575](CSharp面向对象程序设计概述和基础知识/1546389999575.png)

# 使用VisualStudio编程工具

## 认识Visual Studio

![1546390079092](CSharp面向对象程序设计概述和基础知识/1546390079092.png)

![1546390093063](CSharp面向对象程序设计概述和基础知识/1546390093063.png)

![1546390116929](CSharp面向对象程序设计概述和基础知识/1546390116929.png)

![1546390170071](CSharp面向对象程序设计概述和基础知识/1546390170071.png)

![1546390201105](CSharp面向对象程序设计概述和基础知识/1546390201105.png)

![1546390271330](CSharp面向对象程序设计概述和基础知识/1546390271330.png)

## Console的重要属性

![1546390296152](CSharp面向对象程序设计概述和基础知识/1546390296152.png)

## 控制台窗口的输入与输出

![1546390318417](CSharp面向对象程序设计概述和基础知识/1546390318417.png)

![1546390345556](CSharp面向对象程序设计概述和基础知识/1546390345556.png)

## ReadKey和Beep

![1546390446608](CSharp面向对象程序设计概述和基础知识/1546390446608.png)

![1546390506031](CSharp面向对象程序设计概述和基础知识/1546390506031.png)

![1546390540624](CSharp面向对象程序设计概述和基础知识/1546390540624.png)

## 程序调试基本技巧

![1546390575009](CSharp面向对象程序设计概述和基础知识/1546390575009.png)

![1546390591624](CSharp面向对象程序设计概述和基础知识/1546390591624.png)

## C#与Visual Studio编程须知

### 基本编程规则

![1546390635721](CSharp面向对象程序设计概述和基础知识/1546390635721.png)

### 文件组织方式

![1546390672353](CSharp面向对象程序设计概述和基础知识/1546390672353.png)

### 行号、颜色、字体大小

![1546390714321](CSharp面向对象程序设计概述和基础知识/1546390714321.png)

![1546390731616](CSharp面向对象程序设计概述和基础知识/1546390731616.png)

![1546390749731](CSharp面向对象程序设计概述和基础知识/1546390749731.png)

# 面向对象概述与.NET运行原理

## 面向对象编程概述

![1546390825936](CSharp面向对象程序设计概述和基础知识/1546390825936.png)

![1546390838719](CSharp面向对象程序设计概述和基础知识/1546390838719.png)

![1546390853519](CSharp面向对象程序设计概述和基础知识/1546390853519.png)

![1546390994768](CSharp面向对象程序设计概述和基础知识/1546390994768.png)

## 程序是如何被计算机执行的？

![1546391086946](CSharp面向对象程序设计概述和基础知识/1546391086946.png)

![1546391124229](CSharp面向对象程序设计概述和基础知识/1546391124229.png)

![1546391207809](CSharp面向对象程序设计概述和基础知识/1546391207809.png)

![1546391234762](CSharp面向对象程序设计概述和基础知识/1546391234762.png)

![1546391252960](CSharp面向对象程序设计概述和基础知识/1546391252960.png)

![1546391268358](CSharp面向对象程序设计概述和基础知识/1546391268358.png)

![1546391325695](CSharp面向对象程序设计概述和基础知识/1546391325695.png)

![1546391351641](CSharp面向对象程序设计概述和基础知识/1546391351641.png)

![1546391371283](CSharp面向对象程序设计概述和基础知识/1546391371283.png)

![1546391393778](CSharp面向对象程序设计概述和基础知识/1546391393778.png)

![1546391426272](CSharp面向对象程序设计概述和基础知识/1546391426272.png)

## 如何编写计算机可以执行的程序？

![1546391474068](CSharp面向对象程序设计概述和基础知识/1546391474068.png)

![1546391510979](CSharp面向对象程序设计概述和基础知识/1546391510979.png)

![1546391535130](CSharp面向对象程序设计概述和基础知识/1546391535130.png)

![1546391550847](CSharp面向对象程序设计概述和基础知识/1546391550847.png)

![1546391589697](CSharp面向对象程序设计概述和基础知识/1546391589697.png)

![1546391612321](CSharp面向对象程序设计概述和基础知识/1546391612321.png)

![1546391628640](CSharp面向对象程序设计概述和基础知识/1546391628640.png)

## 怎样构造求解问题的算法？

![1546391893409](CSharp面向对象程序设计概述和基础知识/1546391893409.png)

## 日期计算结构化编程的实现

![1546391916319](CSharp面向对象程序设计概述和基础知识/1546391916319.png)

![1546391930542](CSharp面向对象程序设计概述和基础知识/1546391930542.png)

![1546391940964](CSharp面向对象程序设计概述和基础知识/1546391940964.png)

![1546391999855](CSharp面向对象程序设计概述和基础知识/1546391999855.png)

![1546392044977](CSharp面向对象程序设计概述和基础知识/1546392044977.png)

![1546392062497](CSharp面向对象程序设计概述和基础知识/1546392062497.png)

![1546392079601](CSharp面向对象程序设计概述和基础知识/1546392079601.png)

![1546392125218](CSharp面向对象程序设计概述和基础知识/1546392125218.png)

![1546392154640](CSharp面向对象程序设计概述和基础知识/1546392154640.png)

![1546392169557](CSharp面向对象程序设计概述和基础知识/1546392169557.png)

![1546392233561](CSharp面向对象程序设计概述和基础知识/1546392233561.png)

![1546392259505](CSharp面向对象程序设计概述和基础知识/1546392259505.png)

![1546392275155](CSharp面向对象程序设计概述和基础知识/1546392275155.png)

## 日期计算面向对象编程的实现

![1546392314334](CSharp面向对象程序设计概述和基础知识/1546392314334.png)

![1546392347122](CSharp面向对象程序设计概述和基础知识/1546392347122.png)

![1546392371120](CSharp面向对象程序设计概述和基础知识/1546392371120.png)

# 变量、数据类型与表达式

## 理解变量

![1546392965221](CSharp面向对象程序设计概述和基础知识/1546392965221.png)

![1546392980946](CSharp面向对象程序设计概述和基础知识/1546392980946.png)

![1546392991943](CSharp面向对象程序设计概述和基础知识/1546392991943.png)

![1546393085820](CSharp面向对象程序设计概述和基础知识/1546393085820.png)

![1546393110146](CSharp面向对象程序设计概述和基础知识/1546393110146.png)

![1546393172514](CSharp面向对象程序设计概述和基础知识/1546393172514.png)

![1546393296312](CSharp面向对象程序设计概述和基础知识/1546393296312.png)

![1546393331011](CSharp面向对象程序设计概述和基础知识/1546393331011.png)

![1546393364837](CSharp面向对象程序设计概述和基础知识/1546393364837.png)

![1546393399122](CSharp面向对象程序设计概述和基础知识/1546393399122.png)

## 数据类型

![1546393428036](CSharp面向对象程序设计概述和基础知识/1546393428036.png)

![1546393448400](CSharp面向对象程序设计概述和基础知识/1546393448400.png)

![1546393483377](CSharp面向对象程序设计概述和基础知识/1546393483377.png)

## String和Var

![1546393504047](CSharp面向对象程序设计概述和基础知识/1546393504047.png)

![1546393556235](CSharp面向对象程序设计概述和基础知识/1546393556235.png)

## 变量与内存

![1546393595506](CSharp面向对象程序设计概述和基础知识/1546393595506.png)

![1546393618993](CSharp面向对象程序设计概述和基础知识/1546393618993.png)

## 数据类型转换

![1546393700826](CSharp面向对象程序设计概述和基础知识/1546393700826.png)

![1546393717205](CSharp面向对象程序设计概述和基础知识/1546393717205.png)

## 运算符与表达式

![1546393738129](CSharp面向对象程序设计概述和基础知识/1546393738129.png)

![1546393767186](CSharp面向对象程序设计概述和基础知识/1546393767186.png)

![1546393902498](CSharp面向对象程序设计概述和基础知识/1546393902498.png)

# 选择结构与逻辑表达式

![1546394106770](CSharp面向对象程序设计概述和基础知识/1546394106770.png)

![1546394127862](CSharp面向对象程序设计概述和基础知识/1546394127862.png)

## if/else 选择结构

![1546394144689](CSharp面向对象程序设计概述和基础知识/1546394144689.png)

![1546394199546](CSharp面向对象程序设计概述和基础知识/1546394199546.png)

![1546394215946](CSharp面向对象程序设计概述和基础知识/1546394215946.png)

## 选择结构的嵌套

![1546394245953](CSharp面向对象程序设计概述和基础知识/1546394245953.png)

![1546394259400](CSharp面向对象程序设计概述和基础知识/1546394259400.png)

## 逻辑表达式的组合

![1546394319458](CSharp面向对象程序设计概述和基础知识/1546394319458.png)

![1546394350049](CSharp面向对象程序设计概述和基础知识/1546394350049.png)

## 多分支结构

![1546394393921](CSharp面向对象程序设计概述和基础知识/1546394393921.png)

![1546394407494](CSharp面向对象程序设计概述和基础知识/1546394407494.png)

# 循环结构

![1546394557472](CSharp面向对象程序设计概述和基础知识/1546394557472.png)

## while/do 循环

![1546394599622](CSharp面向对象程序设计概述和基础知识/1546394599622.png)

![1546394619201](CSharp面向对象程序设计概述和基础知识/1546394619201.png)

![1546394677410](CSharp面向对象程序设计概述和基础知识/1546394677410.png)

```csharp
     static void InputQuitToStop()
        {
            string userInput = "";

            while (userInput.ToLower() != "quit")
            {
                Console.WriteLine("\n不断输入字符串，回车结束一次输入。不想再运行程序时，输入quit。");
                userInput = Console.ReadLine();
                if (string.IsNullOrEmpty(userInput) == false)
                {
                    Console.WriteLine("您输入了：{0}", userInput);
                }
            }
            Console.WriteLine("\n---------------------------------------------");
            Console.WriteLine("\n检测到quit命令，循环中止，敲任意键退出……");
        }
```

![1546394692484](CSharp面向对象程序设计概述和基础知识/1546394692484.png)

## for循环

![1546394712306](CSharp面向对象程序设计概述和基础知识/1546394712306.png)

## Break和Continue

![1546394729970](CSharp面向对象程序设计概述和基础知识/1546394729970.png)

```csharp
        /// <summary>
        /// 理解Break和Continue的不同作用
        /// </summary>
        static void BreakAndContinue()
        {
            for (int i = 1; i <= 10; i++)
            {
                if (i == 5)
                {
                    //切换以下两句的注释，体会它们的不同作用
                    //continue;
                    break;

                }
                Console.WriteLine("第{0}轮循环", i);
            }
        }
```

![1546394750339](CSharp面向对象程序设计概述和基础知识/1546394750339.png)

![1546394771080](CSharp面向对象程序设计概述和基础知识/1546394771080.png)

![1546394800546](CSharp面向对象程序设计概述和基础知识/1546394800546.png)

## foreach循环

![1546394817328](CSharp面向对象程序设计概述和基础知识/1546394817328.png)

![1546394842722](CSharp面向对象程序设计概述和基础知识/1546394842722.png)

![1546394889418](CSharp面向对象程序设计概述和基础知识/1546394889418.png)

![1546394901409](CSharp面向对象程序设计概述和基础知识/1546394901409.png)

![1546394914049](CSharp面向对象程序设计概述和基础知识/1546394914049.png)

## 控制台程序编程小技巧

![1546395012225](CSharp面向对象程序设计概述和基础知识/1546395012225.png)

  ```csharp
  //测试如何检测按键
        static void testKey()
        {
            Console.WriteLine("随意敲任意键查看其键值，压ESC退出");
            ConsoleKeyInfo key;
            do
            {
                //用户敲了按键了吗？
                while (!Console.KeyAvailable)
                {
                    //啥也不干，等待……
                }
                //等待用户击键
                key = Console.ReadKey(true);
                Console.WriteLine();//输出一个空行
                Console.WriteLine("Modifiers值={0}", key.Modifiers);
                Console.WriteLine("KeyChar值={0}", (int)(key.KeyChar));
                Console.WriteLine("Key值={0}", key.Key);
                //CapsLock这个键是不能被捕获的，但我们可以检测出键盘的状态
                if (Console.CapsLock)
                {
                    Console.WriteLine("处于大写状态");
                }
                //NumberLock这个键是不能被捕获的，但我们可以检测出键盘的状态
                if (Console.NumberLock)
                {
                    Console.WriteLine("小键盘上的Num Lock键被按下");
                }
                //检测控制键
                if (key.Modifiers != 0)
                {
                    if ((key.Modifiers & ConsoleModifiers.Alt) != 0)
                    {
                        Console.WriteLine("Alt键被按下");
                    }
                    if ((key.Modifiers & ConsoleModifiers.Control) != 0)
                    {
                        Console.WriteLine("Ctrl键被按下");
                    }
                    if ((key.Modifiers & ConsoleModifiers.Shift) != 0)
                    {
                        Console.WriteLine("Shift键被按下");
                    }
                }
            } while (key.Key != ConsoleKey.Escape);
            Console.WriteLine("\n检测到ESC键，敲任意键退出……\n");
        }
  ```

![1546395031586](CSharp面向对象程序设计概述和基础知识/1546395031586.png)

![1546395043666](CSharp面向对象程序设计概述和基础知识/1546395043666.png)

```c#
        /// <summary>
        /// 展示系统内置的强制中止控制台程序的功能
        /// </summary>
        static void QuitConsoleApp()
        {
            Console.WriteLine("死循环：请使用Ctrl+C或Ctrl+Break强制中止本程序");
            while (true)
            {
                Console.WriteLine("当前时间：" + DateTime.Now.ToLocalTime());
                Thread.Sleep(2000);
            }
        }


        /// <summary>
        /// 禁用Ctrl+C
        /// </summary>
        static void DisableControlC()
        {
            Console.WriteLine("本程序只能通过ESC键结束，无法通过Ctrl+C而中止");
            Console.TreatControlCAsInput = true;
            do
            {
                var key = Console.ReadKey(true);

                if (key.Key == ConsoleKey.Escape)
                {
                    Console.WriteLine("检测到ESC键，敲任意键退出……");
                    break;
                }
            } while (true);

        }
```

![1546395057109](CSharp面向对象程序设计概述和基础知识/1546395057109.png)

```csharp
       /// <summary>
        /// 响应UseCancelKeyPress事件，屏蔽掉Ctrl+C和Ctrl+Break
        /// </summary>
        static void UseCancelKeyPress()
        {
            Console.WriteLine("本程序只能通过ESC键结束");
            //响应CancelKeyPress事件（即Ctrl+C和Ctrl+Break被按下）
            Console.CancelKeyPress += Console_CancelKeyPress;

            do
            {
                var key = Console.ReadKey(true);

                if (key.Key == ConsoleKey.Escape)
                {
                    Console.WriteLine("\n检测到ESC键，敲任意键退出……");
                    break;
                }
                if (key.KeyChar != '\0')
                {
                    if (key.Key == ConsoleKey.Enter)
                    {
                        Console.WriteLine();
                    }
                    else
                    {
                        Console.Write(key.KeyChar);
                    }
                }
            } while (true);

        }
        private static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {
            var isCtrlC = e.SpecialKey == ConsoleSpecialKey.ControlC;
            var isCtrlBreak = e.SpecialKey == ConsoleSpecialKey.ControlBreak;
            //如果是Ctrl+C和Ctrl+Break
            if (isCtrlC || isCtrlBreak)
            {
                //屏蔽掉它们，让它们不起作用
                e.Cancel = true;
                //通知用户，Ctrl+C和Ctrl+Break已经不起作用了……
                Console.WriteLine(isCtrlC ? "Ctrl+C已被屏蔽" : "Ctrl+Break已被屏蔽");
            }
        }
```

# 方法

![1546397463155](CSharp面向对象程序设计概述和基础知识/1546397463155.png)

![1546397488532](CSharp面向对象程序设计概述和基础知识/1546397488532.png)

## 方法定义与调用

![1546397518449](CSharp面向对象程序设计概述和基础知识/1546397518449.png)

![1546397529417](CSharp面向对象程序设计概述和基础知识/1546397529417.png)

![1546397541894](CSharp面向对象程序设计概述和基础知识/1546397541894.png)

## 方法重载

![1546397588627](CSharp面向对象程序设计概述和基础知识/1546397588627.png)

![1546397601156](CSharp面向对象程序设计概述和基础知识/1546397601156.png)

![1546397618210](CSharp面向对象程序设计概述和基础知识/1546397618210.png)

## 方法应用实例

![1546397655907](CSharp面向对象程序设计概述和基础知识/1546397655907.png)

```csharp
namespace ShowPicInForm
{
    public partial class frmMain : Form
    {
        public frmMain()
        {
            InitializeComponent();
        }

        private void LoadPicture()
        {
            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                string FileName = openFileDialog1.FileName;
                picImage.ImageLocation = FileName;
            }
        }

        private void btnLoadPic_Click(object sender, EventArgs e)
        {
            LoadPicture();
        }
    }
}
```

![1546397672452](CSharp面向对象程序设计概述和基础知识/1546397672452.png)

![1546397688658](CSharp面向对象程序设计概述和基础知识/1546397688658.png)

```csharp
namespace Pseudorandom
{
    public partial class frmMain : Form
    {
        public frmMain()
        {
            InitializeComponent();
        }
        private float a = 3; //乘数,注意，a>=2 and a<m
        private int m = 100;  //模
        private float c = 4;  //增量，注意，c>=0 and c<m

        //依据公式计算出下一个随机数
        private float GetNextRanNumber(int m, float a, float c, float prevNum)
        {
            return (a * prevNum + c) % m;
        }

        //按指定的种子Seed生成nums个随机数
        private void GenerateRandomSequence(int nums, float seed)
        {
            float lastNum, nextNum;
            lastNum = seed;
            //清空富文本框
            RichTextBox1.Clear();
            //追加字符串到富文本框中
            RichTextBox1.AppendText(seed.ToString());
            for (int i = 0; i < nums; i++)
            {
                nextNum = GetNextRanNumber(m, a, c, lastNum);
                RichTextBox1.AppendText(" ," + nextNum);
                lastNum = nextNum;
            }
        }

        private void btnGenerate_Click(object sender, EventArgs e)
        {
            int nums = Convert.ToInt32(txtNumbers.Text);
            float seed = Convert.ToSingle(txtSeed.Text);
            GenerateRandomSequence(nums, seed);
        }

    }
}
```

![1546397703011](CSharp面向对象程序设计概述和基础知识/1546397703011.png)

![1546397713944](CSharp面向对象程序设计概述和基础知识/1546397713944.png)

# 递归

## 递归概述

![1546398770187](CSharp面向对象程序设计概述和基础知识/1546398770187.png)

![1546398790146](CSharp面向对象程序设计概述和基础知识/1546398790146.png)

![1546398810002](CSharp面向对象程序设计概述和基础知识/1546398810002.png)

![1546398825173](CSharp面向对象程序设计概述和基础知识/1546398825173.png)

![1546398854502](CSharp面向对象程序设计概述和基础知识/1546398854502.png)

![1546398890935](CSharp面向对象程序设计概述和基础知识/1546398890935.png)

![1546398921218](CSharp面向对象程序设计概述和基础知识/1546398921218.png)

## 递归编程技巧

![1546398939874](CSharp面向对象程序设计概述和基础知识/1546398939874.png)

![1546398967507](CSharp面向对象程序设计概述和基础知识/1546398967507.png)

```csharp
namespace CalculateN
{
    public partial class frmCalculate : Form
    {
        public frmCalculate()
        {
            InitializeComponent();
        }

        private void btnCalculate_Click(object sender, EventArgs e)
        {
            int n = Convert.ToInt32(txtN.Text);
            lblResult.Text = n.ToString()+"!="+Factorial(n).ToString();
            //lblResult.Text = n.ToString() + "!=" + Factorial2(n).ToString();

        }
        //计算n!，用递归实现
        private long Factorial(int n)
        {
            if (n == 1)
               return 1;
            long ret;
            ret = Factorial(n - 1) * n;
            return ret;

        }
        //计算n!，用递推实现
        private long Factorial2(int n)
        {
            long result = 1;
            for(int i = 1; i <= n; i++)
            {
                result *= i;
            }
            return result;
        }
    }
}
```

![1546398977594](CSharp面向对象程序设计概述和基础知识/1546398977594.png)

![1546399025219](CSharp面向对象程序设计概述和基础知识/1546399025219.png)

![1546399056898](CSharp面向对象程序设计概述和基础知识/1546399056898.png)

![1546399105890](CSharp面向对象程序设计概述和基础知识/1546399105890.png)

![1546399120954](CSharp面向对象程序设计概述和基础知识/1546399120954.png)

```csharp
namespace Recursion
{
    public partial class frmMain : Form
    {
        public frmMain()
        {
            InitializeComponent();
        }
        private string Story = "";

        //故事主体：
        private void WriteStory()
        {
            Story = "从前有座山，山里有座庙。\n";
            Story += "庙里有两个和尚，在讲故事。\n";
            Story += "讲什么故事呢？……\n";
        }

        private void btnExecute_Click(object sender, EventArgs e)
        {
            //清空文本
            RichTextBox1.Text = "";
            //老和尚开始没完没了地讲故事
            DoRecursion((int)updnTimes.Value);
        }
        //用于实现递归调用
        private void DoRecursion(int times)
        {
            //结束条件
            if (times == 0)
                return;

            //每次递归调用时要完成的工作
            //to do: 如果将以下这两句移到DoRecursion()一句之后，
            //       会发生什么？
            //RichTextBox1.AppendText("第 " + times + " 次\n");
            //RichTextBox1.AppendText(Story);

            //递归调用，参数减一
            DoRecursion(times - 1);

            //////每次递归调用时要完成的工作
            RichTextBox1.AppendText("第 " + times + " 次\n");
            RichTextBox1.AppendText(Story);

        }
        private void Form1_Load(object sender, EventArgs e)
        {
            //把故事主体写好
            WriteStory();
        }
    }
}
```

![1546399139078](CSharp面向对象程序设计概述和基础知识/1546399139078.png)

## 处理大整数

![1546399156486](CSharp面向对象程序设计概述和基础知识/1546399156486.png)

![1546399166900](CSharp面向对象程序设计概述和基础知识/1546399166900.png)

![1546399177410](CSharp面向对象程序设计概述和基础知识/1546399177410.png)

![1546399192195](CSharp面向对象程序设计概述和基础知识/1546399192195.png)

```csharp
namespace GetFibonacciNumber
{
    public partial class frmMain : Form
    {
        public frmMain()
        {
            InitializeComponent();
            ShowCalculateResult();
        }
        private long FibonacciUseLong(int NumberIndex)
        {
            long previousValue = -1;
            long currentResult = 1;
            for (var i = 0; i <= NumberIndex; ++i)
            {
                if (long.MaxValue - currentResult < previousValue)
                {
                    throw new OverflowException("超过了本计算机能计算的最大整数！");
                }
                long sum = currentResult + previousValue;
                previousValue = currentResult;
                currentResult = sum;
            }
            return currentResult;
        }

        private BigInteger FibonacciUseBigInteger(int NumberIndex)
        {
            BigInteger previousValue = -1;
            BigInteger currentResult = 1;
            for (var i = 0; i <= NumberIndex; ++i)
            {
                BigInteger sum = currentResult + previousValue;
                previousValue = currentResult;
                currentResult = sum;
            }
            return currentResult;
        }

        /// <summary>
        /// 显示计算结果
        /// </summary>
        private void ShowCalculateResult()
        {
            try
            {
                if (rdoLong.Checked)
                    lblResult.Text = FibonacciUseLong((int)numericUpDown1.Value).ToString();
                else
                    lblResult.Text = FibonacciUseBigInteger((int)numericUpDown1.Value).ToString();
            }
            catch (Exception ex)
            {
                lblResult.Text = ex.Message;
            }

        }

        private void numericUpDown1_ValueChanged(object sender, EventArgs e)
        {
            ShowCalculateResult();
        }

        private void radioButton1_CheckedChanged(object sender, EventArgs e)
        {
            ShowCalculateResult();
        }

        private void rdoLong_CheckedChanged(object sender, EventArgs e)
        {
            ShowCalculateResult();
        }

    }
}
```

## 浮点数的处理技巧

![1546399212099](CSharp面向对象程序设计概述和基础知识/1546399212099.png)

![1546399225714](CSharp面向对象程序设计概述和基础知识/1546399225714.png)

![1546399254579](CSharp面向对象程序设计概述和基础知识/1546399254579.png)
